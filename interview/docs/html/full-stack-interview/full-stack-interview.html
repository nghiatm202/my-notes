<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Interview 2022</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-opaquegray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="59b9f518-a807-46b2-a2aa-ce2d306411dd" class="page sans"><header><div class="page-header-icon undefined"><span class="icon">📖</span></div><h1 class="page-title">Interview 2022</h1></header><div class="page-body"><hr id="1af27826-8156-40d1-b8f4-044a379da9a9"/><ul id="2521cd36-9a0d-44c0-be58-812cf907afc9" class="toggle"><li><details open=""><summary><strong>Rest API questions</strong></summary><ol type="1" id="2f1f4c6f-b5df-4b45-9c8c-8bf6556a6bdd" class="numbered-list" start="1"><li><strong>What is rest?</strong><ul id="98aa5b76-aab3-45d7-a607-c4907ceed4f1" class="bulleted-list"><li style="list-style-type:disc">REST stands for Representational State Transfer. REST is an architectural style for web development. REST architecture lays out guidelines for the transfer of resource representations between clients and servers on the web.</li></ul></li></ol><ol type="1" id="ad65cf6e-2fb9-4e8b-b996-b80782aa6544" class="numbered-list" start="2"><li><strong><strong>What is a REST API?</strong></strong><ul id="da099353-35ef-4a77-8343-fde0acbd9837" class="bulleted-list"><li style="list-style-type:disc">A <em>REST API</em> or <em>RESTful API </em>is a web API that conforms to the REST architecture style.</li></ul></li></ol><ol type="1" id="145b0b2f-2bf9-4e39-99da-b4b71f119d0e" class="numbered-list" start="3"><li><strong><strong>Describe the 5 constraints of the REST architectural style, and their benefits</strong></strong><ul id="6e0fecf9-adea-4bb7-a450-beece40d9e81" class="bulleted-list"><li style="list-style-type:disc">Uniform interface</li></ul><ul id="a1940aba-23aa-427f-8408-cd7e04562b62" class="bulleted-list"><li style="list-style-type:disc">Client-server</li></ul><ul id="e3f94cea-6be8-44a0-bc3f-290db2d73380" class="bulleted-list"><li style="list-style-type:disc">Stateless</li></ul><ul id="67219c3c-c91c-4f3c-b420-125d823a5582" class="bulleted-list"><li style="list-style-type:disc">Cacheable</li></ul><ul id="8772c609-da24-4b1a-a399-77ae66e5abb0" class="bulleted-list"><li style="list-style-type:disc">Layered system</li></ul></li></ol><ol type="1" id="09a1110e-b334-4a7b-829c-391ab9c4e930" class="numbered-list" start="4"><li><strong><strong>Explain the HTTP request methods supported by REST, and when they are used.</strong></strong><ul id="b3e6df2c-58e3-4979-ba9e-1b97b31fba46" class="bulleted-list"><li style="list-style-type:disc"><strong>GET</strong> method: Request data from server</li></ul><ul id="79b0ce52-191b-408a-94b0-29a918deddf3" class="bulleted-list"><li style="list-style-type:disc"><strong>POST</strong> method: Submit data to create new resource on server-defined URL</li></ul><ul id="fe3f30ab-d5f3-40b1-b2e1-7891faa64535" class="bulleted-list"><li style="list-style-type:disc"><strong>PUT</strong> method: Submit data to update a resource at client-defined URL</li></ul><ul id="5a3d0dc5-3ccc-43da-a231-aab7269b0780" class="bulleted-list"><li style="list-style-type:disc"><strong>DELETE</strong> method: Remove resource from server</li></ul><ul id="a4eb899c-80bd-4ebf-b614-2302e38d36e9" class="bulleted-list"><li style="list-style-type:disc"><strong>OPTIONS</strong> method: Return request methods supported by a service</li></ul><ul id="1cbffaac-d3a1-4498-bb31-778e13556a0d" class="bulleted-list"><li style="list-style-type:disc"><strong>HEAD</strong> method: Return meta information such as response headers</li></ul><ul id="3fa64584-662c-49e9-9664-093e78afb4f2" class="bulleted-list"><li style="list-style-type:disc"><strong>PATCH</strong> method: Modify part of the resource on the server</li></ul></li></ol></details></li></ul><ul id="2e301384-9ab2-4597-bef4-b4478250766a" class="toggle"><li><details open=""><summary><strong>REACT &amp; VUE</strong></summary><ul id="0dad39ff-ecbf-4aa3-991a-9bf2e7ec8add" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>SPA, SSA, PWA</strong></mark></summary><p id="a35b1b71-0783-4b5b-9bfd-a217851ec2c4" class=""><a href="https://haodev.wordpress.com/2019/03/20/ssr-vs-csr/">https://haodev.wordpress.com/2019/03/20/ssr-vs-csr/</a></p><ul id="aec0c7a9-4880-436a-8283-3030e2623de9" class="bulleted-list"><li style="list-style-type:disc"><strong>Single Page Aplication</strong>: <ul id="95871d9a-de45-42e6-aba5-ce546c040d0c" class="bulleted-list"><li style="list-style-type:circle">Ứng dụng sẽ render HTML, CSS ở phía client, FE sẽ xử lý nhưng logic cơ bản như như get data, validation, navigate và render. Còn BE sẽ xử lý logic để lấy data và trả về cho client thông qua API.</li></ul><ul id="84bf922d-bf7b-4c35-841f-a0dcac810956" class="bulleted-list"><li style="list-style-type:circle">Pros:<ul id="bf84b1ab-e49d-491e-85fd-c8183606b193" class="bulleted-list"><li style="list-style-type:square">Ít tốn tài nguyên của hệ thống, vì client sẽ chịu trách nhiệm render</li></ul><ul id="7c52ab1d-fe17-4987-9efb-383dc60c4199" class="bulleted-list"><li style="list-style-type:square">Vì giao tiếp qua API nên lượng request đến server sẽ được giảm thiểu</li></ul><ul id="3cc6a362-93c0-4237-97b5-28122aca0ef7" class="bulleted-list"><li style="list-style-type:square">Nhanh, vì các HTML, css, JS, chỉ được tải 1 lần duy nhất</li></ul><ul id="826ea079-adac-4e62-962d-d1a8008a4adf" class="bulleted-list"><li style="list-style-type:square">Không cần phải load lại trang, làm tăng trải nghiệm người dùng.</li></ul></li></ul><ul id="5d3d5c04-ce1c-4e64-b4a2-f5eae906d370" class="bulleted-list"><li style="list-style-type:circle">Cons:<ul id="46f31bdc-f497-45a1-9af1-abd5c09da5ec" class="bulleted-list"><li style="list-style-type:square">Khó SEO vì nội dung web được render phía client</li></ul><ul id="1c65f3bb-5ca7-4f2a-88db-efff15ff167b" class="bulleted-list"><li style="list-style-type:square">Trình duyệt sẽ xử lý nhiều, nên vấn đề hiệu năng cần được chú ý</li></ul><ul id="52c1e736-eaed-45ad-8980-75b54a591015" class="bulleted-list"><li style="list-style-type:square"></li></ul></li></ul></li></ul><ul id="77af7002-80e8-4fe3-86f6-ba4af02055bc" class="bulleted-list"><li style="list-style-type:disc"><strong>Server Side Rendering</strong>: <ul id="1f91b7e8-4899-424a-b180-d315960e9ad8" class="bulleted-list"><li style="list-style-type:circle">Mọi logic về validation, đọc dữ liệu, navigate, hay render đều được xử lý ở phía server </li></ul><ul id="d5cfbf05-12aa-47e4-8373-287c5cb887f9" class="bulleted-list"><li style="list-style-type:circle">Cơ chế hoạt động: <ul id="bf257ecd-10ef-41bc-a304-b80d441e8aed" class="bulleted-list"><li style="list-style-type:square">Khi user vào trang web, browser gửi GET request tới server</li></ul><ul id="acac8ef7-ae75-40a5-a994-773073ebdd0c" class="bulleted-list"><li style="list-style-type:square">Server nhận request, đọc dữ liệu, truy vấn database, xử lí logic, ... </li></ul><ul id="a2c9b2bc-77af-4797-9ad2-9a8deeafd051" class="bulleted-list"><li style="list-style-type:square">Server sẽ render ra HTML và trả về cho client</li></ul></li></ul><ul id="d1b944cb-08a6-4f8f-bc04-ee215904a565" class="bulleted-list"><li style="list-style-type:circle">Pros: <ul id="5afcc4c6-d34d-40a9-bc00-84a5c07db730" class="bulleted-list"><li style="list-style-type:square">Hỗ trợ mạnh về SEO vì khi bot google, bing vào web sẽ thấy toàn bộ dữ liệu dưới dạng html</li></ul><ul id="b2ee38a2-dfe9-4f13-8203-3c43cf1442c4" class="bulleted-list"><li style="list-style-type:square">Initial load nhanh, dễ optimize vì toàn bộ dữ liệu đều đã được xử lý ở phía server, client chỉ render lại.</li></ul><ul id="19d1a2de-91b2-4f74-8e50-e50e37a283f6" class="bulleted-list"><li style="list-style-type:square">Sẽ rất thích hợp với những static page, có dữ liệu ít bị thay đổi</li></ul><ul id="272af7cc-51b1-4f68-ad22-148a4dbb67ef" class="bulleted-list"><li style="list-style-type:square">Chỉ cần code trong 1 project ko cần tách biệt ra FE và BE</li></ul></li></ul><ul id="778cf9b6-8a14-4426-b2c4-47bc4daaec17" class="bulleted-list"><li style="list-style-type:circle">Cons: <ul id="94f5ab0b-92fe-402c-965e-3473c1699497" class="bulleted-list"><li style="list-style-type:square">Web sẽ xử lý và load lại hoàn toàn nếu có một thay đổi nhỏ xảy ra</li></ul><ul id="6f331fa1-bc46-4a59-846a-5eed20330ee9" class="bulleted-list"><li style="list-style-type:square">Khi lượng traffic quá lớn, làm cho server nặng và quá tải vì mọi logic đều xử lý phía server </li></ul><ul id="2b07fdcd-d87e-479a-a1ff-b442438b67ab" class="bulleted-list"><li style="list-style-type:square">Trải nghiệm người dùng không tốt, vì trang web phải refresh và load lại nhiều lần</li></ul></li></ul></li></ul><ul id="ce39a0cb-7dcc-4bde-9019-f25ae317d005" class="bulleted-list"><li style="list-style-type:disc"><strong>Progressive web apps</strong><ul id="3cc61fbb-f7c2-479f-8aad-cc6ad4ea749c" class="bulleted-list"><li style="list-style-type:circle">Hiểu đơn giản PWA là cách làm cho web app trở nên ngon hơn, ngon ở đây là khả năng web app chưa làm được. </li></ul><ul id="5de666c4-86d8-4cb4-bbda-49658a6127f9" class="bulleted-list"><li style="list-style-type:circle">Hiện tại vấn đề lớn nhất mà web app chưa làm được đó là trải nghiệm chưa được mượt mà như native app</li></ul><ul id="6a960b06-5fde-45ac-bc02-314eab372dd7" class="bulleted-list"><li style="list-style-type:circle">Để làm được điều này PWA phải đảm bảo được 3 yếu tố:<ul id="bec6b3e9-5f90-4997-911e-7536e405c74a" class="bulleted-list"><li style="list-style-type:square">Reliable: app load nhanh và có thể dụng offline</li></ul><ul id="68327272-78b7-4aa0-800c-228355198ebe" class="bulleted-list"><li style="list-style-type:square">Fast: app phải load rất nhanh, nhấn cái chuyển trang liền hoặc animation load vù vù</li></ul><ul id="764e831a-e074-45a2-b19e-dbbbd8cbb0c8" class="bulleted-list"><li style="list-style-type:square">Engaging: có khả năng dụ user sử dụng. Có thể gửi notification, badge</li></ul></li></ul><ul id="3cf89304-8ab9-4d50-9bde-363950cd72fb" class="bulleted-list"><li style="list-style-type:circle">Nếu vậy sao không làm native app cho nhanh ? <ul id="de403524-3920-4b91-b27a-ac0977e84557" class="bulleted-list"><li style="list-style-type:square">Trên thực tế số lượng người dùng mobile sẽ nhiều hơn web, tuy nhiên thì mỗi user thường chỉ dùng những app top chart và trung bình 1 tháng chỉ cài thêm từ 1 hoặc 2 app.</li></ul><ul id="da142119-4ecf-4374-9e53-f81bfaf0c862" class="bulleted-list"><li style="list-style-type:square">Chi phí để tiếp cận 1 user và dụ user đó dùng app trên web sẽ rẻ hơn trên app (việc chạy quảng cáo trên web sẽ dễ dàng hơn)</li></ul><ul id="ca840996-a0fc-4606-b466-9bde07bf21bf" class="bulleted-list"><li style="list-style-type:square">Về mặt kỹ thuật: đỡ học 2 ngôn ngữ ios và android, có thể tạo bằng RN nhưng PWA sẽ tận dụng src code của web, RN thì không </li></ul></li></ul></li></ul></details></li></ul><ul id="55f65d58-0b7b-4c7a-9f71-9b3e5a95d436" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Phương pháp SEO</strong></mark></summary><ul id="58c5060b-1a7a-4fe5-b414-aa2f5de9fd85" class="bulleted-list"><li style="list-style-type:disc">Sử dụng thẻ &lt;title /&gt;</li></ul><ul id="ae4287c6-4001-4674-94ef-71282bf73905" class="bulleted-list"><li style="list-style-type:disc">Sử dụng thẻ meta description</li></ul><ul id="e1c45a1e-bfdf-4611-b1b8-b04a3fc8534b" class="bulleted-list"><li style="list-style-type:disc">Sử dụng những thẻ heading (h1 → h6)</li></ul><ul id="d8bee859-999d-4ccb-86dc-2ac5c8cec74f" class="bulleted-list"><li style="list-style-type:disc">Broken links: không nên để link của các trang ngừng hoạt động vì ảnh hưởng đến trải nghiệm người dùng cũng như ranking của trang</li></ul><ul id="d3940aac-3ab9-4848-a4e6-82b192de231e" class="bulleted-list"><li style="list-style-type:disc">Alt attribute image: khi image không thể hiển thị thì alt của image sẽ cung cấp thông tin thay thế</li></ul><ul id="2f34c64e-f7e7-42b7-9c17-3149f4be18dd" class="bulleted-list"><li style="list-style-type:disc">Sử dung các thẻ HTML5 như header, footer, main, section, nav, ... thay các thẻ div, span truyền thống để trang có ngữ nghĩa hơn cho các search engines</li></ul><ul id="e511a4ac-982f-48e8-add8-7323097e86af" class="bulleted-list"><li style="list-style-type:disc">Loại bỏ inline css trong các thẻ html</li></ul><ul id="d0862ca6-b5d0-4185-8f5d-7b64a30ea8b5" class="bulleted-list"><li style="list-style-type:disc">Tối ưu hoá url cho page, url nên chứa keyword liên quan, không nên chứa space hay kí tự đặc biệt</li></ul></details></li></ul><ul id="b58d8bef-d00b-4f3e-82ae-af2ace8582ae" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Babel</strong></mark></summary><ul id="4a7af501-b897-4fb9-9e14-b1b3bf0e1d02" class="bulleted-list"><li style="list-style-type:disc">Babel là một trình biên dịch Javascript (source code =&gt;output code), được dùng với mục đích chuyển đổi mã lệnh JavaScript được viết dựa trên tiêu chuẩn ECMAScript phiên bản mới (Như ES6, ES7,...) về phiên bản cũ hơn.</li></ul><ul id="9688670e-93be-4dfb-bbd7-f21788a7e4d0" class="bulleted-list"><li style="list-style-type:disc">Babel chạy trong 3 giai đoạn: parsing, transforming, and printing (Phân tích, chuyển đổi và in).</li></ul><ul id="24fae014-7af5-4205-84d4-dcae98050384" class="bulleted-list"><li style="list-style-type:disc"><strong>Tại sao lại cần sử dụng Babel?</strong><ul id="9f16e0bd-6a81-41e2-a06d-e828dd4e54d0" class="bulleted-list"><li style="list-style-type:circle">Ngôn ngữ JavaScript chủ yếu được chạy trên browser, còn browser thì có nhiều loại khác nhau như Chrome, Firefox, Internet Explore, Safari… tất cả đều có những quy định riêng để viết JavaScript. Nên khi code JavaScript của bạn có chạy ngon lành trên Chrome, thì chưa chắc có thể chạy được trên Internet Explore, Safari,...</li></ul><ul id="30b3f80f-45b7-4436-bf7d-c7b8566c3349" class="bulleted-list"><li style="list-style-type:circle">Phiên bản phổ biến của ECMASCript đang được nhiều trình duyệt hỗ trợ hiên nay là ES5. Phiên bản kế tiếp ES6 mặc dù đã được chính thức ra đời tuy nhiên lại mới chỉ được một số trình duyệt hỗ trợ và không hoàn toàn đầy đủ.</li></ul><ul id="c88afec2-ae60-4a34-a8f0-997934bcd274" class="bulleted-list"><li style="list-style-type:circle">Dễ hiểu, Babel là công cụ giúp ta viết code trên phiên bản <strong>ECMASCript mới</strong>, nhưng lại compiler ra phiên bản <strong>ECMASCript cũ </strong>để<strong> tất cả browser có thể đều chạy được.</strong></li></ul></li></ul></details></li></ul><ul id="79afd29e-6c79-44a7-ac77-f361b97ec3b5" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Design pattern common</strong></mark></summary><p id="0f0115e2-d9c5-40b9-b718-6568c8b9af92" class=""><a href="https://viblo.asia/p/react-patterns-phan-1-yMnKM1GEK7P">https://viblo.asia/p/react-patterns-phan-1-yMnKM1GEK7P</a></p><ul id="4c3bb554-0444-4019-9c5f-577edb12d608" class="bulleted-list"><li style="list-style-type:disc"><strong>React pattern: </strong><ul id="7a0ceb9d-d534-491a-b910-2a42aa627e1e" class="bulleted-list"><li style="list-style-type:circle"><a href="https://reactpatterns.js.org/docs/accessing-a-child-component">https://reactpatterns.js.org/docs/accessing-a-child-component</a></li></ul><ul id="afab050d-da68-4cd9-8977-8a4935b4f9ab" class="bulleted-list"><li style="list-style-type:circle"><a href="https://blog.openreplay.com/3-react-component-design-patterns-you-should-know-about">https://blog.openreplay.com/3-react-component-design-patterns-you-should-know-about</a></li></ul><ul id="8be1bdfd-1383-4383-93a7-db3045c6c33e" class="bulleted-list"><li style="list-style-type:circle">Proxy component: là component có thể tái sử dụng lại được</li></ul><ul id="082c2e58-a2c9-4901-914c-9a484cf19526" class="bulleted-list"><li style="list-style-type:circle">Call API in <strong>componentDidMount</strong></li></ul><ul id="0c43dd9d-b026-40ab-b05c-324a4c0fe0ce" class="bulleted-list"><li style="list-style-type:circle">Stateless function: là cách định nghĩa react component như 1 function thay vì class đồng thời nó  không giữ state chỉ nhận props truyền vào</li></ul><ul id="675ef00f-1aed-4040-967e-b4ddb1a3e0d2" class="bulleted-list"><li style="list-style-type:circle">Higher-order function: là 1 function return về 1 function khác hoặc nhận tham số là 1 function và return về function đó</li></ul><ul id="c26e89ff-54ba-4cee-a119-20a5c455d39c" class="bulleted-list"><li style="list-style-type:circle">Higher-order component: tương tự như HOF tuy nhiên nó return hoặc nhận vào tham số là component.</li></ul><ul id="cde1369e-677f-43ec-860e-9f091e84aef2" class="bulleted-list"><li style="list-style-type:circle">...</li></ul></li></ul><ul id="c9557e47-a7b7-483e-b72e-9d8ff8a74008" class="bulleted-list"><li style="list-style-type:disc"><strong>Vue: </strong><a href="https://learn-vuejs.github.io/vue-patterns/patterns/#component-declaration">https://learn-vuejs.github.io/vue-patterns/patterns/#component-declaration</a><ul id="4adf51c1-fee2-4d7d-a92b-b1f389022327" class="bulleted-list"><li style="list-style-type:circle">...</li></ul></li></ul></details></li></ul><ul id="88c26cf6-19bf-4406-a2aa-5c5b01092b29" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Compare react &amp; vue, cons, pros</strong></mark></summary><ul id="8bfb7f40-f84e-41ee-92c8-f2e65efbc4ce" class="bulleted-list"><li style="list-style-type:disc"></li></ul></details></li></ul><ul id="92dd6252-0a0e-42b0-9e6f-ec0354363af9" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Dom (real, virtual)</strong></mark></summary><p id="177c8263-9ab4-4c32-bd79-e94dbcb32f71" class=""><a href="https://viblo.asia/p/su-that-thu-vi-ve-react-co-the-ban-chua-biet-L4x5xAawKBM">https://viblo.asia/p/su-that-thu-vi-ve-react-co-the-ban-chua-biet-L4x5xAawKBM</a></p><p id="f607e8ce-f163-495c-b428-cd16debdfd44" class="">
</p><ul id="e5133536-919f-4233-9da9-1d9506a783b8" class="bulleted-list"><li style="list-style-type:disc"><a href="https://tonynguyenit.medium.com/how-react-virtual-dom-decide-to-update-browser-dom-91f170718733">https://tonynguyenit.medium.com/how-react-virtual-dom-decide-to-update-browser-dom-91f170718733</a></li></ul><ul id="d39b21d3-2fa5-4f4e-91b1-73c3ce3becf0" class="bulleted-list"><li style="list-style-type:disc"><a href="https://reactjs.org/docs/reconciliation.html#the-diffing-algorithm">https://reactjs.org/docs/reconciliation.html#the-diffing-algorithm</a></li></ul><ul id="32dd0107-c7fc-4e87-af76-08fd57e86a8a" class="bulleted-list"><li style="list-style-type:disc">Real dom<ul id="70b9f6b4-0b2f-4ebf-ac99-6adfb7394bdc" class="bulleted-list"><li style="list-style-type:circle"></li></ul></li></ul><ul id="78c211e7-c8ea-4175-ae21-5135682fdf74" class="bulleted-list"><li style="list-style-type:disc">Virtual dom<ul id="4dcb0b5d-98da-4710-a0fa-a96043fcbd04" class="bulleted-list"><li style="list-style-type:circle"></li></ul></li></ul></details></li></ul><ul id="2d46df97-90ba-40a3-8503-7066f858ed34" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>State management (flux, redux)</strong></mark></summary><ul id="d6d2fcfe-9ec0-4b42-b03c-ff3a707b177f" class="bulleted-list"><li style="list-style-type:disc"><strong>FLUX</strong> là một kiến thức quen thuộc được thêm bởi Facebook để sử dụng và làm việc với React. <ul id="df04bbe0-ba7b-4133-99e1-83296d743738" class="bulleted-list"><li style="list-style-type:circle"><a href="https://kipalog.com/posts/Huong-dan-va-giai-thich-Flux-bang-hinh-ve">https://kipalog.com/posts/Huong-dan-va-giai-thich-Flux-bang-hinh-ve</a></li></ul><ul id="cb4ec200-9203-403f-95db-56e5ecea63a2" class="bulleted-list"><li style="list-style-type:circle">Flux không được xem là một Framework hay thư viện mà nó chỉ đơn giản là một kiểu kiến trúc hỗ trợ thêm cho React. </li></ul><ul id="a634652f-6940-4d8e-b28f-6c285a5bdcd3" class="bulleted-list"><li style="list-style-type:circle">Đồng thời, nó xây dựng các ý tưởng về luồng dữ liệu một chiều (tên tiếng anh là Unidirectional Data Flow).</li></ul><ul id="d83922f8-2736-48b8-ac17-1e88045f1eb1" class="bulleted-list"><li style="list-style-type:circle">Cấu trúc Flux bao gồm: <ul id="345bd33e-aba2-4b0a-83f5-9932f8cac90c" class="bulleted-list"><li style="list-style-type:square">Actions: Có nhiệm vụ làm dẫn truyền dữ liệu đến với Dispatcher (nó được xem tương tự như Helper Method).</li></ul><ul id="85cd4f10-682c-48f8-a62f-6c52d38253af" class="bulleted-list"><li style="list-style-type:square">Dispatcher: Nhận những thông tin truyền đạt từ Actions để truyền tải dữ liệu tới các nơi đã thực hiện đăng ký nhận các thông tin.</li></ul><ul id="8ff37672-3fd2-460c-bbbb-00eb11ca6b3c" class="bulleted-list"><li style="list-style-type:square">Stores: Là nơi có nhiệm vụ lưu trữ cho trạng thái và các logic của hệ thống, đây là một trong những nơi có nhiệm vụ nhận đăng ký dữ liệu với Dispatcher.</li></ul><ul id="3984d4d5-6a1b-42fa-805e-354a706c0ba5" class="bulleted-list"><li style="list-style-type:square">Controller Views: Được cho là các React Components có nhiệm vụ nhận các trạng thái từ Stores và truyền dữ liệu cho các thành phần con.</li></ul></li></ul></li></ul><ul id="7a9de59f-f885-4b3b-a5fe-e1cb8398dbb6" class="bulleted-list"><li style="list-style-type:disc"><strong>REDUX:</strong></li></ul><ul id="036cee4a-5b97-4cfb-9c49-48584c16c653" class="bulleted-list"><li style="list-style-type:disc"><strong>FLUX ≠ REDUX</strong><ul id="9191ec19-7b80-4b32-ad94-f9ee05f8499d" class="bulleted-list"><li style="list-style-type:circle">Flux có kiến trúc mang tính tổng quát còn redux thì lại chi tiết hơn vì là một phiên bản được implement từ flux và sử dụng immutable state.</li></ul><ul id="f48682ec-5468-4a6f-a2be-5e4079d7477d" class="bulleted-list"><li style="list-style-type:circle">Mặc dù phát triển dựa trên flux nhưng redux chỉ có duy nhất 1 store và đã lược bỏ đi dispatcher</li></ul></li></ul></details></li></ul><ul id="2ceb2b98-0999-47f4-a345-6e5ca4c5c3f9" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Style design (css, scss, styled), The ways struct css module?</strong></mark></summary><ul id="5cded674-c64a-45ba-9ffe-b1bae4d424e1" class="bulleted-list"><li style="list-style-type:disc">Có 4 cách để style css trong react:<ul id="b8695e0b-b94c-4deb-8413-bacef1cba419" class="bulleted-list"><li style="list-style-type:circle"><strong>CSS stylesheet</strong>: đơn giản là viết 1 file css và import vào component bạn muốn style</li></ul><ul id="6425832f-ed0a-4d89-9425-af3c73dd6f59" class="bulleted-list"><li style="list-style-type:circle"><strong>Inline styling</strong>: với react thì inline style không được thể hiện bằng 1 string mà là 1 object. Ta có thể tạo một biến để lưu trữ những style object và truyền vào element bất kỳ bằng cú pháp style={name_variable}</li></ul><ul id="83140033-0272-45a0-91b6-c5d996808aa5" class="bulleted-list"><li style="list-style-type:circle"><strong>CSS module</strong>: <ul id="95b25049-3f86-461b-83f3-6ea831a8d393" class="bulleted-list"><li style="list-style-type:square">Là kiểu viết module hóa stylesheet thành từng file nhỏ, không còn sử dụng một file stylesheet tập trung nữa. Thêm vào đó, tất cả tên class lúc này sẽ được scope lại local.</li></ul><ul id="da1019cd-2eef-44df-957e-16f13f692eee" class="bulleted-list"><li style="list-style-type:square">Nói tóm lại, Module CSS sẽ được viết ở cùng folder với Component.</li></ul><ul id="708eb311-a51e-4fe4-a810-86ed449336e5" class="bulleted-list"><li style="list-style-type:square">Một số lợi ích khi dùng css module: <ul id="0d1148fb-a9df-4abf-a1cb-60e775390224" class="bulleted-list"><li style="list-style-type:disc">Chỉ tồn tại ở một nơi</li></ul><ul id="f1307830-de8d-4e44-b500-fbc296012676" class="bulleted-list"><li style="list-style-type:disc">Chỉ được sử dụng ở component đó mà không sử dụng ở bất kì chỗ nào </li></ul><ul id="708cdbd4-fcf1-462b-bf9c-7c84d5dd5457" class="bulleted-list"><li style="list-style-type:disc">Không nhất thiết phải dùng scss (muốn dùng vẫn được) vì bản chất css module đã chia nhỏ từng file css theo từng component khác nhau</li></ul><ul id="4608c463-f776-4d55-a639-5ade44efd956" class="bulleted-list"><li style="list-style-type:disc">Không sợ bị trùng tên giữa các class vì khi build với webpack tên class của CSS và element đều là duy nhất với hash code đi kèm.<blockquote id="eafea19c-e800-43b6-b759-b3f45444b744" class=""><code><strong>[Tên component]_[Tên value trong file css]__[hash string]</strong></code></blockquote></li></ul></li></ul></li></ul><ul id="93dcefb9-0b78-4778-8606-9a5ca789e4ea" class="bulleted-list"><li style="list-style-type:circle"><strong>styled component</strong>: <ul id="7420e3c3-9afa-4689-a7b1-c7a67fec51a0" class="bulleted-list"><li style="list-style-type:square">là một lib giúp bạn có thể tổ chức và quản lý code css 1 cách dễ dàng và hiệu quả.</li></ul><ul id="79b588da-4211-4017-b199-a7f536b41eb5" class="bulleted-list"><li style="list-style-type:square">Nó được xây dựng với mục tiêu giữ cho các style của component trong react gắn liền với các component đó </li></ul><ul id="b1ac82ee-05bf-4efa-bd29-79196e38cc3a" class="bulleted-list"><li style="list-style-type:square">Không chỉ thay đổi việc implement các component mà còn thay đổi cả tư duy trong việc xây dựng styles cho các component đó.</li></ul><ul id="c5703685-2c5a-457d-bd25-575b36ada7c2" class="bulleted-list"><li style="list-style-type:square">Lợi ích: <ul id="d98daec0-b9da-4341-9998-a9f138cfb491" class="bulleted-list"><li style="list-style-type:disc">cho phép ta encapsulate (đóng gói) style vào trong component trong js nhưng vẫn giữ được các tính năng của css như nesting, media query, pseudo-selector, ... Nó giải quyết được vấn đề global scope của css vì ta không cần phải viết selector cho class hay id, bởi styled component sẽ generate class ngẫu nhiên và truyền component thông qua property là className</li></ul><ul id="2d69fab7-87fd-426c-aff6-abd9d8c3b77f" class="bulleted-list"><li style="list-style-type:disc">Thay đổi style dựa trên thuộc tính hoặc trạng thái của component dễ dàng hơn. Ta có thể truyền props để thực hiện việc thay đổi style dễ dàng hơn</li></ul></li></ul><ul id="df79c303-fde9-4319-a326-e9c315930c93" class="bulleted-list"><li style="list-style-type:square">Bất lợi:<ul id="dece3296-c603-4f54-9a80-ef5972362fe6" class="bulleted-list"><li style="list-style-type:disc">Tên class được generate ngẫu nhiên nên sẽ gây khó chịu cho người quen debug css bằng tên class. (ta có thể giải quyết bằng việc kết hơp css selector với styled component)</li></ul><ul id="07fd4eb8-8e65-405d-a7c4-a1c98684fde7" class="bulleted-list"><li style="list-style-type:disc">Còn khá non trẻ nên chưa được kiểm duyệt tính scale trong các project lớn</li></ul><ul id="fe169c56-631f-4d5c-b9ab-3276e714bbb0" class="bulleted-list"><li style="list-style-type:disc">Nhiều người vẫn không thích css trong js</li></ul><ul id="36f548a9-f87f-4e60-97d0-f76396a13f49" class="bulleted-list"><li style="list-style-type:disc">Không được dùng<code>ref</code> trên component phải chuyển sang <code>innerRef</code>bởi vì <a href="https://www.styled-components.com/docs/advanced#refs">ref sẽ được truyền vào wrapper của styled component thay vì component mình muốn.</a></li></ul></li></ul></li></ul></li></ul></details></li></ul><ul id="64e4814a-d5ba-4ff6-ada4-55296d237493" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Build system (webpack, vite)</strong></mark></summary><ul id="61ab4ad5-339c-489b-a78d-48a87ea0383b" class="bulleted-list"><li style="list-style-type:disc"><strong>Webpack</strong> là công cụ giúp bạn compile các module Javascript. Nó hay được gọi là “module bundler”.<ul id="063efac6-679a-4e84-8f46-88a1656e82f3" class="bulleted-list"><li style="list-style-type:circle">Webpack là công cụ giúp gói gọn toàn bộ file js, jsx, img, css(bao gồm cả scss,sass,..)</li></ul><ul id="252980b5-ef88-426e-9755-3ab6498285d3" class="bulleted-list"><li style="list-style-type:circle">Việc gói gọn không phải là lộn xộn hết cả lên mà nó được gói theo cấu trúc project, từ phần module này sang phần kia.</li></ul><ul id="9c53a8b8-a8cc-4072-8602-5509277320d4" class="bulleted-list"><li style="list-style-type:circle">Ngoài ra webpack còn rất nhiều chức năng hữu dụng khác nữa, như optimize hay tuỳ chọn chạy trên môi trường khác nhau(dev hoặc production),…</li></ul><ul id="9d5f601c-d764-46e2-b93c-f24421dcf565" class="bulleted-list"><li style="list-style-type:circle">Webpack nhận vào các module cùng với các dependencies và generate ra các static assets tương ứng.</li></ul><ul id="3c2c0a49-36d2-477e-a504-cb40af723b0f" class="bulleted-list"><li style="list-style-type:circle">Việc sử dụng Webpack sẽ giúp project của chúng ta được optimize hơn rất nhiều.</li></ul><ul id="cca3e47b-603a-4c04-ae4f-49c480b2973b" class="bulleted-list"><li style="list-style-type:circle">Triết lí cốt lõi:<ul id="03dbd39f-fc46-4416-abcb-2b2eeacff90d" class="bulleted-list"><li style="list-style-type:square"><strong>Mọi thứ đều là module</strong>: khi làm việc với js, chúng ta thường tạo module ứng với 1 hoặc nhiều file js gộp lại. Thì đối với webpack thì những file như (CSS, Images, HTML) đều có thể trở thành module. Nó không khác gì khi chúng ta sử dụng file js cả. Cũng có những câu lệnh import module như <strong>require(“myJSfile.js”) </strong>or <strong>require(“myCSSfile.css”). </strong>Với tính cách module thì chúng ta có thể sử dụng nó ở bất kì ở đâu và có thể re-use khi cho ta muốn.</li></ul><ul id="d467e219-3be5-42e9-af88-fdcde61ee664" class="bulleted-list"><li style="list-style-type:square"><strong>Load only what you need and when you need</strong>: Thông thường khi làm việc với js, chúng ta sử dụng rất nhiều module khác nhau. Với wepback sẽ gộp tất các cái module đó thành một file <strong>&quot;bundle.js&quot;. T</strong>rong các ứng dụng thực tế file &quot;bundle.js&quot; có dung lượng lên đến <strong>&quot;10MB-15MB&quot;</strong>, đều này không tốt khi sử dụng cho website. Khi client request sẽ load rất lâu dẫn đến trải nghiệm người dùng đối với ứng dụng không tốt. Webpack hiểu ra điều đó nên webpack có vài tính năng chia nhỏ file &quot;bundle&quot; thì nhiều file khác nhau ứng với từng mục đích khác nhau. Việc chia nhỏ vậy, sẽ giúp chúng ta cần load những gì và khi nào cần sử dụng nó.</li></ul></li></ul><ul id="cbee1f86-72ec-44a8-bc79-0f016ac7fe9d" class="bulleted-list"><li style="list-style-type:circle">Ưu điểm<ul id="ee2d13f3-1738-4374-9c41-796cd85b59d7" class="bulleted-list"><li style="list-style-type:square">Giúp cho cho project dễ dàng phát triển, quản lý, customize</li></ul><ul id="0c037b6a-305f-4b4a-9990-17553747236d" class="bulleted-list"><li style="list-style-type:square">Tăng tốc độ cho project</li></ul><ul id="7bb2744c-aab0-444a-bde9-de6a6ec549f7" class="bulleted-list"><li style="list-style-type:square">Phân chia các module và chỉ load khi cần</li></ul><ul id="d6b23d52-4c8f-491f-90a4-54286a0c6078" class="bulleted-list"><li style="list-style-type:square">Đóng gói tất cả file nguồn thành một file duy nhất, nhờ vào loader mà có thể biên dịch các loại file khác nhau</li></ul><ul id="77d48b77-e769-42f3-8aed-5b42f18796c6" class="bulleted-list"><li style="list-style-type:square">Biến các tài nguyên tĩnh ( image, css) trở thành 1 module</li></ul><ul id="1c294ef7-d9e0-453b-96dd-7b7da2c201d5" class="bulleted-list"><li style="list-style-type:square">Chuyển đổi các mã nguồn : JSX, less, sass, scss thành js, ... ES6 -&gt; ES5 thông qua babel transpiler ...</li></ul></li></ul></li></ul><ul id="4d07b33e-2a25-41ec-82e5-86d6c1f0da29" class="bulleted-list"><li style="list-style-type:disc"><strong>Vite</strong> là một tool mới ra mắt cùng vue3 được phát triển bởi evan you. Về chức năng thì cũng na ná như vue-cli tuy nhiên có một số điểm khác biệt như: <ul id="6af25956-856f-4fb8-a07d-1e5cb9992015" class="bulleted-list"><li style="list-style-type:circle">vite không based trên webpack </li></ul><ul id="b54ec644-bb6b-4b16-8966-d1fe7e9a4d2e" class="bulleted-list"><li style="list-style-type:circle">DevServer sử dụng native ES modules trên trình duyệt.</li></ul><ul id="9de86f78-63f1-4710-a189-f451cc96c860" class="bulleted-list"><li style="list-style-type:circle">Vite build sử dụng <a href="https://rollupjs.org/guide/en/">Rollup</a>, thằng này cũng được đánh giá khá nhanh</li></ul><ul id="959f8ee6-2c73-451d-b451-1a6c77d5e99a" class="bulleted-list"><li style="list-style-type:circle">Nhược điểm: kén browser, kén dependencies, còn một số lỗi ở môi trường production, ...</li></ul></li></ul></details></li></ul><ul id="ec154936-6fac-4ba9-8bc7-1e1a163d8d1f" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Composition in vuejs?</strong></mark></summary><ul id="60eb3d4a-b3e6-4e52-95cb-b60694282d0d" class="bulleted-list"><li style="list-style-type:disc"></li></ul></details></li></ul><ul id="f8aa53a1-f4bb-47c2-9002-b5ad309f86ec" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Proxy &amp; Reflect ?</strong></mark></summary><ul id="6167828b-5c1a-4ca7-b49d-97f336f9f5f1" class="bulleted-list"><li style="list-style-type:disc"></li></ul></details></li></ul><ul id="b9a79616-d72a-4a9b-ab5e-d7a7dfd29eb9" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Reactivity system in vuejs?</strong></mark></summary><ul id="60043ff9-1aaf-45ee-8b1c-452bfdbc953f" class="bulleted-list"><li style="list-style-type:disc">là cơ chế cho phép chúng ta phản ứng lại những thay đổi đột biến. Khi bạn thay đổi state thì view sẽ tự động được cập nhật. Điều này làm cho việc quản lý state trở nên dễ dàng và trực quan.</li></ul></details></li></ul><ul id="56dd0442-6b54-412c-839b-dfef2505dcc4" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Những phương pháp giúp tối ưu performance?</strong></mark></summary><ul id="ee4de738-665b-44e9-9ff5-a4b55ca6cf9a" class="bulleted-list"><li style="list-style-type:disc">Code splitting: chỉ load những page hoặc component cần thiết lúc render, không nên load hết tất cả lên, vd: khi vào homepage ta chỉ cần load page home và component liên quan đến page đó thôi</li></ul><ul id="2c1c82f7-4ce1-484c-883f-d1a863d27c86" class="bulleted-list"><li style="list-style-type:disc">Lazy load image: thay vì load hết tất cả img thì ta nên load những img hiển thị trên viewport, khi scroll thì tiếp tục load những hình ảnh còn lại</li></ul><ul id="7558b219-d197-4688-afc7-41a016b6d10f" class="bulleted-list"><li style="list-style-type:disc">Lazy size image: với mỗi screen device sẽ có những size ảnh khác nhau thay vì chỉ load 1 size ảnh cho all device</li></ul><ul id="a0dbbef2-d9e4-4800-93ce-e7eea5c62d4c" class="bulleted-list"><li style="list-style-type:disc">Server side rendering</li></ul><ul id="c585ff89-0a22-4cdc-b428-4bd20fce802d" class="bulleted-list"><li style="list-style-type:disc">Sử dụng CDN</li></ul><ul id="3ff599dc-0ab9-4cbf-b9b7-8cf35a372efd" class="bulleted-list"><li style="list-style-type:disc">Tối ưu CSS</li></ul><ul id="8cdab302-d7b1-4bba-865c-ef968dced3df" class="bulleted-list"><li style="list-style-type:disc">Minified HTML, CSS, JS with webpack</li></ul><ul id="0d7610dc-29fb-43e6-be21-872efd02d619" class="bulleted-list"><li style="list-style-type:disc">Tránh việc re-render nhiều lần trong app</li></ul><ul id="c49f1280-45bf-45b3-b291-af07f43df859" class="bulleted-list"><li style="list-style-type:disc">Thêm loading hoặc skeleton để tăng trải nghiệm người dùng</li></ul></details></li></ul><ul id="3dcf0687-473d-4364-92e5-7419728e0ee5" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Immutable và mutable trong react</strong></mark></summary><ul id="049d1f1f-a8f2-40b1-b492-e7bae61dca6d" class="bulleted-list"><li style="list-style-type:disc">Mutable trạng thái/ dữ liệu của Object có thể thay đổi được.<ul id="df82ec8c-f795-44aa-99a2-53491f94ee51" class="bulleted-list"><li style="list-style-type:circle"><code>Object</code> và <code>Array</code> trong JavaScript mặc định đã được <em>mutate</em></li></ul><ul id="43ec37f0-247b-4760-852f-f89d3aef7728" class="bulleted-list"><li style="list-style-type:circle"><span style="border-bottom:0.05em solid"><strong>Pros</strong></span>: Mutate Object tạo ra side effect dẫn tới nhiều bugs không mong muốn.</li></ul></li></ul><ul id="ed60af2d-17b9-4f8d-a0ff-d8ed9e69371c" class="bulleted-list"><li style="list-style-type:disc">Immutable trạng thái/ dữ liệu không thể bị thay đổi.<ul id="e9850d17-859d-461f-a82e-7b5bd6c2c2f7" class="bulleted-list"><li style="list-style-type:circle">Trong JavaScript, tất cả các kiểu dữ liệu nguyên thủy (primitive) đều là immutability.</li></ul><ul id="d1f1073e-a9d4-4d4b-b2a4-d185c119601b" class="bulleted-list"><li style="list-style-type:circle">Mỗi khi chúng ta thay đổi dữ liệu, nó sẽ tạo ra một instance mới hoàn toàn và không ảnh hưởng tới instance cũ.</li></ul><ul id="bb16558f-ed3a-4757-9937-1fcd241a12f3" class="bulleted-list"><li style="list-style-type:circle"><span style="border-bottom:0.05em solid"><strong>Pros</strong></span>: Immutability là rất tốt, nó tránh được nhiều bugs nhưng vô hình chung lại làm giảm performance của app. Immutability tạo ra một bản sao giống hoàn toàn so với bản gốc, sau đó edit dữ liệu mà chúng ta muốn thay đổi trên bản sao này. Điều có có nghĩa là nó sẽ tốn rất nhiều memory cho việc copy các <code>Object</code>
 hoặc <code>Array. </code>Thử tưởng tượng chúng ta muốn thay đổi 1 giá trị trong một Array bao gồm 1 triệu phần tử thì sẽ tốn nhiều memory như thế nào nhỉ 🤔</li></ul><p id="d6a21803-2b53-440c-9c31-ab9ee463a291" class="">⇒ Để giải quyết được vấn đề memory lead. Immutable sử dụng 1 cấu trúc dữ liệu có lên là <strong>“trie data structures”</strong>. Cấu trúc dữ liệu này sử dụng một concept là <strong>Structure Sharing</strong> (tối ưu memory bằng cách tái sử dụng).</p><p id="31b956fc-5aec-4adb-95f8-7cfe26ed016c" class="">Theo cách Immutability thông thường, mỗi khi thay đổi một thuộc tính nào đó, chúng ta phải clone toàn bộ <code>Object</code> hoặc <code>Array</code> thành một bản sao, sau đó thực hiện modify trên chính bản sao đó.</p><p id="d32a797e-5655-4ae9-8aa8-9ffeb580df3b" class=""><strong>Hiện tại có khá nhiều thư viện hỗ trợ chúng ta thực hiện công việc này. </strong><strong><a href="https://github.com/immutable-js/immutable-js">Immutablejs</a></strong><strong> và </strong><strong><a href="https://github.com/swannodette/mori">mori</a></strong><strong> là 2 thư viện phổ biến nhất implement immutability sử dụng cấu trúc Structure Sharing.</strong></p><p id="496f5da9-5cc0-4b67-ab4f-5cd4e5562d15" class=""><a href="https://blog.daovanhung.com/post/ban-da-thuc-su-hieu-mutable-va-immutable">https://blog.daovanhung.com/post/ban-da-thuc-su-hieu-mutable-va-immutable</a></p></li></ul></details></li></ul><ul id="41013ffa-6d59-46b3-bf79-682358472117" class="toggle"><li><details open=""><summary><strong><mark class="highlight-red">React hooks</mark></strong></summary><p id="20ce9bf2-6489-4eba-8ec3-8574c1057cd3" class=""><a href="https://dynonguyen.com/nhung-react-hook-hay-dung-nhat-trong-reactjs/">https://dynonguyen.com/nhung-react-hook-hay-dung-nhat-trong-reactjs/</a></p></details></li></ul><ul id="a1c4d1d3-b493-412c-9812-a623d6e24ea8" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Tại sao setState không trả về async</strong></mark></summary><ul id="fa4d5ee2-4275-4545-8552-393bf06707e6" class="bulleted-list"><li style="list-style-type:disc"><strong>setState</strong>: KHÔNG TRẢ VỀ ASYNC mà nó trả về 1 dispatch function. Vì:<ul id="65760f68-018b-4d92-80a6-2ff18823ddde" class="bulleted-list"><li style="list-style-type:circle">Khi gọi useState, kết quả trả về là 1 mảng gồm: 1 giá trị  + 1 dispatch function</li></ul><ul id="d48d3426-2526-42a0-a984-19936c528e4a" class="bulleted-list"><li style="list-style-type:circle"><strong>dispatch function</strong>: nhận vào 1 giá trị và trả về void (lưu ý, là trả về <code>void</code>, không phải <code>promise</code>) nên <code>setState</code> không phải <code>async</code></li></ul></li></ul><ul id="eff91ffd-0e37-49ed-935b-b292f7389e23" class="bulleted-list"><li style="list-style-type:disc"><strong>Nếu không phải async thì tại sao nó không thể update giá trị ngay?</strong><ul id="9c0c5b76-52da-45bd-81bb-b4c5f38151d5" class="bulleted-list"><li style="list-style-type:circle">Theo như reactjs có nói: Sau khi giá trị được truyền vào, thì nó sẽ đi vào 1 hàng đợi, và chờ được xử lý</li></ul><ul id="3450e7b7-4fed-44de-a622-80b1e714b745" class="bulleted-list"><li style="list-style-type:circle">Đến khi component <strong>re-render</strong> thì giá trị mới sẽ được cập nhật</li></ul></li></ul></details></li></ul></details></li></ul><ul id="cedda407-6699-47ac-a1f6-e867f65cf9e1" class="toggle"><li><details open=""><summary><strong>HTML / CSS</strong></summary><ul id="09f4d876-c24f-480c-9dda-f968e2a60169" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Lazy loading, lazy image</strong></mark></summary><p id="d220d479-35da-4325-b1fa-2885e8becdcb" class=""><a href="https://dynonguyen.com/huong-dan-trien-khai-lazy-loading/">https://dynonguyen.com/huong-dan-trien-khai-lazy-loading/</a></p></details></li></ul><ul id="d5af6e02-bb6a-4af3-84ce-2d4ffcca65b3" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Tại sao sử dụng srcset trong thẻ img?</strong></mark></summary><ul id="248f2db8-2e75-49c2-b2f8-c5583c632666" class="bulleted-list"><li style="list-style-type:disc">srcset cho phép bạn khai báo một tập hợp các hình ảnh sẽ được hiển thị trên các kích thước khung nhìn khác nhau. </li></ul><ul id="beeaadbe-1d6e-471f-a4d1-ea068384d0b9" class="bulleted-list"><li style="list-style-type:disc">Bạn chỉ cần lưu và hình ảnh ở các độ phân giải khác nhau</li></ul><ul id="3c40a7d8-3015-4ce4-8bd7-5207d9e9441e" class="bulleted-list"><li style="list-style-type:disc">VD: img_small.png 200w, img_medium.png 500w, img_large.png 1000w</li></ul><ul id="67b7fe25-b289-4743-a99e-6ec39219b1d9" class="bulleted-list"><li style="list-style-type:disc">và chúng được ngăn cách bởi dấy phẩy</li></ul></details></li></ul><ul id="0d6a3347-76a1-404f-a0d6-731fa7ad74e8" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Sự khác nhau giữa “resetting” và “normalizing” CSS là gì? Bạn sẽ chọn cái nào, và tại sao?</strong></mark></summary><ul id="9cda944c-5901-4243-918e-3b5888035f2d" class="bulleted-list"><li style="list-style-type:disc">Resetting: loại bỏ tất cả kiểu trình duyệt mặc định trên các phần tử. <ul id="c8837220-7573-437d-b0c8-da91791c2108" class="bulleted-list"><li style="list-style-type:circle">Ví dụ: <code>margin</code>, <code>padding</code>, <code>font-size</code> của tất cả các phần tử được đặt lại như cũ. Bạn sẽ phải khai báo lại kiểu dáng cho các yếu tố kiểu chữ phổ biến.</li></ul></li></ul><ul id="05b46ca8-0d09-48d6-b094-3f95a84695a1" class="bulleted-list"><li style="list-style-type:disc">Normalizing: Chuẩn hóa bảo tồn các kiểu mặc định hữu ích thay vì “unstyling” mọi thứ. Nó cũng sửa lỗi cho các phụ thuộc trình duyệt phổ biến.</li></ul><p id="e77d9f42-597e-4cce-901e-ee137e381cb4" class="">Chọn resetting khi bạn có thiết kế trang web rất tùy chỉnh hoặc độc đáo, và bạn cần phải thực hiện nhiều kiểu của riêng mình và không cần giữ nguyên bất kỳ kiểu mặc định nào.</p></details></li></ul><ul id="b93d2bcd-5361-4cfd-80ba-fe3fb0211f3d" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Floats?</strong></mark></summary><ul id="09ebfb2e-2181-458d-82a4-5073228204e0" class="bulleted-list"><li style="list-style-type:disc">Thuộc tính float trong CSS đặt một phần tử ở bên trái hoặc bên phải vùng chứa của nó, cho phép các phần tử văn bản và nội tuyến quấn quanh nó. Phần tử bị xóa khỏi luồng bình thường của trang, mặc dù vẫn còn lại một phần của luồng (trái ngược với vị trí tuyệt đối).</li></ul></details></li></ul><ul id="2be5ac63-d8d9-4316-8764-1c32e25c732d" class="toggle"><li><details open=""><summary><strong><mark class="highlight-red">Có những cách nào để ẩn 1 element?</mark></strong></summary><ul id="513e8b8b-9b47-4669-9569-cd7510cbebda" class="bulleted-list"><li style="list-style-type:disc"><strong><strong>opacity</strong></strong>: set về giá trị 0, ta có thể ẩn đi element đó, với cách này ta vẫn có thể đính kèm sự kiện lên nó. Nó không hoàn toàn ẩn đi mà chỉ vô hình mà thôi<pre id="9ef91632-6780-4298-8d02-0fd0941d7fa0" class="code"><code>element {
  opacity: 0;
}</code></pre></li></ul><ul id="adcc5cc5-3d53-43a7-93d1-22d3b2a1aed2" class="bulleted-list"><li style="list-style-type:disc"><strong><strong>color Alpha Transparency</strong></strong>: chỉ cần set giá trị Alpha (giá trị thứ 4) về 0 thì ta có thể ẩn đi được phần tử<pre id="5008447a-9b2f-4d9f-a6ed-97847b661f1f" class="code"><code>element {
  color: rgba(r, g, b, 0);
  background-color: rgba(r, g, b, 0);
}

/* or */

element {
  color: hsla(h, s, l, 0);
  background-color: hsla(h, s, l, 0);
}</code></pre></li></ul><ul id="6c61c071-b742-4efa-832a-ea693d1473fb" class="bulleted-list"><li style="list-style-type:disc"><strong><strong>transform</strong></strong>: ta có thể dùng hàm scale() hoặc translate để biến đổi phần tử. Cụ thể ta có thể dùng 3 cách<pre id="29024bd5-7bb9-4445-877d-d6ad8cf3bc75" class="code"><code>element {
  transform: scale(0);
}

/* or */

element {
  transform: translateX(-999px);
}

/* or */

element {
  transform: translateY(-999px);
}</code></pre></li></ul><ul id="ff06dd79-e3e9-4a22-a5d8-d86eda0c8b7d" class="bulleted-list"><li style="list-style-type:disc"><strong>clip-path</strong><pre id="ecd98302-ec62-48e1-a195-6c2fba2118be" class="code"><code>element {
  clip-path: circle(0);
}</code></pre></li></ul><ul id="e0cf79e7-855d-4307-82bc-a91101ea4a8a" class="bulleted-list"><li style="list-style-type:disc"><strong><strong>visibility: </strong></strong><pre id="84947fee-49d9-4ac4-b86c-9fe87159fca5" class="code"><code>element {
  visibility: hidden;
}</code></pre></li></ul><ul id="71fa1869-ead0-4e31-b8ed-8448942f0713" class="bulleted-list"><li style="list-style-type:disc"><strong>display</strong>: nhận giá trị <code>none</code>, nó sẽ ẩn hoàn toàn phần tử đi và bạn không thể đính kèm được sự kiện lên phần tử đó<pre id="0fb5f398-094b-409f-afbf-187ac8d15e6b" class="code"><code>element {
  display: none;
}</code></pre></li></ul><ul id="1474d7cf-82b9-47c1-842d-c9f0bd2a7e5f" class="bulleted-list"><li style="list-style-type:disc"><strong>hidden: </strong>là một thuộc tính trong HTML mà ở đó nó đã được mặc định default css là <code>display: none</code>. Ta sử dụng như sau<pre id="93d4bb1b-5461-4c8e-bc2d-88aa11c36ac0" class="code"><code>&lt;p hidden&gt;
  Hidden content
&lt;/p&gt;</code></pre></li></ul><ul id="9f649c14-cec1-447d-a48c-7d95e4775c1f" class="bulleted-list"><li style="list-style-type:disc"><strong><strong>Absolute: </strong></strong>Việc sử dụng <code>absolute </code>cũng khá giống như <code>transform</code>, tức là bạn có thể chỉ định 4 giá trị top/bottom/left/right thành các giá trị âm để di chuyển phần tử ra khỏi khung nhìn<pre id="28da8ebb-d1c1-45c8-a475-dd88bb49ea8d" class="code"><code>element {
  position: absolute;
  left: -999px;
}</code></pre></li></ul><ul id="48ec979c-13b5-4e8b-a7a9-18dc1f2b100b" class="bulleted-list"><li style="list-style-type:disc"><strong>Overlay</strong>: Sử dụng phần tử giả cũng có thể giúp ta ẩn đi phần tử (tuy nhiên lưu ý đây chỉ là ẩn đi &quot;bằng việc set background theo phần tử cha&quot;)<pre id="dbd612f2-307e-4322-a644-9931b97cb482" class="code"><code>element {
  position: relative;
}

element:after {
  position: absolute;
  content: &#x27;&#x27;;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  background: #fff;
}</code></pre></li></ul><ul id="d80c9b09-688f-4d9a-a263-ca33ad1a9a67" class="bulleted-list"><li style="list-style-type:disc"><strong><strong>Giảm thiểu kích thước: </strong></strong>đây là sự kết hợp giữa 3 thuộc tính <code>height</code>, <code>padding</code>, <code>overflow</code><pre id="2f97f44e-c059-4e46-8727-7b72c7683b80" class="code"><code>element {
  height: 0;
  padding: 0;
  overflow: hidden;
}</code></pre><p id="a1c5c926-7b17-4719-b2a5-57e2a3cab5b7" class="">
</p><p id="035f6de0-a3ff-44de-bfc4-7321b181b74e" class="">
</p></li></ul></details></li></ul><ul id="67ab1900-f798-48f2-b7e0-a8b6c346ac02" class="toggle"><li><details open=""><summary><strong><mark class="highlight-red">Flex và grid?</mark></strong></summary><ul id="007356f2-857b-469e-8898-261846cef7c7" class="bulleted-list"><li style="list-style-type:disc">CSS Grid Layout là hệ thống bố cục mạnh mẽ nhất hiện có trong CSS. Nó là một hệ thống 2 chiều, có nghĩa là nó có thể xử lý cả cột và hàng, không giống như flexbox phần lớn là hệ thống 1 chiều</li></ul><ul id="b6a5f416-efd5-4120-9d34-08a0b61a78c0" class="bulleted-list"><li style="list-style-type:disc">Flexbox (hộp linh hoạt) là một hệ thống bố cục một chiều (theo chiều ngang hoặc chiều dọc), nhằm mục đích cung cấp một cách hiệu quả việc bố trí, căn chỉnh và phân phối không gian giữa các mục trong một thùng chứa (container), ngay cả khi kích thước của chúng không xác định hoặc kích thước động.<ul id="fc2044e3-9240-4321-a247-217186b85737" class="bulleted-list"><li style="list-style-type:circle"><a href="https://www.notion.so/Flexbox-686ee4ef94394e80b355b25425dbfa94">https://www.notion.so/Flexbox-686ee4ef94394e80b355b25425dbfa94</a></li></ul></li></ul></details></li></ul><ul id="461375f9-4f10-401a-9e97-1f27bd73b27a" class="toggle"><li><details open=""><summary><strong><mark class="highlight-red">Ưu điểm của việc sử dụng CSS preprocessors(SASS, SCSS, LESS)?</mark></strong></summary><ul id="0b7d9942-4503-40d6-95dd-d6985a7d07ae" class="bulleted-list"><li style="list-style-type:disc">CSS Preprocessors là ngôn ngữ tiền xử lý CSS. Là một ngôn ngữ kịch bản mở rộng của CSS và được biên dịch thành cú pháp CSS giúp bạn viết CSS nhanh hơn và có cấu trúc rõ ràng hơn. CSS Preprocessor có thể giúp bạn tiết kiệm thời gian viết CSS, dễ dàng bảo trì và phát triển CSS.</li></ul><ul id="f089388d-c35d-416e-94d8-3efca174fb27" class="bulleted-list"><li style="list-style-type:disc">Ưu điểm:<ul id="d20a1686-3ef2-453d-a106-efa1d0715337" class="bulleted-list"><li style="list-style-type:circle">Có thêm phần mở rộng ngôn ngữ như các biến (variable), nesting, mixins...</li></ul><ul id="845fc8f8-1f62-4528-9e74-0d69b38b9e6b" class="bulleted-list"><li style="list-style-type:circle">Nhiều chức năng thao tác với màu sắc và các giá trị khác.</li></ul><ul id="27dbfe61-a9d5-44fc-b870-6e081098ca8d" class="bulleted-list"><li style="list-style-type:circle">Có các đặc tính nâng cao kiểm soát thư viện.</li></ul><ul id="a9329038-9e68-4fae-b225-bccf7e92c3ab" class="bulleted-list"><li style="list-style-type:circle">Định dạng tốt và dễ tùy chỉnh.</li></ul></li></ul></details></li></ul><ul id="681f8272-0a50-4015-bed8-094b9c8cbc91" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Độ ưu tiên trong css?</strong></mark></summary><p id="e1d9bbbf-1883-472a-912f-51eeecaf8dd3" class="">→ <a href="https://www.notion.so/CSS-Specificity-29ab7524c2f640d5adbe45af34a0f93d">Xem bài tìm hiểu về độ cụ thể trong css</a> </p></details></li></ul><ul id="3acd541c-4fd3-414c-8ff0-d4232ab14a2d" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Hiểu gì về box-model?</strong></mark></summary><ul id="721e7b26-4f70-4e02-8f02-48137692cbd0" class="bulleted-list"><li style="list-style-type:disc">Một hộp hình chữ nhật được bao quanh mọi phần tử HTML. Box model (mô hình hình hộp) được sử dụng để xác định chiều cao và chiều rộng của hình hộp chữ nhật. Hộp CSS bao gồm Chiều rộng và chiều cao (hoặc trong trường hợp không có, giá trị mặc định và nội dung bên trong), phần đệm (padding), đường viền (border), lề (margin):<ul id="3759f2e8-8f87-471f-bcde-4a32f2a77e37" class="bulleted-list"><li style="list-style-type:circle"><strong>Content:</strong> Nội dung thực tế của hộp nơi đặt văn bản hoặc hình ảnh.</li></ul><ul id="fe6ba8f2-1cdc-4010-afc6-ace4459920ea" class="bulleted-list"><li style="list-style-type:circle"><strong>Padding</strong>: Khu vực bao quanh nội dung (Khoảng trống giữa đường viền và nội dung).</li></ul><ul id="ff0dc2b7-fdaa-4373-9650-85dcb3f0fb01" class="bulleted-list"><li style="list-style-type:circle"><strong>Border</strong>: Khu vực bao quanh phần đệm.</li></ul><ul id="fd8eb7e8-5333-40c0-969f-ee8943d76383" class="bulleted-list"><li style="list-style-type:circle"><strong>Margin</strong>: Khu vực bao quanh đường viền.</li></ul></li></ul></details></li></ul><ul id="44e4c437-b0ce-4f55-82be-01656714e4df" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong><strong>Sự khác nhau giữa display: inline, block và inline-block</strong></strong></mark></summary><ul id="78ce9612-6bd4-41f8-9050-0c434fb3aab8" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>inline</strong></span>: các item sẽ nằm trên cùng 1 dòng. Nếu các items vượt quá độ dài của dòng thì item sẽ xuống dòng mới (vd: thẻ &lt;span&gt;). Các inline item sẽ chỉ có thể điều chỉnh <strong>margin</strong> và <strong>padding</strong> <strong>left and right </strong>(top và bottom thì không thể).</li></ul><ul id="1b1a0869-c643-4326-ae59-8e433ad248d7" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>block</strong></span>: khác với inline thì block nó sẽ luôn xuống dòng và chiếm toàn bộ width nếu width không được set. Các item block sẽ set được width, height, margin, padding đầy đủ 4 hướng (top, bottom, left, right)</li></ul><ul id="389ce203-e0c6-4eee-a1ac-399cd32105d0" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>inline-block</strong></span>: sẽ được sắp xếp giống kiểu inline nghĩa là các item sẽ được xếp trên 1 dòng nhưng sẽ có thuộc tính của block như là set width, height, margin, padding đủ  4 hướng</li></ul></details></li></ul><ul id="23cf079a-9e50-40f1-a7c2-e76ded803e19" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Responsive design khác adaptive design như thế nào?</strong></mark></summary><ul id="6eff3f3e-186a-46bd-a3f9-843f5b8ef977" class="bulleted-list"><li style="list-style-type:disc">RD: thích ứng với nhiều kích thước màn hình khác nhau và chỉ cần thiết kế một phiên bản cho web</li></ul><ul id="052349ba-2ddb-444d-a872-eeb4b0fc99a8" class="bulleted-list"><li style="list-style-type:disc">AD: Bố cục riêng biệt cho từng kích thước màn hình và phải thiết kế nhiều phiên bản cho web</li></ul></details></li></ul><ul id="5a2f3993-6beb-4978-a5ec-4eee9ba2d173" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Cách sử dụng position?</strong></mark></summary><ul id="a75b2d1d-ba6c-43bc-8503-3a722c337013" class="bulleted-list"><li style="list-style-type:disc"><strong>Absolute: </strong>Để đặt một phần tử chính xác nơi bạn muốn đặt nó. Absolute position thực sự được đặt so với phần tử gốc. Nếu không có trang gốc nào thì vị trí tương đối với chính trang đó (nó sẽ mặc định tất cả các cách sao lưu vào phần tử).</li></ul><ul id="88e784ec-7191-4d5f-b313-701e65bed96e" class="bulleted-list"><li style="list-style-type:disc"><strong>Relative</strong>: Tương đối với chính nó. Vị trí đặt: tương đối; trên một phần tử và không có thuộc tính định vị nào khác, nó sẽ không ảnh hưởng đến định vị của nó. Nó cho phép sử dụng z-index trên phần tử và nó giới hạn phạm vi của các phần tử con được định vị tuyệt đối. Bất kỳ phần tử con nào sẽ được định vị tuyệt đối trong khối đó.</li></ul><ul id="361e51b7-4344-45fd-ad6d-551ca56a9124" class="bulleted-list"><li style="list-style-type:disc"><strong>Fixed:</strong> Phần tử được định vị liên quan đến chế độ xem hoặc chính cửa sổ trình duyệt. Khung nhìn không thay đổi nếu bạn cuộn và do đó phần tử cố định sẽ ở ngay vị trí cũ.</li></ul><ul id="19dfc56e-527e-4b37-b7b6-d7d8907528fa" class="bulleted-list"><li style="list-style-type:disc"><strong>Static: </strong>Mặc định tĩnh cho mọi phần tử trang. Lý do duy nhất bạn muốn đặt một phần tử ở vị trí: static là để xóa một cách một số vị trí đã áp dụng cho một phần tử nằm ngoài tầm kiểm soát của bạn.</li></ul><ul id="d5da625d-6599-47bc-aa37-638f52e5bd1f" class="bulleted-list"><li style="list-style-type:disc"><strong>Sticky</strong>: Sticky positioning là sự kết hợp giữa định vị tương đối và cố định. Phần tử được coi là vị trí tương đối cho đến khi nó vượt qua ngưỡng được chỉ định, tại thời điểm đó, phần tử được coi là vị trí cố định.</li></ul></details></li></ul><ul id="a530c95f-9f40-407d-9216-b5add54f9d64" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Sự khác nhau của các đơn vị trong css: px, rem, em, vw, vh, ...</strong></mark></summary><ul id="3025079d-8d9f-4d2b-9c3a-ec9960cba5e3" class="bulleted-list"><li style="list-style-type:disc"><strong>Đơn vị tương đối (Relative Units) </strong>là những đơn vị được tính một cách tương đối dựa trên các phần tử khác (có thể là phần tử cha hoặc phần tử root). Các đơn vị loại này khá linh động, rất thích hợp cho việc thích ứng trên các thiết bị khác nhau. Một vài đơn vị tương đối như: <strong>rem, em, %, vw, vh, ex, ch, vmin, vmax</strong></li></ul><ul id="18039736-9c90-4b7b-bbda-52fd7d8b196f" class="bulleted-list"><li style="list-style-type:disc"><strong>Đơn vị tuyệt đối (Absolute Units)</strong> là những đơn vị mà giá trị của nó không bao giờ thay đổi và không bị ảnh hưởng bởi các thành phần khác. Tức là trong mọi kích thước màn hình thì kích thước của nó vẫn như thế. Với loại đơn vị này chỉ nên dùng cho những thứ có kích thước cố định, hoặc kích thước nhỏ không quá ảnh hưởng như border, … Một vài đơn vị tuyệt đối như: <strong>px, pt, cm, mm, pc, in</strong>.</li></ul><ul id="9e93c00b-c786-44c9-b321-8f543b49e897" class="bulleted-list"><li style="list-style-type:disc"><strong>em </strong>là đơn vị mà giá trị của nó được tính dựa trên tỉ lệ so với phần tử cha của nó hoặc chính nó thông qua giá trị của thuộc tính <strong>font-size. </strong>Mức độ ưu tiên sẽ tính theo font-size của nó trước, nếu nó không set thuộc font-size thì lấy của cha trực tiếp. Nếu cha nó không có thì lấy tiếp cha của cha nó Đến khi nào đến root thì thôi.</li></ul><ul id="f9f54acc-17d2-48e9-ab53-62aa98ab95cd" class="bulleted-list"><li style="list-style-type:disc"><strong>rem (root em) </strong>tương tự như <strong>em</strong>, nhưng đơn giản là nó sẽ tỉ lệ theo thuộc tính font-size của phần tử <strong>root &lt;html&gt;</strong></li></ul><ul id="74907122-0fce-45bd-affc-b73714a60b62" class="bulleted-list"><li style="list-style-type:disc"><strong>vw </strong>sẽ tính theo tỉ lệ <strong>chiều rộng khung nhìn </strong>thiết bị của bạn. 1 vw = 1/100 chiều rộng view-port. Ví dụ: màn hình của bạn có chiều rộng 1100px thì 1vw = 11px</li></ul><ul id="65de20b7-d43f-475a-998e-ec83ff714fe3" class="bulleted-list"><li style="list-style-type:disc"><strong>vh </strong>tương tự vw, vh sẽ tỉ lệ theo chiều cao của khung nhìn thiết bị.</li></ul><ul id="f5489b54-8186-4f01-a854-31784f386312" class="bulleted-list"><li style="list-style-type:disc"><strong>%</strong> là đơn vị phần trăm sẽ tỉ lệ theo phần tử cha trực tiếp của nó.</li></ul><ul id="dfb0c99a-3a3d-4a75-8b55-fbf1a7a890bb" class="bulleted-list"><li style="list-style-type:disc"><strong><strong>Đơn vị vmin và vmax: </strong></strong>2 đơn vị này tương tự như <strong>vw và vh</strong>. Điểm khác biệt là nó sẽ không tỉ lệ theo 1 hướng mà là cả 2, tuỳ thuộc vào độ lớn của chiều cao và chiều rộng màn hình. Cụ thể:<ul id="48cc7990-3d16-469c-b58e-dd9ef052c583" class="bulleted-list"><li style="list-style-type:circle"><strong>1 vmin</strong> = 1 vw hoặc 1 vh (Lấy cái nhỏ hơn). VD: màn hình của bạn có kích thước là 840×640 thì 1 vmin = 6.4px, nếu màn hình của bạn là 360×480 thì 1 vmin = 3.6px</li></ul><ul id="b5688a57-3d56-4740-8cbc-c311141b2940" class="bulleted-list"><li style="list-style-type:circle"><strong>1 vmax</strong> = 1 vw hoặc 1 vh (Lấy cái lớn hơn). VD: màn hình của bạn có kích thước là 840×640 thì 1 vmin = 8.4px, nếu màn hình của bạn là 360×480 thì 1 vmin = 4.8px</li></ul></li></ul><ul id="4042be08-bd29-4761-8a04-c46caf25f596" class="bulleted-list"><li style="list-style-type:disc"><strong>Các đơn vị tuyệt đối px, pt, cm, in, mm: </strong>Với các đơn vị tuyệt đối thì giá trị của nó được cố định và không bị ảnh hưởng bởi bất kỳ thành phần nào khác, các đơn vị này chỉ nên sử dụng với những thành phần đã được xác định chính xác kích thước và không bị biến thiên bởi các thành phần khác. Hoặc các thuộc tính có kích thước nhỏ, không cần quá chính xác như <code>border: solid 1px;</code> . Thuộc tính hay được sử dụng nhất là px hoặc pt.</li></ul><p id="f3845b72-11c1-47e0-8d5b-b18b0220ad98" class=""><a href="https://dynonguyen.com/tat-tan-tat-don-vi-trong-css/">https://dynonguyen.com/tat-tan-tat-don-vi-trong-css/</a></p></details></li></ul></details></li></ul><ul id="9606cf95-68f1-4311-b1ce-70347fbaf666" class="toggle"><li><details open=""><summary><strong>JS</strong></summary><p id="8c70ee43-0444-4315-a69b-c006ed28b420" class=""><a href="https://completejavascript.com/javascript/">https://completejavascript.com/javascript/</a></p><p id="b291dda1-6033-49ed-b448-84a08e82dcb7" class=""><a href="https://iq.js.org/questions/javascript/difference-between-undefined-and-null">https://iq.js.org/questions/javascript/difference-between-undefined-and-null</a></p><ul id="b4f7c360-2593-43c6-8f34-3be3b295249d" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Function programing</strong></mark></summary><ul id="3ad1b4ad-60fe-40bb-a1a0-1d77f17627bf" class="bulleted-list"><li style="list-style-type:disc">Functional Programming là phương pháp lập trình lấy function làm đơn vị thao tác cơ bản.</li></ul><ul id="fb4438c3-2e85-4459-8f6f-f531d269a28e" class="bulleted-list"><li style="list-style-type:disc"> Các nguyên tắc trong FP:<ul id="faae2f12-d24d-4ba3-850c-b83f49e7d786" class="bulleted-list"><li style="list-style-type:circle"><strong>Immutability</strong>: tính bất biến. Cái nào đã khai báo một lần thì mãi mãi như vậy, không bao giờ thay đổi nữa.</li></ul><ul id="139f2276-9f11-4f52-95ca-3af80a2757ae" class="bulleted-list"><li style="list-style-type:circle"><strong>Purity</strong>: tính thuần khiết, thuần tuý không bị pha tạp. <ul id="fc4d7ebe-5e8a-4030-8f10-cc04f998a007" class="bulleted-list"><li style="list-style-type:square">Tất cả các hàm đều phải là pure function, không có hiệu ứng phụ (side effect), không được tác động lên bất cứ giá trị nào bên ngoài nó, cũng nói không với chỉnh sửa tham số input. </li></ul><ul id="6618291a-6075-47c9-8b87-9c0d439309b0" class="bulleted-list"><li style="list-style-type:square">Đặc điểm quan trọng nữa của pure function là với mỗi tập giá trị đầu vào nhất định, luôn có 1 và chỉ 1 kết quả trả về tương ứng. Đây là tính chất của hàm số toán học. </li></ul><ul id="bb9051c7-49cf-4199-af74-09c6deaf75e0" class="bulleted-list"><li style="list-style-type:square">Pure function trong Functional Programming thường ngắn gọn, đơn giản và chỉ xử lý duy nhất 1 vấn đề logic.</li></ul><pre id="0bec2a74-c352-43a4-9529-00a5ad44e34a" class="code"><code>// not pure function
const getDuration = (timestamp) =&gt; {
  return Date.now() - timestamp;
};

// pure function
const add = (a, b) =&gt; {
  return a + b;
};</code></pre></li></ul></li></ul><ul id="89e99a51-5901-4683-a2c9-05983766dc57" class="bulleted-list"><li style="list-style-type:disc"><strong>Higher order function</strong>: là một khái niệm đến từ Toán học. Bất cứ hàm nào tiếp nhận 1 function như tham số, hoặc trả về 1 function như kết quả, thì đều được coi là higher-order function.</li></ul><ul id="765d5d6c-da61-4c90-8481-320dfae3cb84" class="bulleted-list"><li style="list-style-type:disc"><strong><strong>Function Composition: </strong></strong>Đây là <a href="https://www.mathsisfun.com/sets/functions-composition.html">khái niệm Toán học</a> mà tiếng Việt ta gọi là &quot;hàm hợp&quot;, hay &quot;hàm phức hợp&quot;. Mọi thứ trong Functional Programming đều có nguồn gốc Toán học. <ul id="57074aad-3577-46c5-a4b3-ad096532f97e" class="bulleted-list"><li style="list-style-type:circle">Function Composition là sự phối hợp, liên kết nhiều hàm lại với nhau, thành một hàm lớn, nhiều chức năng hơn.</li></ul><ul id="189b8574-5293-4844-974d-dbd942c35c5f" class="bulleted-list"><li style="list-style-type:circle">Hoặc dễ hiểu đây là cách chúng ta kết hợp nhiều function lại với nhau. Kết quả của function này sẽ được sử dụng cho function tiếp theo. Cứ như vậy nó sẽ tạo thành một chuỗi các function thực hiện các nhiệm vụ theo thứ tự.</li></ul><ul id="b1368299-f03c-4b1d-8d0c-8b6020dcd627" class="bulleted-list"><li style="list-style-type:circle">Có 2 kỹ thuật căn bản trong Function Composition là <code>compose</code> và <code>pipe</code>.<ul id="d1230e6c-9f46-45c0-bf43-3aac6267ac49" class="bulleted-list"><li style="list-style-type:square"><strong>compose</strong>: trong toán học cơ bản với <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y = f(g(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span></span></span></span></span><span>﻿</span></span> ta tính g(x) trước rồi truyền cho f() là ra kết quả, từ phải sang trái. Ý tưởng của <code>compose</code>
 là xếp cuốn chiếu các hàm lại với nhau, theo thứ tự từ trái sang phải để tạo ra một hàm mới, mà khi được thực thi, nó sẽ lần lượt gọi các hàm đã truyền vào trước đó theo thứ tự ngược lại, từ phải sang trái (<code>Right to left</code>)</li></ul><ul id="30e7029b-ef5e-41fd-8c53-14791343acd0" class="bulleted-list"><li style="list-style-type:square"><strong><strong>Pipe: </strong></strong>Một biến thể của <code>compose</code> là <code>pipe</code>, vận hành theo chiều ngược lại. Ta có thể implement bằng cách đảo vị trí <code>f</code> và <code>g</code> (<code>Left to right</code>)</li></ul></li></ul></li></ul><ul id="35a91600-ad5b-48d5-b1cd-e95af5642045" class="bulleted-list"><li style="list-style-type:disc"> <strong><strong>Currying function: </strong></strong>là một HOF, biến đổi 1 function n tham số thành n hàm nhận vào duy nhất 1 tham số</li></ul></details></li></ul><ul id="24eabd47-22a2-42e8-85d8-eb2eabe6433a" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Reactive programing</strong></mark></summary><ul id="c5f21c3d-c2b9-4d52-a369-85d0d9960166" class="bulleted-list"><li style="list-style-type:disc">Có thể giới thiệu ngắn ngọn Reactive = Asynchronous + Non-Blocking I/O (NIO), có nghĩa là một chương trình được gọi là Reactive nó sẽ đảm bảo được 2 yếu tố là Asynchronous (xử lý bất đồng bộ) và Non-Blocking I/O.</li></ul><ul id="7db90c89-cbab-48b3-9514-b769c86fc490" class="bulleted-list"><li style="list-style-type:disc">Bằng cách viết những đoạn mã asynchronous và non-blocking, chương trình sẽ cho phép switch qua các tách vụ khác mà đang sử dụng cùng một I/O resource, và có thể quay lại sử lý tiếp khi tác vụ đó hoàn thành. Do đó với reactive programing chương trình có thể sử lý nhiều request hơn trên cùng một tài nguyên hệ thống.</li></ul><ul id="a0d9ee4d-6727-4a84-befc-3640b0f216af" class="bulleted-list"><li style="list-style-type:disc">Reactive và non-blocking nhìn chung thì không làm cho ứng dụng chạy nhanh hơn. Lợi ích mà nó được kỳ vọng là ứng dụng chịu tải được tốt hơn mà chỉ yêu cầu ít tài nguyên hơn.</li></ul></details></li></ul><ul id="7a845176-4439-47dd-86bc-b690e7d39431" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Hoisting &amp; Javascript hoạt động như thế nào</strong></mark></summary><ul id="4f1cce21-e830-4879-807b-6e676013e0c4" class="bulleted-list"><li style="list-style-type:disc">Hoisting là một hành vi mặc định của Javascript di chuyển việc khai báo lên đầu trong scope của nó.</li></ul><ul id="811ad1e9-2ef4-4889-82af-9714a83a194c" class="bulleted-list"><li style="list-style-type:disc">Tuy nhiên đây là một quan niệm chưa đúng về hoisting, Chúng ta nên xem cách JS hoạt động như thế nào:<ul id="ee9d36c0-a2f9-4d20-a8dd-96737fe82ae2" class="bulleted-list"><li style="list-style-type:circle">Khi bộ máy JS xử lý đoạn code của bạn , nó tạo ra 1 cái gọi là bối cảnh thực thi (execution context). Có 2 quá trình liên quan đến việc tạo cái bối cảnh thực thi này:<ul id="147f1f65-238e-40df-a681-44f2806e1563" class="bulleted-list"><li style="list-style-type:square">Giai đoạn 1 (creation) : Trong giai đoạn này các biến và function được thêm vào bộ nhớ. Bộ máy JS sẽ đi qua một lượt đoạn code của bạn và thêm tất cả các biến vào bộ nhớ máy tính. <strong>Nhưng nó chưa gán giá trị cho các biến này.</strong> Trong khi đó các function thì lại được <strong>thêm toàn bộ vào bộ nhớ bao gồm cả tên và khối code bên trong nó.</strong></li></ul><ul id="1d7ea4d2-2c76-4352-b393-97840cc96e95" class="bulleted-list"><li style="list-style-type:square">Giai đoạn 2 (execution) : Trong giai đoạn này giá trị sẽ được gán cho các biến và function sẽ được gọi. Nên kể cả bạn khởi tạo 1 biến với giá trị ban đầu thì ở giai đoạn 2 này biến mới được gán giá trị. Ở giai đoạn 1 giá trị không được gán cho biến , nó được thêm vào bộ nhớ với giá trị khởi tạo là undefined.</li></ul></li></ul><ul id="eb05e01f-ca9a-445b-acfa-f86972117adf" class="bulleted-list"><li style="list-style-type:circle">Trước khi function được thực thi , nó đã được thêm vào bộ nhớ trong giai đoạn 1 (creation) nên bộ máy Javascript biết function này nằm ở đâu. <strong>Nó không chuyển cái function này lên trên đầu.</strong></li></ul><ul id="d7c84d3f-2ac5-4183-ab60-433207b89eeb" class="bulleted-list"><li style="list-style-type:circle">Đối với biến quá trình cũng giống như vậy nhưng có 1 chút khác biệt. Các biến cũng được thêm vào bộ nhớ trong giai đoạn 1 nhưng không có giá trị nào được gán cho chúng. Trong JS khi một biến được khai báo mà không có giá trị nào bộ máy JS tự động thêm giá trị undefined</li></ul></li></ul><p id="cda52db1-1d45-4c34-8e3d-4c3e95920120" class=""><a href="https://nodejs.vn/user/d%C5%A9ng-v%C5%A9-0">https://nodejs.vn/user/dũng-vũ-0</a></p></details></li></ul><ul id="85c6dead-1447-4c39-a517-61f64332ad48" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Temporal dead zone</strong></mark></summary><ul id="6e68967f-148c-4eaf-a759-11e402432ea9" class="bulleted-list"><li style="list-style-type:disc">Từ es6 trở lên giới thiệu 2 từ khóa <strong>let</strong> và <strong>const</strong> để khai báo biến. </li></ul><ul id="c0476c89-29c0-46fd-ba8f-e71f54b2d725" class="bulleted-list"><li style="list-style-type:disc">Điểm khác biệt so với var là <strong>ở giai đoạn 1 (creation)</strong> <strong>chúng không được khởi tạo với giá trị undefined như với var.</strong> </li></ul><ul id="8d412d22-2434-4043-b412-dbdeb93bf9c3" class="bulleted-list"><li style="list-style-type:disc">Thay vào đó: chúng được set 1 chế độ đặc biệt gọi là <mark class="highlight-red"><strong>Temporal Dead Zone</strong></mark>. Đây là 1 khoảng thời gian giữa việc khai báo và khởi tạo biến. </li></ul><ul id="b73069a1-35b1-480a-9a50-b8b783bb696d" class="bulleted-list"><li style="list-style-type:disc">Trong giai đoạn này bạn sẽ không thể truy cập vào biến đó được. </li></ul><ul id="fbe92ff9-c246-4337-86ff-080fc845ba1d" class="bulleted-list"><li style="list-style-type:disc">Điều này có nghĩa là chúng vẫn tồn tại ở đó nhưng bạn sẽ không thể truy cập được cho đến khi bạn khởi tạo giá trị cho biến sẽ được thực hiện ở giai đoạn 2.</li></ul></details></li></ul><ul id="664f3ae9-dd51-43e4-a3af-2430d591eca3" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Scope</strong></mark></summary><p id="ef25fc38-b313-468e-be12-53f6411caa63" class=""><em>Scope là 1 khái niệm nhằm xác định phạm vi hoạt động của biến.</em></p><ul id="d5c898ba-9f58-40ce-b8e0-71dcfcc37d9e" class="bulleted-list"><li style="list-style-type:disc">Có 2 loại scope: </li></ul><ul id="3575794f-d322-4f7a-9916-ae5ee1db8340" class="bulleted-list"><li style="list-style-type:disc"><strong>Global Scope, </strong><ul id="88b7576e-8060-40a3-8cb0-7902810e0007" class="bulleted-list"><li style="list-style-type:circle">Biến được định nghĩa bên ngoài function sẽ thuộc về <em>Global Scope</em></li></ul><ul id="7ea125dd-effb-4285-92bb-4f72be34d56b" class="bulleted-list"><li style="list-style-type:circle">Biến thuộc Global Scope có thể được sử dụng và thay thế ở bất cứ đâu </li></ul><ul id="441acfe1-1f8e-4755-8935-53aa33a27627" class="bulleted-list"><li style="list-style-type:circle">Nếu biến được định nghĩa mà không sử dụng từ khóa khai báo thì được mặc định thuộc vào Global Scope</li></ul></li></ul><ul id="620eeb00-d8c9-4214-8c58-919738564f1e" class="bulleted-list"><li style="list-style-type:disc"><strong>Local Scope</strong><ul id="1a70a9ea-495f-4097-8b71-17e9ee12bd3b" class="bulleted-list"><li style="list-style-type:circle">Biến được định nghĩa bên trong 1 function sẽ thuộc về <em>Local Scope</em></li></ul><ul id="79aa4446-9f6b-4bc8-a4cd-fed831387179" class="bulleted-list"><li style="list-style-type:circle">Mỗi function khi gọi sẽ tạo ra 1 scope mới. </li></ul><ul id="6cc0bbdc-6167-4d3a-8546-8d7aeffdc411" class="bulleted-list"><li style="list-style-type:circle">Các function khác nhau sẽ tạo ra các scope khác nhau.</li></ul><ul id="ae70b912-95a3-42bd-bb87-6ef4656a10c5" class="bulleted-list"><li style="list-style-type:circle">Điều này dẫn đến có thể khai báo biến trùng tên ở các function khác nhau.</li></ul></li></ul><ul id="4fb1ca8b-d758-4d34-9371-f279fe471c8f" class="bulleted-list"><li style="list-style-type:disc"><strong>Block Statements</strong><ul id="a2deae85-d48d-45e4-9ee5-51985c500b40" class="bulleted-list"><li style="list-style-type:circle"><em>Block statements</em> như điều kiện if và switch hay vòng lặp for và while, không giống như function chúng không tạo ra 1 scope mới. </li></ul><ul id="9f6941d9-b686-48fa-9b73-8a0f371116d2" class="bulleted-list"><li style="list-style-type:circle">Biến được định nghĩa bên trong <em>Block statements</em> sẽ vẫn giữ nguyên scope của nó.</li></ul><ul id="0123d410-3774-4c6c-be95-03398e3d1e7b" class="bulleted-list"><li style="list-style-type:circle">Javascript ES6 giới thiệu 2 từ khóa khai báo biến là let và const. </li></ul><ul id="275cf35a-2cb2-497b-9e15-ac4bbe5d4e2f" class="bulleted-list"><li style="list-style-type:circle">Trái ngược với var, let và const hỗ trợ tạo ra local scope bên trong Block statements</li></ul></li></ul></details></li></ul><ul id="c22f7aab-5935-487f-b488-d9a00d91e76f" class="toggle"><li><details open=""><summary><strong><mark class="highlight-red">spread operator, rest parameters, destructuring</mark></strong></summary><ul id="4bc2bca8-a775-48b8-bbab-6809bed2b567" class="toggle"><li><details open=""><summary><span style="border-bottom:0.05em solid"><strong>Destructuring</strong></span></summary><ul id="a2eb3280-b6b8-463d-9dd0-f4bf6a310999" class="bulleted-list"><li style="list-style-type:disc">Là một cú pháp cho phép bạn gán các thuộc tính của một Object hoặc một Array.</li></ul><ul id="057caf70-a8cd-4320-8e06-26d21b316c28" class="bulleted-list"><li style="list-style-type:disc">Điều này có thể làm giảm đáng kể các dòng mã cần thiết để thao tác dữ liệu trong các cấu trúc này</li></ul><ul id="8e067cd7-9be9-4ba6-9658-ea198e5be3ac" class="bulleted-list"><li style="list-style-type:disc">Có hai loại Destructuring:<mark class="highlight-yellow_background"><strong> Destructuring Objects</strong></mark> và<strong><mark class="highlight-yellow_background"> Destructuring Arrays</mark></strong></li></ul><pre id="77958c9d-fc58-4b92-a567-70ffee2ffe4e" class="code"><code>const info = { id: 1, name: &#x27;Tee&#x27;, gender: &#x27;male&#x27;}
// Destructure properties into variables
const { id, name, gender } = info</code></pre><pre id="00c3adf9-06ed-4475-9448-aca40a555cb6" class="code"><code>const date = [&#x27;10&#x27;, &#x27;01&#x27;, &#x27;1998&#x27;]
// Destructure Array values into variables
const [day, month, year] = date</code></pre></details></li></ul><ul id="a1c91321-4b6c-4320-aa98-d52aeafafa3a" class="toggle"><li><details open=""><summary><span style="border-bottom:0.05em solid"><strong>Spread operator</strong></span></summary><ul id="b19fa21f-4f95-40ab-9ecf-67d5e323fddc" class="bulleted-list"><li style="list-style-type:disc">Là ba dấu chấm <mark class="highlight-yellow_background"><strong>(...)</strong></mark>, có thể chuyển đổi một mảng thành một chuỗi các tham số được phân tách bằng dấu phẩy</li></ul><ul id="3dec0f04-5484-4a89-b779-0004485e65ff" class="bulleted-list"><li style="list-style-type:disc">Spread có thể tao ra một cấu trúc dữ liệu shallow copy để tăng tính thao tác dữ liệu.</li></ul><ul id="70a0d643-ccb3-4ec9-8542-7e21b71dbbf1" class="bulleted-list"><li style="list-style-type:disc">Cũng giống như <mark class="highlight-yellow_background"><strong>destructuring</strong></mark> thì Spread cũng làm việc nhiều với Arrays và Objects</li></ul><pre id="e7908df3-3c76-4e28-802a-4faf2ab68a48" class="code"><code>// Create an Array
const tools = [&#x27;hammer&#x27;, &#x27;screwdriver&#x27;]
const otherTools = [&#x27;wrench&#x27;, &#x27;saw&#x27;]

// Concatenate tools and otherTools together
const allTools = tools.concat(otherTools)

// Unpack the tools Array into the allTools Array
const allTools = [...tools, ...otherTools]</code></pre><pre id="6317b04d-794b-42b7-aeac-766a3e50259a" class="code"><code>// Create a function to multiply three items
function multiply(a, b, c) {
  return a * b * c
}

multiply(1, 2, 3) ;// 6

// Or

const numbers = [1, 2, 3]
multiply(...numbers);//6</code></pre></details></li></ul><ul id="cf0cba46-06ee-46dc-972f-216c2dc87a69" class="toggle"><li><details open=""><summary><span style="border-bottom:0.05em solid"><strong>Rest parameter</strong></span></summary><ul id="41e41f80-dd81-4cad-87bc-823661e39816" class="bulleted-list"><li style="list-style-type:disc">Là một cú pháp tạo ra một array từ một số lượng giá trị không xác định</li></ul><ul id="a1c31099-e886-4462-be1d-ba315ca0efcb" class="bulleted-list"><li style="list-style-type:disc">Giúp chúng ta có thể định nghĩa một hàm với số lượng tham số có thể thay đổi tuỳ ý.</li></ul><ul id="a92144e1-83d6-4040-b96d-22e5169210a3" class="bulleted-list"><li style="list-style-type:disc">Hay nói theo cách khác khi chúng ta không biết chắc chắn số lượng tham số cần có của một hàm chúng ta có thể sử dụng rest parameter</li></ul><ul id="f377badc-7275-4358-9c2b-56031825d85d" class="bulleted-list"><li style="list-style-type:disc">Giống như Spread Syntax (...) nhưng có tác dụng ngược lại</li></ul><pre id="4aeaef0b-9b55-4a61-be96-35a62c9b2594" class="code"><code>function restTest(...args) {
  console.log(args)
}

restTest(1, 2, 3, 4, 5, 6);// [1, 2, 3, 4, 5, 6]</code></pre></details></li></ul><p id="3d816bb1-f6ec-4d37-b5d5-870eeec86aa6" class="">
</p></details></li></ul><ul id="8e187ce1-a148-46c0-9dcd-607ec1973b02" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Deep copy ≠ Shallow copy</strong></mark></summary><p id="1a1f0e88-12c4-4ddc-8703-e4ea039a1024" class=""> <a href="https://www.notion.so/Shallow-Deep-Copy-2331df1919544a089db204d0aaae3ac5">link</a></p></details></li></ul><ul id="687a9dbe-471a-4036-ae78-fc3d8c760016" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Map ≠ SET ≠ WeakMap ≠ WeakSet</strong></mark></summary><ul id="46f39151-c39a-4e32-b57e-edc0d66a7d4f" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Map</strong></mark> trong JavaScript là một <strong>cấu trúc dữ liệu</strong> cho phép lưu trữ dữ liệu theo kiểu <strong>key-value</strong>, tương tự như object. Tuy nhiên, chúng khác nhau ở chỗ là:</summary><ul id="6f835895-466a-4b8b-9066-c51a07226fef" class="bulleted-list"><li style="list-style-type:disc"><strong>Object</strong> chỉ cho phép sử dụng String hay Symbol làm key</li></ul><ul id="f1516c37-43b1-4955-bada-ba0d0402321c" class="bulleted-list"><li style="list-style-type:disc"><strong>Map</strong> cho phép mọi kiểu dữ liệu (String, Number, Boolean, NaN, Object,...) có thể làm key và Map có thuộc tính <strong>size</strong> và một số phương thức đặc trưng</li></ul><ul id="7fb917d4-df53-46e1-9382-9c49d75a2bf0" class="bulleted-list"><li style="list-style-type:disc">Một số phương thức và thuộc tính của Map:<ul id="3ce41824-6571-42da-a641-aab49101836e" class="bulleted-list"><li style="list-style-type:circle"><code>new Map([iterable])</code>: khởi tạo Map với tham số là một iterable object (không bắt buộc) với mỗi phần tử có dạng <code>[key, value]</code>.</li></ul><ul id="faaed235-2e9f-469c-84a2-b9c721c54cb4" class="bulleted-list"><li style="list-style-type:circle"><code>map.set(key, value)</code>: lưu <code>value</code> bởi <code>key</code> và trả về <code>map</code>.</li></ul><ul id="5d3694e4-aff9-41a3-9072-95f028bbd2ab" class="bulleted-list"><li style="list-style-type:circle"><code>map.get(key)</code>: trả về <code>value</code> bởi <code>key</code>, nếu <code>key</code> không tồn tại thì trả về <code>undefined</code>.</li></ul><ul id="7634f8cd-e4ce-46ed-b2f5-8a4c20788983" class="bulleted-list"><li style="list-style-type:circle"><code>map.has(key)</code>: trả về <code>true</code> nếu <code>key</code> tồn tại, ngược lại thì trả về <code>false</code>.</li></ul><ul id="7529ba39-4381-4a99-a631-f2f6b58477dd" class="bulleted-list"><li style="list-style-type:circle"><code>map.delete(key)</code>: xóa giá trị ứng với <code>key</code> và trả về <code>true</code> nếu <code>key</code> tồn tại, ngược lại thì trả về <code>false</code>.</li></ul><ul id="fbd825fb-d681-44f5-af43-46d38ab53be1" class="bulleted-list"><li style="list-style-type:circle"><code>map.clear()</code>: xóa tất cả các phần tử trong <code>map</code>.</li></ul><ul id="8308dbd1-3098-4065-80e1-9b8557512840" class="bulleted-list"><li style="list-style-type:circle"><code>map.size</code>: trả về số phần tử hiện tại có trong <code>map</code>.</li></ul></li></ul><p id="742fa6f3-98f1-400f-86dd-ecd79aed4777" class=""><a href="https://completejavascript.com/so-sanh-map-voi-object-trong-javascript/">https://completejavascript.com/so-sanh-map-voi-object-trong-javascript/</a></p></details></li></ul><ul id="19a7e4db-97e8-4281-bc2b-1b87c743b233" class="toggle"><li><details open=""><summary><strong><mark class="highlight-red">Set</mark></strong><strong> trong Javascript </strong>là một loại object cho phép bạn lưu trữ dữ liệu một cách duy nhất, không trùng lặp.</summary><ul id="5c014177-3c67-463c-93f4-3eb09d261240" class="bulleted-list"><li style="list-style-type:disc">Set là một loại object</li></ul><ul id="5d33d2d5-8698-41d9-9d0f-7d6610e70fea" class="bulleted-list"><li style="list-style-type:disc">Dữ liệu trong set là duy nhất và không trùng lặp. Không trùng lặp ở đây được hiểu là các phần tử không được giống nhau. </li></ul><ul id="1c646ec3-2cbc-4f1a-a979-e1b6fc764eea" class="bulleted-list"><li style="list-style-type:disc">Có thể lưu <code>NaN </code>và <code>undefined</code> vào Set trong JavaScript.</li></ul><ul id="e9d718e7-0e55-4d00-b599-577428bc13db" class="bulleted-list"><li style="list-style-type:disc">Các phương thức của Set là:<ul id="f35f86f3-5fa3-4662-88e5-726736b2bd9d" class="bulleted-list"><li style="list-style-type:circle"><code>new Set(iterable)</code>: khởi tạo Set bằng cách truyền vào một iterable object (không bắt buộc), trường hợp không truyền vào tham số nào thì Set sẽ rỗng.</li></ul><ul id="9efa12e9-1c8c-416d-8c5a-ad218a57b582" class="bulleted-list"><li style="list-style-type:circle"><code>set.add(value)</code>: thêm phần tử <code>value</code> vào Set và trả về chính Set đó.</li></ul><ul id="a8e20ab7-446e-4082-a15d-b22e9ce54bf3" class="bulleted-list"><li style="list-style-type:circle"><code>set.delete(value)</code>: xóa một phần tử trong Set và trả về <code>true</code> nếu giá trị <code>value</code> tồn tại trong Set, ngược lại trả về <code>false</code>.</li></ul><ul id="005f6fed-d447-413f-9f49-17519ddedf95" class="bulleted-list"><li style="list-style-type:circle"><code>set.has(value)</code>: trả về <code>true</code> nếu giá trị <code>value</code> tồn tại trong Set, ngược lại thì trả về <code>false</code>.</li></ul><ul id="7b06da01-5a0a-4715-942c-67bc664d62d2" class="bulleted-list"><li style="list-style-type:circle"><code>set.clear()</code>: xóa tất cả các phần tử trong Set.</li></ul><ul id="7eb3b3cf-6074-4f90-8d7b-87060641d671" class="bulleted-list"><li style="list-style-type:circle"><code>set.size</code>: trả về số lượng phần tử trong Set.</li></ul></li></ul><p id="b84e3833-2259-4d0e-b9a1-b8b6646b5173" class=""><a href="https://completejavascript.com/ban-biet-gi-ve-set-trong-javascript/">https://completejavascript.com/ban-biet-gi-ve-set-trong-javascript/</a></p></details></li></ul><ul id="27663ecd-5046-4814-875d-16359565a12d" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>WeakMap </strong></mark></summary><ul id="402dfedc-d8d0-4615-9b7c-1367ec566419" class="bulleted-list"><li style="list-style-type:disc">WeakMap trong JavaScript tương tự như Map, cho phép lưu trữ dữ liệu theo kiểu <code>key-value</code>. Tuy nhiên, WeakMap chỉ chấp nhận <strong>object</strong> làm <strong>key </strong>còn map thì cho phép tất cả mọi kiểu dữ liệu</li></ul><ul id="c788ecd7-1105-4f71-a030-b8ef74b0b574" class="bulleted-list"><li style="list-style-type:disc">Khi object bị hủy, object tương ứng trong WeakMap sẽ bị giải phóng vì không còn cách nào để truy cập vào object đó nữa.<pre id="90985be2-ca94-4af5-acdc-4dc1e3b99770" class="code"><code>let alex = { name: &quot;Alex&quot; };

// khai báo map và sử dụng biến alex làm key cho map
let map = new Map();
map.set(alex, &quot;1&quot;);

// ghi đè giá trị của biến alex
alex = null;

// mặc dù biến alex bị gán bằng null, nhưng object alex vẫn tồn tại trong map
console.log(map.size); // 1
for (let item of map) {
  console.log(item);
  /**
   * [{name: &#x27;Alex&#x27;}, &#x27;1&#x27;]
   */
}
// Để hủy ta phải dùng method delete trong map</code></pre><pre id="87ff38ab-4569-4e5e-8b0d-63085049c9c0" class="code"><code>let alex = { name: &quot;Alex&quot; };

// khai báo map và sử dụng biến alex làm key cho weakMap
let weakMap = new WeakMap();
weakMap.set(alex, &quot;1&quot;);

// ghi đè giá trị của biến alex
alex = null;

// Sau khi biến alex bị gán bằng null, 
// không còn cách nào có thể truy cập vào phần tử với key là alex trước đó. 
// Vì vậy, object với alex sẽ bị hủy.</code></pre></li></ul><ul id="2db4ac68-c310-4a54-b995-bd673abffe30" class="bulleted-list"><li style="list-style-type:disc">WeakMap không phải iterable object nên không có cách nào để duyệt hết các phần tử trong WeakMap (như cách dùng <code>for...of</code> với Map).</li></ul><ul id="0c249635-31ad-47f1-8331-8f48041f4f1f" class="bulleted-list"><li style="list-style-type:disc">Ứng dụng của weakMap:<ul id="60eedf63-5bf3-4c43-87c9-addcbe163a3b" class="bulleted-list"><li style="list-style-type:circle">Lưu dữ liệu ví dụ lưu lại số lần truy cập của một đối tượng user</li></ul><ul id="c2badb73-c01a-4ff7-b32d-bc61d8c61941" class="bulleted-list"><li style="list-style-type:circle">Caching dữ liệu</li></ul></li></ul><ul id="8ec3f335-1d75-4d0e-a535-5af37c89277f" class="bulleted-list"><li style="list-style-type:disc">Các phương thức của WeakMap là:<ul id="ce865448-36ce-4f00-ad09-26211e317465" class="bulleted-list"><li style="list-style-type:circle"><code>weakMap.set(key, value)</code>: lưu giá trị <code>value</code> vào thuộc tính <code>key</code> và trả về chính WeakMap.</li></ul><ul id="3351281e-872c-4b77-bc3d-2983933c5664" class="bulleted-list"><li style="list-style-type:circle"><code>weakMap.get(key)</code>: trả về giá trị của thuộc tính <code>key</code>, nếu <code>key</code> không tồn tại thì trả về <code>undefined</code>.</li></ul><ul id="ea0ab3a9-adf7-40bb-a59b-2bba7b61d9a3" class="bulleted-list"><li style="list-style-type:circle"><code>weakMap.delete(key)</code>: xóa thuộc tính <code>key</code> trong WeakMap, nếu <code>key</code> tồn tại thì trả về <code>true</code>, ngược lại thì trả về <code>false</code>.</li></ul><ul id="6c0b3b3d-067a-498b-9d3a-e66713f870cf" class="bulleted-list"><li style="list-style-type:circle"><code>weakMap.has(key)</code>: trả về <code>true</code> nếu <code>key</code> tồn tại trong <code>weakMap</code>, ngược lại thì trả về <code>false</code>.</li></ul></li></ul><p id="37f95c1b-3424-406b-a475-01ecf6007757" class=""><a href="https://completejavascript.com/weakmap-trong-javascript/">https://completejavascript.com/weakmap-trong-javascript/</a></p></details></li></ul><ul id="eb002970-c303-43d7-88c3-e58329e9d6f0" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>WeakSet </strong></mark></summary><ul id="3c3ff076-6e84-4673-9eb5-fd46869314bc" class="bulleted-list"><li style="list-style-type:disc">WeakSet trong JavaScript tương tự như Set, cho phép <strong>lưu trữ dữ liệu một cách duy nhất</strong>, không trùng lặp. Tuy nhiên, WeakSet chỉ chấp nhận phần tử kiểu object.</li></ul><ul id="17492764-dc59-4e28-a0a3-8ad250659a7d" class="bulleted-list"><li style="list-style-type:disc">Khi object bị hủy, object tương ứng trong WeakSet sẽ bị giải phóng vì không còn cách nào để truy cập vào object đó nữa.</li></ul><ul id="84d82633-8f7a-48f4-af17-f26b1fb4c41b" class="bulleted-list"><li style="list-style-type:disc">WeakSet không phải iterable object nên không có cách nào để duyệt hết các phần tử trong WeakSet (như cách dùng <code>for...of</code>
 với Set).</li></ul><ul id="356a227c-7f75-45ec-a427-1679abe65df1" class="bulleted-list"><li style="list-style-type:disc">Các phương thức của WeakSet là:<ul id="9e416aab-284f-49da-a0a2-97a42dd923d0" class="bulleted-list"><li style="list-style-type:circle"><code>weakSet.add(value)</code>: lưu giá trị <code>value</code> vào WeakSet và trả về chính WeakSet.</li></ul><ul id="dae3261f-5eb3-4482-a340-c2d33555121a" class="bulleted-list"><li style="list-style-type:circle"><code>weakSet.delete(value)</code>: xóa phần tử <code>value</code> trong WeakSet, nếu <code>value</code> tồn tại thì trả về <code>true</code>, ngược lại thì trả về <code>false</code>.</li></ul><ul id="633fe9c4-1fb2-486a-928c-55579d226fc1" class="bulleted-list"><li style="list-style-type:circle"><code>weakSet.has(value)</code>: trả về <code>true</code> nếu <code>value</code> tồn tại trong <code>weakSet</code>, ngược lại thì trả về <code>false</code>.</li></ul></li></ul><p id="8af03cf7-73db-4003-9b29-b1ee08440088" class=""><a href="https://completejavascript.com/weakset-trong-javascript/">https://completejavascript.com/weakset-trong-javascript/</a></p></details></li></ul></details></li></ul><ul id="db96823a-86f7-4fed-8df1-dea97d3890a5" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>map(), filter(), reduce()</strong></mark></summary><ul id="5e4bd82c-09e3-4136-98b7-0415d61353f8" class="bulleted-list"><li style="list-style-type:disc"><strong>map</strong>: để thực hiện một chức năng trên mỗi phàn tử của một mảng. Sử dụng <mark class="highlight-yellow_background"><strong>map</strong></mark> nếu chúng ta muốn thực hiện cùng một thao tác hoặc chuyển đổi trên từng phần tử của mảng và lấy lại một array mới có cùng <mark class="highlight-yellow_background"><strong>length</strong></mark> với các <mark class="highlight-yellow_background"><strong>value</strong></mark> được chuyển đổi.</li></ul><ul id="12705dad-4882-4412-b2af-75066a9ff036" class="bulleted-list"><li style="list-style-type:disc"><strong>filter</strong>: khi chúng ta muốn xoá các mục không thoã mãn điều kiện. Mỗi phần tử của mãng được truyền cho hàm callback. Trên mỗi lần lặp nếu callback trả về true, thì phần tử đó sẽ được thêm vào mảng mới và ngược lại</li></ul><ul id="70b7f1af-5069-4832-aa41-dcf8e03bbaad" class="bulleted-list"><li style="list-style-type:disc"><strong>reduce</strong>: sử dụng để lặp qua các phần tử của mảng sau đó tính toán và trả về 1 kết quả cuối cùng. Thường được sử dụng để giải quyết các bài toán như lặp qua một mảng → xử lý gì đó → trả về một kết quả cuối cùng</li></ul><p id="e019e475-81ac-4dbe-b712-c856eda2fc48" class=""><a href="https://www.notion.so/JS-Overview-acc91a213fad46f2b2e4b15765f098e5">link</a></p></details></li></ul><ul id="2e6d9393-963b-4bd8-b66e-565d301ee925" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>cookie, session, localStorage</strong></mark></summary><p id="0452c654-2dfa-4ba8-a8f2-f5eec970a7e2" class=""><a href="https://www.notion.so/JS-Overview-67d68f82596c4ad9b36f119f63ad92c5">link</a></p></details></li></ul><ul id="ceb017b6-6268-4153-b137-2f4823932649" class="toggle"><li><details open=""><summary><strong><mark class="highlight-red">async/await ≠ promise ≠ callback</mark></strong></summary><p id="10615db8-25a9-4437-9233-669243266130" class=""><a href="https://completejavascript.com/xu-ly-bat-dong-bo-callback-promise-async-await/">https://completejavascript.com/xu-ly-bat-dong-bo-callback-promise-async-await/</a></p><p id="64522451-df15-47a7-9179-ae18111012e1" class=""><a href="https://completejavascript.com/ket-thuc-som-promise-chaining-trong-javascript/">https://completejavascript.com/ket-thuc-som-promise-chaining-trong-javascript/</a></p><p id="70df7e54-ef83-41b2-aa34-ecace5e438dd" class=""><a href="https://completejavascript.com/xu-ly-bat-dong-bo-song-song-tuan-tu/">https://completejavascript.com/xu-ly-bat-dong-bo-song-song-tuan-tu/</a></p><p id="4980a1c5-eba3-40d2-85b2-fbf871f08cc6" class=""><a href="https://www.notion.so/Callback-Asynchronous-25c2ca13ad314ba1a1e5b0b3d4cd6722">link</a></p></details></li></ul><ul id="bb8418d5-9d34-494c-b690-f8b81b0b1bc2" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>HOF, Currying Fn</strong></mark></summary><p id="e14425fc-a645-4106-a75e-25bef113acd0" class=""><a href="https://www.notion.so/HOF-Currying-2fdc25b2b28b4aacbd18c76ca64810e3">link</a></p></details></li></ul><ul id="49746b48-c962-47b6-ba15-33f6a8299a12" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Closure Fn</strong></mark></summary><ul id="4c28c5f2-1f7c-4586-a3d5-bde1c151dd1a" class="bulleted-list"><li style="list-style-type:disc">Closure là tạo một phạm vi từ vựng đóng bên trong một phạm vi khác, vì vậy phạm vi bên trong có thể truy cập phạm vi bên ngoài. Closure được tạo khi hàm được tạo. Closure là làm cho các biến và phương thức ở chế độ riêng tư trong phạm vi.</li></ul><ul id="5adee3c5-d3b4-48e7-b510-b604832a2233" class="bulleted-list"><li style="list-style-type:disc">Currying là một ví dụ của việc closure. Nó thường tự trả về khi tạo ra lexical environment. Môi trường này bao gồm bất kỳ biến cục bộ nào nằm trong phạm vi tại thời điểm closure được tạo. Nó giống như một nhà máy nhỏ để sản xuất một sản phẩm với các chức năng cụ thể từ các thành phần đó.</li></ul><ul id="cad64112-3d50-4a64-b4a2-ba5e779d8d81" class="bulleted-list"><li style="list-style-type:disc">Không có cách rõ ràng nào để tạo các phương thức private trong JS, nhưng closure có thể ‘private’ các phương thức.</li></ul><p id="0a3207f5-1c85-42a6-a632-c03b2418921f" class=""><a href="https://blog.daovanhung.com/post/scope-closure-this-va-to-chuc-bo-nho-trong-javascript">https://blog.daovanhung.com/post/scope-closure-this-va-to-chuc-bo-nho-trong-javascript</a></p><hr id="16fa177f-ccb9-4ea4-9bcb-0b007088ee4e"/><ul id="f915b1db-4a6a-447b-9a4d-753809638680" class="bulleted-list"><li style="list-style-type:disc">Closure là một hàm có thể ghi nhớ nơi nó được tạo ra và truy cập được các biến ở bên ngoài phạm vi của nó</li></ul><ul id="ed92dafd-0db1-4054-aad4-97e3c3ece34e" class="bulleted-list"><li style="list-style-type:disc">Ứng dụng:<ul id="ff654be6-2bfa-4b57-ba9a-192570ad30e9" class="bulleted-list"><li style="list-style-type:circle">Giúp code viết ngắn gọn hơn</li></ul><ul id="d6e802a3-a0d5-4b30-b44b-41e0326e1d32" class="bulleted-list"><li style="list-style-type:circle">Biểu diễn, ứng dụng tính private trong OOP</li></ul></li></ul><ul id="cee909ec-2d10-46a3-b4f4-dfdf4e9225e2" class="bulleted-list"><li style="list-style-type:disc">Lưu ý: <ul id="e6ee7449-c0bf-4d22-94cf-b915dc902311" class="bulleted-list"><li style="list-style-type:circle">Biến được tham chiếu (refer) trong closure sẽ không được xóa khỏi bộ nhớ khi hàm cha thực thi xong</li></ul><ul id="4a5b0784-c348-426a-8849-1a6628dace55" class="bulleted-list"><li style="list-style-type:circle">Các khái niệm JS nâng cao rất dễ gây nhầm lẫn</li></ul></li></ul><p id="33f2f2b6-bf98-49d2-a4cc-d11487df5566" class=""><a href="https://www.notion.so/JS-Overview-67d68f82596c4ad9b36f119f63ad92c5">link</a></p></details></li></ul><ul id="19303686-8ebc-45cc-8932-54c12db81fb4" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>This, call, apply, bind</strong></mark></summary><p id="4e48638f-a3fa-4ded-b77f-616742971397" class=""><a href="https://www.notion.so/JS-Overview-67d68f82596c4ad9b36f119f63ad92c5">link</a></p><p id="efe96710-a6b3-4f84-9419-fb8c28f63a97" class=""><a href="https://completejavascript.com/phan-biet-call-apply-va-bind-trong-javascript/">https://completejavascript.com/phan-biet-call-apply-va-bind-trong-javascript/</a></p><ul id="3c6552bb-81b9-429c-b766-88a72d3d4066" class="bulleted-list"><li style="list-style-type:disc">Nhìn chung, hàm <code>call</code> và <code>apply</code> là gần giống nhau. Chúng đều gọi hàm trực tiếp. Chỉ khác ở cách truyền tham số vào (với <strong>c</strong>all thì đối số phân cách bởi dấu phẩy <strong>c</strong>omma và với <strong>a</strong>pply thì đối số cho bởi mảng <strong>a</strong>rray)</li></ul><ul id="e3ff1e31-9a46-4960-920b-6fa4c5191a91" class="bulleted-list"><li style="list-style-type:disc">Hàm <code>bind</code> thì hơi khác hơn một chút. Hàm này không gọi hàm trực tiếp mà trả về một hàm mới. Sau đó, bạn có thể sử dụng hàm mới này. Về cách truyền tham số vào thì hàm <code>bind</code> giống với hàm <code>call</code>.</li></ul></details></li></ul><ul id="72e2e5e7-9872-47c0-be1b-c57b37e16bd5" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Prototype</strong></mark></summary><ul id="97eb74b8-1f34-42f3-bdcd-89e58d7e2066" class="bulleted-list"><li style="list-style-type:disc">Prototype là khái niệm cốt lõi trong JavaScript và là cơ chế quan trọng trong việc thực thi mô hình OOP trong JavaScript. </li></ul><ul id="c7495a51-222e-4eb6-bd79-2013ac374f0b" class="bulleted-list"><li style="list-style-type:disc">Tất cả các object trong javascript đều có một prototype, và các object này kế thừa các thuộc tính (properties) cũng như phương thức (methods) từ prototype của mình.</li></ul><ul id="5090336c-b488-47ec-9857-89fdc3eb18a5" class="bulleted-list"><li style="list-style-type:disc">Trong JavaScript, trừ <em>undefined</em>, toàn bộ các kiểu còn lại đều là object. </li></ul><ul id="a3c4ff80-0afe-45f0-9eff-c122ed5ba334" class="bulleted-list"><li style="list-style-type:disc">Các kiểu string, số, boolean lần lượt là object dạng <em>String</em>, <em>Number,</em> <em>Boolean</em>. Mảng là object dạng <em>Array</em>, hàm là object dạng <em>Function</em></li></ul><ul id="203874ee-54b6-49a5-a354-176861f2d9c7" class="bulleted-list"><li style="list-style-type:disc">Trước kia (ES5) trong JavaScript <strong>không có khái niệm class</strong>, do vậy, để <strong>kế thừa các trường/hàm </strong>của một object, ta phải sử dụng prototype.</li></ul><ul id="9c54e2f4-3bd7-46f7-b653-003f94b9cb8e" class="bulleted-list"><li style="list-style-type:disc">Khi ta gọi property hoặc function của một object, JavaScript sẽ tìm trong chính object đó, nếu không có thì tìm lên cha của nó. Do đó, ta có thể gọi các hàm <em>toUpperCase</em>, <em>trim </em>trong String là do các hàm đó đã tồn tại trong <em>String.prototype</em></li></ul><ul id="440ad55d-0600-4635-bcb0-6d30eea42696" class="bulleted-list"><li style="list-style-type:disc">Khi ta thêm function cho prototype, toàn bộ những thằng con của nó cũng học được function tương tự.</li></ul><ul id="5f3e3c6a-d50a-4ba8-a5c2-ba866e91fadb" class="bulleted-list"><li style="list-style-type:disc"><strong>Giới hạn của prototype trong JavaScript:</strong><ul id="a054e154-e1aa-4751-bd36-49d19ced0a4e" class="bulleted-list"><li style="list-style-type:circle">Không được phép kế thừa prototype vòng tròn.</li></ul><ul id="71791f19-42db-42b5-9368-593aadb540d6" class="bulleted-list"><li style="list-style-type:circle">Giá trị của <code>__proto__</code> có thể là <code>null</code> hoặc là một object, nhưng các kiểu dữ liệu khác đều bị bỏ qua.</li></ul><ul id="b4171fe0-cb3d-44ec-959f-5fc1a86f1c08" class="bulleted-list"><li style="list-style-type:circle">Prototype không hỗ trợ thay đổi giá trị thuộc tính</li></ul></li></ul><ul id="d1b7b7a4-b801-4a58-841a-3bcb72d6fcee" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red"><strong>Tóm lại:</strong></mark><ul id="cbcd63ba-05d2-4dde-b16a-eac77fc5428f" class="bulleted-list"><li style="list-style-type:circle">Trong JavaScript, tất cả các object đều có thuộc tính ẩn <code>[[Prototype]]</code> với giá trị là <code>null</code> hoặc kiểu object.</li></ul><ul id="df90cd4b-bb7c-42f4-b7b7-0b22fee3449b" class="bulleted-list"><li style="list-style-type:circle">Bạn có thể sử dụng <code>obj.__proto__</code> như là một <strong>getter/setter</strong> để truy cập vào <code>[[Prototype]]</code>.</li></ul><ul id="1b7f16d8-f5da-40ad-b64c-821e902f2040" class="bulleted-list"><li style="list-style-type:circle">Object ứng với <code>[[Prototype]]</code> được gọi là một prototype.</li></ul><ul id="6bd50868-cae4-4364-a7be-415f2162ab79" class="bulleted-list"><li style="list-style-type:circle">Khi truy cập một thuộc tính hay phương thức trong object mà nó không tồn tại thì JavaScript sẽ tự động tìm kiếm trong prototype.</li></ul><ul id="0cc25be9-ccd7-4476-8aac-0a4b004d9098" class="bulleted-list"><li style="list-style-type:circle">Prototype chỉ hỗ trợ việc đọc, không hỗ trợ ghi/xóa thuộc tính trực tiếp trên prototype.</li></ul><ul id="aff72951-615c-4c77-91e8-ae50ce071763" class="bulleted-list"><li style="list-style-type:circle">Khi bạn gọi <code>obj.method()</code> và <code>method()</code> được lấy từ prototype, giá trị của <code>this</code> vẫn tham chiếu đến <code>obj</code> chứ không phải prototype.</li></ul><ul id="a569f9b6-2e8a-45f3-b23f-72b86cd9b68f" class="bulleted-list"><li style="list-style-type:circle">Vòng lặp <code>for...in</code> duyệt tất cả các thuộc tính trong object và thuộc tính của prototype thông qua kế thừa.</li></ul></li></ul><ul id="b2a523e5-f827-49b8-92e7-96162b2f81d7" class="bulleted-list"><li style="list-style-type:disc"><a href="https://completejavascript.com/prototype-la-gi-prototype-trong-javascript/">https://completejavascript.com/prototype-la-gi-prototype-trong-javascript/</a></li></ul></details></li></ul><ul id="36ec6f66-0fce-41aa-9c73-6799f7fa701c" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Side effect?  </strong></mark></summary><ul id="06acad0b-e46d-42c9-aea0-ba53390f57bb" class="bulleted-list"><li style="list-style-type:disc">Side effects dùng để: <ul id="6a205029-8e3c-4829-951a-b4e3ae6a1c56" class="bulleted-list"><li style="list-style-type:circle">Gọi API lấy dữ liệu</li></ul><ul id="0307b52a-b31b-4791-a6c9-fff1181e6dcf" class="bulleted-list"><li style="list-style-type:circle">Tương tác với DOM</li></ul><ul id="f91b6b3d-81f8-47aa-8232-c90bbd5b45b6" class="bulleted-list"><li style="list-style-type:circle">Subscriptions</li></ul><ul id="cd3031fc-2717-4349-b1f7-5afa36b80912" class="bulleted-list"><li style="list-style-type:circle">setTimeOut, setInterval</li></ul></li></ul><ul id="9dfd1c7c-bc3c-4534-86e9-86d4e0cefa45" class="bulleted-list"><li style="list-style-type:disc">Có 2 loại side effects:<ul id="8636a696-7ef5-4e69-a106-89f4e9106e99" class="bulleted-list"><li style="list-style-type:circle">Effects <strong><mark class="highlight-yellow_background">không cần clean up</mark></strong>: gọi API, tương tác với DOM</li></ul><ul id="f2dffeab-b679-4f33-a255-1062582fe61b" class="bulleted-list"><li style="list-style-type:circle">Effects <mark class="highlight-yellow_background"><strong>cần clean up</strong></mark>: subscriptions, setTimeOut, setInterval </li></ul></li></ul></details></li></ul><ul id="b53c8361-0daa-4688-9812-be1e53eb628c" class="toggle"><li><details open=""><summary><strong><mark class="highlight-red">Hãy giải thích về event delegation</mark></strong></summary><ul id="f1f4faaf-0ca6-4b4c-9a30-417063a383a9" class="bulleted-list"><li style="list-style-type:disc">Event delegation là một kỹ thuật liên quan đến việc thêm event listeners vào một phần tử mẹ thay vì thêm chúng vào các phần tử con.</li></ul><ul id="75c45555-a2dd-40b3-8fbd-e02cc16ed53b" class="bulleted-list"><li style="list-style-type:disc"> Listeners sẽ kích hoạt bất cứ khi nào sự kiện được kích hoạt trên các phần tử con do sự kiện làm nổi bong bóng (bubbling up) DOM. </li></ul><ul id="7988997d-4778-4f39-82e7-0129a28d3baa" class="bulleted-list"><li style="list-style-type:disc">Lợi ích của kỹ thuật này là:<ul id="fcdddf42-1046-4fb8-b40e-b999d735b577" class="bulleted-list"><li style="list-style-type:circle">Memory footprint giảm xuống vì chỉ cần một trình xử lý duy nhất trên phần tử mẹ, thay vì phải đính kèm các trình xử lý sự kiện trên mỗi phần tử con.</li></ul><ul id="93422a43-8fa0-4c30-bfee-778ed6d747cf" class="bulleted-list"><li style="list-style-type:circle">Không cần phải hủy liên kết trình xử lý khỏi các phần tử bị xóa và liên kết sự kiện cho các phần tử mới.</li></ul></li></ul></details></li></ul><ul id="930da6a0-4e18-46d2-99d6-a78fc4d4e923" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong><strong>Sự khác biệt giữa </strong></strong></mark><mark class="highlight-red"><code><strong><strong>Set</strong></strong></code></mark><mark class="highlight-red"><strong><strong>, </strong></strong></mark><mark class="highlight-red"><code><strong><strong>WeakSet</strong></strong></code></mark><mark class="highlight-red"><strong><strong>, </strong></strong></mark><mark class="highlight-red"><code><strong><strong>Map </strong></strong></code></mark><mark class="highlight-red"><strong><strong>và </strong></strong></mark><mark class="highlight-red"><code><strong><strong>WeakMap </strong></strong></code></mark><mark class="highlight-red"><strong><strong>trong JavaScript là gì?</strong></strong></mark></summary><ul id="237b4e0e-4482-4bb4-b026-44fd4c77ba40" class="bulleted-list"><li style="list-style-type:disc"><code><strong>WeakSet</strong></code><code> </code>và <code><strong>Set</strong></code><strong> </strong>đều là tập hợp các giá trị duy nhất. Sự khác biệt chính là <code><strong>WeakSet</strong></code><code> </code>chỉ lưu trữ đối tượng và không thể chứa các giá trị tùy ý thuộc bất kỳ loại nào, nhưng các <code><strong>Set</strong></code>thì có thể.</li></ul><ul id="8001a6fa-f635-4ba8-a05b-9215ebf65a5b" class="bulleted-list"><li style="list-style-type:disc">Sets hữu ích khi bạn cần nối từng dữ liệu một vào cấu trúc dữ liệu nhưng cũng muốn loại bỏ các phần trùng lặp. Các hoạt động tập hợp có giá trị trung bình là <code><strong>O(1)</strong></code>, điều này làm cho chúng tiết kiệm thời gian.</li></ul><ul id="fc0c8c6d-747a-400d-9dc0-7bd8e392f238" class="bulleted-list"><li style="list-style-type:disc"><code><strong>WeakMap</strong></code> và <code><strong>Map</strong></code> là tập hợp các cặp khóa / giá trị. Sự khác biệt chính là trong <code><strong>WeakMap</strong></code>, các khóa phải là các đối tượng. Trong <code><strong>Map</strong></code>, các khóa có thể thuộc bất kỳ loại nào.</li></ul><ul id="deb31508-90ae-4023-9508-0ec682a15b34" class="bulleted-list"><li style="list-style-type:disc">Cũng cần biết rằng các giá trị <code><strong>WeakMap</strong></code> không thể được lặp lại và chúng giữ một tham chiếu yếu (weak reference) đến khóa. Ví dụ: nếu bạn xóa thủ công một khóa được tham chiếu trong <code><strong>WeakMap</strong></code>, khóa đó sẽ được thu gom.</li></ul></details></li></ul><ul id="272f6687-52d9-4081-a8ac-bfe19186b5a3" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong><strong>Sự khác biệt giữa các host objects và native objects là gì?</strong></strong></mark></summary><ul id="160604ea-da60-4962-89c3-f83e29bd9251" class="bulleted-list"><li style="list-style-type:disc">Native objects là các đối tượng là một phần của ngôn ngữ JavaScript được xác định bởi đặc tả ECMAScript, chẳng hạn như <code><strong>String</strong></code><strong>, </strong><code><strong>Math</strong></code><strong>, </strong><code><strong>RegExp</strong></code><strong>, </strong><code><strong>Object</strong></code><strong>, </strong><code><strong>Function</strong></code>, v.v.</li></ul><ul id="f4725293-2198-4427-99d6-a64d248ae5bd" class="bulleted-list"><li style="list-style-type:disc">Host objects được cung cấp bởi môi trường thời gian chạy (trình duyệt hoặc Node), chẳng hạn như <code><strong>window</strong></code><strong>, </strong><code><strong>XMLHTTPRequest</strong></code>, v.v.</li></ul></details></li></ul><ul id="61064561-3b8d-430c-a2ea-d24f73c49473" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Sự khác biệt giữa</strong></mark><mark class="highlight-red"><strong><code> let</code></strong></mark><mark class="highlight-red"><strong>, </strong></mark><mark class="highlight-red"><strong><code>const</code></strong></mark><mark class="highlight-red"><strong> và </strong></mark><mark class="highlight-red"><strong><code>var </code></strong></mark><mark class="highlight-red"><strong>là gì?</strong></mark></summary><p id="34fc7cf2-a1f3-4313-ad83-0fb1ffb938af" class="">Ban đầu, <code><strong>var</strong></code><strong> </strong>là tùy chọn duy nhất mà JavaScript có để xác định các biến. Trong ES6, chúng ta có <strong>const</strong> và <code><strong>let</strong></code><code> </code>là các tùy chọn bổ sung.</p><ul id="20e0ab4d-8bb8-4587-bea7-22bcb379c191" class="bulleted-list"><li style="list-style-type:disc">Các biến được xác định bằng <code><strong>const</strong></code><code> </code>không thể được gán lại.</li></ul><ul id="641f0cb0-a92e-4160-b5e6-b36963657fc8" class="bulleted-list"><li style="list-style-type:disc">Các biến <code><strong>Const</strong></code><code> </code>và <code><strong>let</strong></code><code> </code>là phạm vi khối.</li></ul><ul id="08f36309-06e7-450e-8b75-d5c8d4671e08" class="bulleted-list"><li style="list-style-type:disc">Biến <code><strong>Var</strong></code><strong> </strong>là function scoped.</li></ul><ul id="14ebc5e6-1c84-468b-8c7b-95984d7b0e28" class="bulleted-list"><li style="list-style-type:disc">Các biến được xác định bằng <code><strong>var</strong></code><code> </code>được sử dụng theo cơ chế hoisting</li></ul></details></li></ul><ul id="c2426694-e658-4ffb-b819-6530240c2a3e" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong><strong>Làm cách nào để bạn kiểm tra xem một biến có phải là một số trong JavaScript hay không?</strong></strong></mark></summary><ul id="cc82a59b-c262-47fa-9612-440ce1c61170" class="bulleted-list"><li style="list-style-type:disc">Để kiểm tra xem một biến có phải là số hay không, chúng ta có thể sử dụng hàm<code><strong> isNaN ()</strong></code><strong> </strong>trong JavaScript. Nó xác định xem một giá trị có phải là một số hay không.</li></ul></details></li></ul><ul id="aaa53546-c660-4210-8013-8125c954eabf" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong><strong>Giải thích cách hoạt động của </strong></strong></mark><mark class="highlight-red"><code><strong><strong>this</strong></strong></code></mark><mark class="highlight-red"><strong><strong> trong JavaScript</strong></strong></mark></summary><ul id="314ced3e-6005-4a46-bdd7-1622a26af53e" class="bulleted-list"><li style="list-style-type:disc">Không có lời giải thích đơn giản nào cho <code><strong>this</strong></code>; nó là một trong những khái niệm khó hiểu nhất trong JavaScript. Giá trị của <code><strong>this</strong></code> phụ thuộc vào cách hàm được gọi.  Các quy tắc sau được áp dụng:<ul id="4f7540aa-66d1-47cf-83c1-62cfbe86bc8b" class="bulleted-list"><li style="list-style-type:circle">Nếu từ khóa <code><strong>new</strong></code> được sử dụng khi gọi hàm, thì bên trong hàm này là một đối tượng hoàn toàn mới.</li></ul><ul id="1fe77498-08bc-4bd8-96a3-7f8e88d5a963" class="bulleted-list"><li style="list-style-type:circle">Nếu <code><strong>apply, call</strong></code><code> </code>hoặc <code><strong>bind</strong></code> được sử dụng để gọi / tạo một hàm, thì bên trong hàm này là đối tượng được truyền vào dưới dạng đối số.</li></ul><ul id="650be444-672e-4f7e-b0fc-39ad4d800ad9" class="bulleted-list"><li style="list-style-type:circle">Nếu một hàm được gọi là một phương thức, chẳng hạn như <code><strong>obj.method ()</strong></code> – thì <code><strong>this</strong></code> là đối tượng mà hàm là thuộc tính của nó.</li></ul><ul id="134d395e-9a83-40e8-a507-746d4c3e8fb6" class="bulleted-list"><li style="list-style-type:circle">Nếu một hàm được gọi dưới dạng một lệnh gọi hàm miễn phí, nghĩa là nó được gọi mà không có bất kỳ điều kiện nào ở trên, thì đây là đối tượng toàn cục. Trong trình duyệt, nó là đối tượng <code><strong>window</strong></code>. Nếu ở chế độ nghiêm ngặt (<code>&#x27;use strict&#x27;</code>), <code><strong>this</strong></code> sẽ là <code>undefined</code> thay vì đối tượng toàn cục.</li></ul><ul id="a4b01d3f-e8a0-40cd-a773-32c10639188f" class="bulleted-list"><li style="list-style-type:circle">Nếu áp dụng nhiều quy tắc trên, quy tắc nào cao hơn sẽ được ưu tiên và sẽ đặt giá trị này.</li></ul><ul id="3e5d6d6b-c92e-4f21-a6b8-d97b7d89728a" class="bulleted-list"><li style="list-style-type:circle">Nếu hàm là một arrow function ES2015, nó sẽ bỏ qua tất cả các quy tắc ở trên và nhận <code><strong>this</strong></code> của phạm vi xung quanh tại thời điểm nó được tạo.</li></ul></li></ul><p id="e2007f11-f392-49ed-a7a7-f589a3e0823d" class="">
</p><p id="a7b9b40f-6dad-4c00-a463-e96f85dfbbe9" class="">
</p><p id="1f10cd88-d287-419c-88d8-bab48264366e" class="">
</p><p id="41191d00-97fa-4276-b4e5-54d931a96f37" class="">
</p></details></li></ul><ul id="010e8289-4cd1-47e6-9c5d-f1fd5b26c4a4" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Javascript Proxy</strong></mark></summary><ul id="2f10d39e-f12f-4a4c-afa7-c355cb4b3459" class="bulleted-list"><li style="list-style-type:disc"><strong>Proxy</strong> là một class được giới thiệu từ ES6, cho phép bạn can thiệp và thay đổi hành vi của một đối tượng (object). </li></ul><ul id="2a34118f-ed78-4b6f-9ec2-1fce40bd58aa" class="bulleted-list"><li style="list-style-type:disc">Các hành vi này bao gồm: truy xuất/thiết lập (getter/setter) thuộc tính của một đối tượng, thay đổi prototype, gọi hàm, khởi tạo đối tượng bằng từ khóa <code>new</code></li></ul><ul id="3de6663f-3d82-423d-a86e-8a18689e3728" class="bulleted-list"><li style="list-style-type:disc">Chúng ta có thể áp dụng Proxy cho bất cứ object nào trong JavaScript, kể cả mảng, hàm hay một proxy khác.</li></ul><ul id="5f34f3d4-2a73-4420-ab17-8bf917d4b608" class="bulleted-list"><li style="list-style-type:disc">Cú pháp:<pre id="c5044dfb-d8ae-4d2c-a283-a2b31f0ff5d7" class="code"><code>const p = new Proxy(target, handler);</code></pre><ul id="bfbfb05d-51d2-40d0-9b79-a56eaa68ee26" class="bulleted-list"><li style="list-style-type:circle">Trong đó<ul id="15d1caab-7298-46ab-bb8e-c4e90b66379c" class="bulleted-list"><li style="list-style-type:square"><strong>target</strong>: là đối tượng sẽ được áp dụng proxy vào</li></ul><ul id="d63fc9e2-57ac-4366-bd6e-c8579322566c" class="bulleted-list"><li style="list-style-type:square"><strong>traps</strong>: là những phương thức giúp bạn thay đổi hành vi của đối tượng</li></ul><ul id="9aa9e466-ca66-498b-98ca-094b540860ca" class="bulleted-list"><li style="list-style-type:square"><strong>handler</strong>: là một object chứa các traps, được đưa vào hàm dựng của lớp Proxy</li></ul></li></ul><ul id="f6e3d3b2-2acb-459c-a6d5-e40ad89e7fb5" class="bulleted-list"><li style="list-style-type:circle">Một số <strong>traps</strong> thông dụng:<ul id="ed8be8e9-ce29-4a9c-a00d-d6a20f3f969f" class="bulleted-list"><li style="list-style-type:square"><strong><code>handler.get()</code></strong></li></ul><ul id="f2775dbb-61d0-4682-8072-2f86a3378d76" class="bulleted-list"><li style="list-style-type:square"><strong><code>handler.set()</code></strong></li></ul><ul id="838a3323-82e9-4f04-8f1f-3b94980165f6" class="bulleted-list"><li style="list-style-type:square"><strong><code>handler.defineProperty()</code></strong></li></ul><ul id="8e6801b1-0d0c-422f-a4cb-47a9e83738e0" class="bulleted-list"><li style="list-style-type:square"><strong><code>handler.deleteProperty()</code></strong></li></ul><ul id="a05cdd68-8d78-4897-bacf-c4836f7403e0" class="bulleted-list"><li style="list-style-type:square"><strong><code>handler.has()</code></strong></li></ul><ul id="0241a380-3ddc-442f-bff5-73f5f115f0c2" class="bulleted-list"><li style="list-style-type:square"><strong><code>handler.apply()</code></strong></li></ul><ul id="aa2bfae6-fde9-46b0-b3f1-dc55bec1aca8" class="bulleted-list"><li style="list-style-type:square"><code><strong>handler.construct()</strong></code></li></ul></li></ul></li></ul><ul id="fc2b0a5e-28de-4faf-93b9-a578ae6118e7" class="bulleted-list"><li style="list-style-type:disc">Ví dụ:<pre id="1d669d0d-c0a3-4200-9d90-04388974b258" class="code"><code>
const u = { name: &#x27;Công Tằng Tôn Nữ Tạ Thị Tòn Ten&#x27; }

// Thiết lập proxy cho đối tượng `u`
const p = new Proxy(u, {
  // `get` là một trap, sẽ được gọi khi truy xuất đến thuộc tính
  // của đối tượng
  get(target, prop, receiver) {
    // Thay đổi hành vi khi truy xuất đến một thuộc tính: Nếu là
    // chuỗi, chuyển sang chữ hoa
    if (typeof target[prop] === &#x27;string&#x27;) return target[prop].toUpperCase()

    return target[prop]
  },
})

console.log(p.name) // CÔNG TẰNG TÔN NỮ TẠ THỊ TÒN TEN
p.email = &#x27;ta.thi@ton.ten&#x27;
console.log(p.email) // TA.THI@TON.TEN</code></pre></li></ul><ul id="b6bcb02d-e986-4365-9ed6-accf35c655b1" class="bulleted-list"><li style="list-style-type:disc"><a href="https://ehkoo.com/bai-viet/tim-hieu-ve-proxy-trong-es6">https://ehkoo.com/bai-viet/tim-hieu-ve-proxy-trong-es6</a></li></ul></details></li></ul><ul id="aff5f744-015b-4f66-8c88-3a2558443c33" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Event loop, message queue</strong></mark></summary><ul id="95f4e3c2-cd9f-43ac-8269-470ce53d6746" class="bulleted-list"><li style="list-style-type:disc"><a href="https://viblo.asia/p/cuoi-cung-thi-event-loop-la-gi-LzD5dX705jY">https://viblo.asia/p/cuoi-cung-thi-event-loop-la-gi-LzD5dX705jY</a></li></ul><ul id="f0bc7da0-3e18-4d61-8de6-1b0fabed0937" class="bulleted-list"><li style="list-style-type:disc"><a href="https://dynonguyen.com/event-loop-bat-dong-bo-trong-javascript/">https://dynonguyen.com/event-loop-bat-dong-bo-trong-javascript/</a></li></ul></details></li></ul><ul id="2f0ff424-591d-4ef9-b6d3-9d5c50663ccc" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>factories ≠ class</strong></mark></summary><ul id="aa206684-6f8d-4c8c-8281-958e33334c16" class="bulleted-list"><li style="list-style-type:disc">Một factory function là bất kỳ hàm nào mà nó không phải là một class, một constructor trả về một object. </li></ul><ul id="af64e9f4-0fd1-4618-8d46-79d765b90c0d" class="bulleted-list"><li style="list-style-type:disc">Trong Javascript bất kỳ hàm nào cũng có thể trả về một một object. Khi thực hiện điều đó mà nó không dùng từ khóa <code>new</code> thì đó là <mark class="highlight-red"><strong>factory function. </strong></mark>Ngược lại thì là<mark class="highlight-red"><strong> constructor function</strong></mark></li></ul><ul id="abc425c1-3b82-4837-9c5c-113b0fb7733f" class="bulleted-list"><li style="list-style-type:disc"><a href="https://medium.com/@jeffrey.k.vy/factory-function-v%C3%A0-constructor-function-trong-javascript-d80292d7255">https://medium.com/@jeffrey.k.vy/factory-function-và-constructor-function-trong-javascript-d80292d7255</a></li></ul></details></li></ul><ul id="7c36d6fb-7007-40c3-8855-977f5a37b105" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>setTimeout, setInterval</strong></mark></summary><ul id="3550555f-16cf-48aa-b40c-d2b5c667c00a" class="bulleted-list"><li style="list-style-type:disc">Là những hàm cho phép bạn thực hiện một đoạn mã Javascript tại một thời điểm nào đó trong tương lai. Nó được gọi là &quot;lập lịch một cuộc gọi&quot; (scheduling a call)<ul id="c3055712-d7e5-4012-9c31-9c777bd5ff58" class="bulleted-list"><li style="list-style-type:circle"><strong><mark class="highlight-yellow_background">setTimeout</mark></strong>: sử dụng để thực thi một hàm hoặc đoạn mã được chỉ định chỉ một lần sau một khoảng thời gian nhất định.</li></ul><ul id="0e54c5e3-ef7c-4a23-9619-5c783e1d3544" class="bulleted-list"><li style="list-style-type:circle"><strong><mark class="highlight-yellow_background">setInterval</mark></strong>: sử dụng để thực thi một hàm hoặc đoạn mã được chỉ định lặp đi lặp lại vào những khoảng thời gian cố định.</li></ul></li></ul><ul id="53ca6dd0-5bfc-45e5-acca-282ecadfdff6" class="bulleted-list"><li style="list-style-type:disc">Dừng thực thi bộ đếm thời gian sử dụng: <mark class="highlight-yellow_background"><strong>clearTimeout() </strong></mark>và <strong><mark class="highlight-yellow_background">clearInterval()</mark></strong></li></ul></details></li></ul><ul id="56f88dc9-a566-4267-96b4-56a6becdbda2" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>web worker</strong></mark></summary><ul id="5b18deda-1da5-46a6-8c39-e811f75918c8" class="bulleted-list"><li style="list-style-type:disc">JavaScript là một ngôn ngữ chạy đơn luồng. Điều đó có nghĩa là nếu bạn thực hiện một tác vụ quá lớn trên giao diện chính thì khả năng cao là giao diện sẽ bị đơ. </li></ul><ul id="5604686a-7d70-4191-8d14-f56f85021590" class="bulleted-list"><li style="list-style-type:disc">Để giải quyết vấn đề này, JavaScript đã đưa ra một khái niệm là Worker</li></ul><ul id="b9d3339f-7701-4157-9f45-b41ce6dcab72" class="bulleted-list"><li style="list-style-type:disc">Web Worker không phải của Javascript, mà đây là một tính năng của trình duyệt cho phép chúng ta truy xuất qua Javascript<hr id="8ff5e293-d445-4cf0-8e34-b83c8e92dbd5"/></li></ul><ul id="9f766f04-5874-4d2b-a097-ef51e554b6f3" class="bulleted-list"><li style="list-style-type:disc">Web Worker là một đối tượng trong Javascript được tạo ra bởi các hàm constructor như <code>Worker</code>, <code>SharedWorker</code>... với tham số được truyền vào là một file JS chứa các đoạn code sẽ được thực thi bởi Worker. Các script được viết trong file này sẽ được thực thi ngầm, không ảnh hưởng đến trải nghiệm của người dùng. Vì vậy với các tác vụ tốn nhiều thời gian các bạn có thể dùng Worker để xử lý.</li></ul><ul id="ff1d0d3b-2985-4bd0-8188-b4ec9b04f937" class="bulleted-list"><li style="list-style-type:disc">Web Workers là tiến trình trong trình duyệt nhưng có thể được dùng để thực thi Javascript code mà không cản trở event loop</li></ul><ul id="938e5f32-a822-477e-8cfc-34c5d50be6f4" class="bulleted-list"><li style="list-style-type:disc">Web Workers cho phép developer đặt những công việc có thời gian chạy dài và những công việc nặng về xử lý tính toán trong background mà không gây trở ngại đến UI, làm app của bạn mượt mà hơn. Ngoài ra, không cần phải xài trick với <code>setTimeout</code> để đánh lừa event loop nữa.</li></ul><ul id="1807bd8d-197d-4c40-aead-b2986ef04139" class="bulleted-list"><li style="list-style-type:disc">Web Workers cho phép bạn làm những việc như thực thi các đoạn code xử lý tốn thời gian để tính toán các phép tính hao tổn nhiều CPU nhưng không làm cản trở UI. Thực ra, nó sẽ chạy song song. Web Workers là đa luồng.</li></ul><ul id="bf651ddd-4c11-4f66-8866-32d9a7a6ed71" class="bulleted-list"><li style="list-style-type:disc">Có 3 loại Web Workers:<ul id="65d61cfa-2a5d-4cb2-9c22-3843f9793e92" class="bulleted-list"><li style="list-style-type:circle">Dedicated worker</li></ul><ul id="12a37df4-7151-4953-99b5-d7443240f06a" class="bulleted-list"><li style="list-style-type:circle">Shared worker</li></ul><ul id="b0a82abe-a9cc-4f6b-92c3-23a4c02c2c94" class="bulleted-list"><li style="list-style-type:circle">Service worker</li></ul></li></ul><p id="78c3351b-b8eb-434c-ba2f-1359e177b8f4" class=""><a href="https://kipalog.com/posts/Duc-khoet-Javascript--Phan-7---Thanh-phan-cua-WebWorker---5-truong-hop-su-dung">https://kipalog.com/posts/Duc-khoet-Javascript--Phan-7---Thanh-phan-cua-WebWorker---5-truong-hop-su-dung</a></p><p id="853afef1-ecd4-4aec-b34f-147590abe83c" class=""><a href="https://2kvn.com/web-worker-anh-cong-nhan-tham-lang-trong-ung-dung-cua-ban-p5f33313835">https://2kvn.com/web-worker-anh-cong-nhan-tham-lang-trong-ung-dung-cua-ban-p5f33313835</a></p><p id="4bb6def1-801e-4c31-815f-01c996f7f903" class=""><a href="https://completejavascript.com/javascript-web-worker-javascript-o-background/">https://completejavascript.com/javascript-web-worker-javascript-o-background/</a></p></details></li></ul></details></li></ul><ul id="910ed7d6-5cf9-4bbe-85f9-dcee5da0504a" class="toggle"><li><details open=""><summary><strong>TS</strong></summary><ol type="1" id="b270df7a-f328-41f3-a690-a882678b48d3" class="numbered-list" start="1"><li>Interface ≠ type</li></ol><ol type="1" id="4e7179c3-7b84-4162-8b26-889859d9120a" class="numbered-list" start="2"><li>Generic</li></ol><ol type="1" id="32602bd8-e410-4d9b-9f7d-7d4ccb252608" class="numbered-list" start="3"><li>Class</li></ol></details></li></ul><ul id="8b865ef2-6180-45d9-a025-87c850c7a8f0" class="toggle"><li><details open=""><summary><strong>Backend</strong></summary><ul id="6760078f-3574-46ab-b78a-152cf7f5843c" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Microservice ≠ Monolithic</strong></mark></summary><ul id="c8acf9ce-b631-4a35-9cab-6337eaa3d625" class="toggle"><li><details open=""><summary><strong>Monolithic</strong> </summary><ul id="26e8b8f4-5ac5-4bdb-bdff-e7d728212ebf" class="bulleted-list"><li style="list-style-type:disc">là kiến trúc phần mềm dạng nguyên khối, nghĩa là mọi tính năng sẽ nằm trong một project. </li></ul><ul id="ee58f0ca-f035-4801-a3bf-2cb95881f2e3" class="bulleted-list"><li style="list-style-type:disc">Giả sử mình có một project web bán hàng triển khai theo kiến trúc monolithic, thì các module như khách hàng, đơn hàng, sản phẩm,… sẽ được gói gọn trong project đó.</li></ul><ul id="89b0c622-0c76-47f8-aa8c-231fbd5ecc2d" class="bulleted-list"><li style="list-style-type:disc"><strong>Ưu điểm: </strong><ul id="3aadf4b8-c101-4558-a9b5-f1ad5a04170f" class="bulleted-list"><li style="list-style-type:circle">Dễ phát triển vì các stack công nghệ thống nhất ở tất cả các layer.</li></ul><ul id="38f2b826-3205-40f2-8d73-e05e84ffc1cb" class="bulleted-list"><li style="list-style-type:circle">Dễ test do toàn bộ project được đóng gói trong một package nên dễ dàng chạy test integrantion và test end-to-end.</li></ul><ul id="d50a3c9e-4840-4e8a-8d64-3b492aa8544c" class="bulleted-list"><li style="list-style-type:circle">Deploy đơn giản và nhanh chóng nếu bạn chỉ có một package để bận tâm.</li></ul><ul id="9c65fe2a-173e-4d7d-84e7-931d314bf517" class="bulleted-list"><li style="list-style-type:circle">Dễ scale vì chúng ta có thể có nhiều instance cho load banlancer.</li></ul><ul id="bb3557aa-8efe-4490-9b7d-e5e935208541" class="bulleted-list"><li style="list-style-type:circle">Yêu cầu team size nhỏ cho việc maintain app.</li></ul><ul id="a3c42a2b-cf2c-488f-91c2-7282bb53b94b" class="bulleted-list"><li style="list-style-type:circle">Team member có thể chia sẻ ít nhiều về skill.</li></ul><ul id="2a436b6c-e89b-46c3-b9e5-70d209e6e0fe" class="bulleted-list"><li style="list-style-type:circle">Tech stack đơn giản và đa số là dễ học.</li></ul><ul id="1e2427ed-944c-495d-b1bf-b7ee658b659b" class="bulleted-list"><li style="list-style-type:circle">Phát triển ban đầu nhanh hơn do đó có thể đem sale hoặc marketing nhanh hơn.</li></ul><ul id="6f882862-93ae-479d-b37a-a92cb07cc755" class="bulleted-list"><li style="list-style-type:circle">Yêu cầu cơ sở hạ tầng đơn giản. Thậm chí một container đơn giản cũng đủ để chạy ứng dụng.</li></ul></li></ul><ul id="667a5091-0dec-438b-8eda-0f8a1440e6e7" class="bulleted-list"><li style="list-style-type:disc"><strong>Nhược điểm:</strong><ul id="cdd2ef1e-190d-4552-b8ff-decc496674f7" class="bulleted-list"><li style="list-style-type:circle">Các component được liên kết chặt chẽ với nhau dẫn đến side effect không mong muốn như khi thay đổi một component ảnh hưởng đến một component khác.</li></ul><ul id="3810e5bb-8a59-43df-b484-035e57ad57ef" class="bulleted-list"><li style="list-style-type:circle">Theo thời gian thì project trở nên phức tạp và lớn dần. Các tính năng mới sẽ mất nhiều thời gian hơn để phát triển và tái cấu trúc các tính năng hiện có sẽ nhiều khó khăn hơn.</li></ul><ul id="45a0ed93-2ae9-4f54-9514-37f2b566e440" class="bulleted-list"><li style="list-style-type:circle">Toàn bộ ứng dụng cần được triển khai lại cho bất kỳ thay đổi nào.</li></ul><ul id="7aba9652-b4f7-4796-a1cf-fe753362799d" class="bulleted-list"><li style="list-style-type:circle">Không hề dễ để hiểu project do các module liên quan chặt chẽ lẫn nhau. Một issue nhỏ cũng có thể làm chết toàn bộ ứng dụng.</li></ul><ul id="72afd54f-8f8a-475d-9885-08fce37606ad" class="bulleted-list"><li style="list-style-type:circle">Áp dụng công nghệ mới khó khăn vì toàn bộ ứng dụng phải thay đổi. Do đó nhiều ứng dụng một khối thường phụ thuộc một công nghệ cũ và lỗi thời.</li></ul><ul id="18351fda-262f-4e77-ba8d-96578cb3dc9c" class="bulleted-list"><li style="list-style-type:circle">Các service quan trọng không thể scale riêng dẫn đến lãng phí tài nguyên vì toàn bộ ứng dụng phải scale theo.</li></ul><ul id="95abc362-bedf-4c8e-8c07-7fcff509d7d9" class="bulleted-list"><li style="list-style-type:circle">Các ứng dụng một khối lớn sẽ có thời gian khởi động lâu và tốn tài nguyên CPU cũng như bộ nhớ.</li></ul><ul id="f1cb0355-2560-42d5-ab32-e75576c1c2e3" class="bulleted-list"><li style="list-style-type:circle">Các team tham gia vào dự án phải phụ thuộc lẫn nhau và tất khó để mở rộng quy mô team.</li></ul></li></ul></details></li></ul><ul id="c8602957-947b-4bbf-ae31-42da18f3b215" class="toggle"><li><details open=""><summary><strong>Microservice</strong></summary><ul id="b06a8578-26f1-447e-b3f9-00418e6d7f31" class="bulleted-list"><li style="list-style-type:disc">là kiến trúc chia dự án thành nhiều service nhỏ</li></ul><ul id="3ec9b4b5-1175-4c65-8585-3ec6e59a6d34" class="bulleted-list"><li style="list-style-type:disc">Các service trong kiến trúc microservice là độc lập với nhau, chúng có thể có kiến trúc khác nhau, sử dụng công nghệ khác nhau hoặc thậm chí có database riêng</li></ul><ul id="7a6d4779-6663-4f0c-b71a-ea160d28bd5f" class="bulleted-list"><li style="list-style-type:disc">Chúng trao đổi thông tin với nhau thông qua môi trường mạng (có thể bằng end point Restful API hoặc các message queue)</li></ul><ul id="7e0db1e9-9bbe-4101-886a-ad7dc94132dc" class="bulleted-list"><li style="list-style-type:disc"><strong>Ưu điểm:</strong><ul id="a75ef750-9705-49b1-92cb-ec213f3cd905" class="bulleted-list"><li style="list-style-type:circle">Các component có kết nối lỏng lẻo dẫn đến dễ cách ly, dễ test và khởi động nhanh.</li></ul><ul id="ba9b0e2e-b9ac-4389-a668-2055dfb908e1" class="bulleted-list"><li style="list-style-type:circle">Vòng đời phát triển nhanh hơn. Tính năng mới được phát triển nhanh hơn và tính năng cũ được cấu trúc lại dễ hơn.</li></ul><ul id="e14068b6-e600-4131-a050-9f985e4f32b6" class="bulleted-list"><li style="list-style-type:circle">Các service có thể deploy độc lập nên ứng dụng dễ đọc, dễ tạo các bản vá hơn.</li></ul><ul id="54cf2250-f22c-47e3-9bea-42f7d3371ee1" class="bulleted-list"><li style="list-style-type:circle">Những issue, ví dụ liên quan đến memory leak một trong các service, bị cô lập và có thể không làm sập ứng dụng.</li></ul><ul id="bf80dbfc-0f36-46ce-91b7-d3aea12aa592" class="bulleted-list"><li style="list-style-type:circle">Việc áp dụng các công nghệ mới dễ hơn. Các component có thể được nâng cấp độc lập với nhau.</li></ul><ul id="1c2f84af-f961-42cd-bcd2-86fa91bb695c" class="bulleted-list"><li style="list-style-type:circle">Các mô hình scale phức tạp và hiệu quả hơn có thể được thiết lập. Các service quan trọng có thể scale hiệu quả hơn. Các component riêng sẽ khởi động nhanh hơn và cải thiện thời gian khởi động của cả hệ thống.</li></ul><ul id="b7d99053-8a8c-430d-a2b1-dc00d68ae349" class="bulleted-list"><li style="list-style-type:circle">Các team tham gia sẽ ít phụ thuộc lẫn nhau. Kiến trúc này rất thích hợp cho các đội Agile.</li></ul></li></ul><ul id="a05691ab-a07a-4e17-bac3-570e09e13ccb" class="bulleted-list"><li style="list-style-type:disc"><strong>Nhược điểm:</strong><ul id="4f40ffda-c3f3-48ca-a402-c45a8640e421" class="bulleted-list"><li style="list-style-type:circle">Phức tạp hơn về mặt tổng thể vì các component khác nhau có các stack công nghệ khác nhau nên buộc team phải tập trung đầu tư thời gian để theo kịp công nghệ.</li></ul><ul id="7e579d39-316f-40b4-a684-e14a52b9c50c" class="bulleted-list"><li style="list-style-type:circle">Khó thực hiện test end-to-end và integration test vì có nhiều stack công nghệ khác nhau.</li></ul><ul id="4a919da5-bda6-4ddc-9dcc-716ba4a3a9b7" class="bulleted-list"><li style="list-style-type:circle">Deploy toàn bộ ứng dụng phức tạp hơn vì có nhiều container và nền tảng ảo hóa liên quan.</li></ul><ul id="db2ceddf-325b-4f13-b457-5b2b27ebf305" class="bulleted-list"><li style="list-style-type:circle">Ứng dụng được scale hiệu quả hơn nhưng thiết lập nâng cấp sẽ phức tạp hơn vì nó sẽ yêu cầu nâng cao nhiều tính năng như truy tìm dịch vụ (service discovery), định tuyến DNS,…</li></ul><ul id="7c0fe27f-ec25-4cab-9f05-1c17df223d08" class="bulleted-list"><li style="list-style-type:circle">Yêu cầu một team-size lớn để maintain ứng dụng vì có nhiều component và công nghệ khác nhau.</li></ul><ul id="bcb69304-5eb5-4df5-acb4-7a3a1fa5e44d" class="bulleted-list"><li style="list-style-type:circle">Các thành viên trong team chia sẻ các skill khác nhau dựa trên component họ làm nên sẽ tạo ra sự khó khăn khi thay thế và chia sẻ kiến thức.</li></ul><ul id="78519b44-e522-4c1d-8164-a25084a22eb6" class="bulleted-list"><li style="list-style-type:circle">Stack công nghệ phức tạp và khó để học hơn.</li></ul><ul id="b51830b7-c5f5-4ae9-b99a-41c150031225" class="bulleted-list"><li style="list-style-type:circle">Thời gian phát triển ban đầu là chậm nên thời gian để có thể làm marketing lâu hơn.</li></ul><ul id="c4875cd2-1cd5-40cb-a1d6-f7979209226d" class="bulleted-list"><li style="list-style-type:circle">Yêu cầu cơ sở hạ tầng phức tạp. Thông thường sẽ yêu cầu nhiều container (Docker) và nhiều máy JVM để chạy.</li></ul></li></ul></details></li></ul></details></li></ul><ul id="bbccd805-b373-4fbe-b399-e58c8bd7b493" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Rest ≠ graph</strong></mark></summary><ul id="86a73eac-46f6-4356-97c3-816ce0b9e916" class="bulleted-list"><li style="list-style-type:disc"><a href="https://2kvn.com/graphql-vs-rest-apis-p5f31353330">https://2kvn.com/graphql-vs-rest-apis-p5f31353330</a></li></ul><ul id="318a6cc1-52bb-4fd7-a929-ea80c8cbd861" class="bulleted-list"><li style="list-style-type:disc"><a href="https://viblo.asia/p/so-sanh-graphql-voi-rest-V3m5WLv8KO7">https://viblo.asia/p/so-sanh-graphql-voi-rest-V3m5WLv8KO7</a></li></ul><ul id="2d2400d7-a205-4db3-a4d1-7e7c4c825915" class="bulleted-list"><li style="list-style-type:disc"><a href="https://codelearn.io/sharing/graphql-va-uu-diem-so-voi-rest-api">https://codelearn.io/sharing/graphql-va-uu-diem-so-voi-rest-api</a></li></ul></details></li></ul><ul id="7cf8d7c3-776a-42b3-899c-33fa4937a15e" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>CORS</strong></mark></summary><ul id="bbf476a2-4912-4f71-9cf9-02969e6a6d06" class="bulleted-list"><li style="list-style-type:disc">(Cross-Origin Resource Sharing) là một kĩ thuật được sinh ra để làm cho việc tương tác giữa client và server được dễ dàng hơn, nó cho phép JavaScript ở một trang web có thể tạo request lên một REST API được host ở một domain khác.</li></ul><ul id="3d6a04db-dc91-4826-931c-b4bd544d2923" class="bulleted-list"><li style="list-style-type:disc"><strong>Cơ chế hoạt động:</strong><ul id="a61752e1-c145-4ea2-8f9c-cdde5a398001" class="bulleted-list"><li style="list-style-type:circle">Trong trường hợp đơn giản nhất, phía client (tức là cái web app chạy ở browser đó) sẽ tạo request GET, POST, PUT, HEAD, etc để yêu cầu server làm một việc gì đó. </li></ul><ul id="cec28fd4-0ad3-4e3d-be89-db5fb83b05e1" class="bulleted-list"><li style="list-style-type:circle">Những request này sẽ được đính kèm một header tên là <code>Origin</code> để chỉ định origin của client code (giá trị của header này chính là domain của trang web).</li></ul><ul id="584a884f-2a54-4e70-9791-e26d0e9c0932" class="bulleted-list"><li style="list-style-type:circle">Server sẽ xem xét <code>Origin </code>để biết được nguồn này có phải là nguồn hợp lệ hay không. </li></ul><ul id="49ed72a4-c05b-4e96-91e5-be98a7bc35c8" class="bulleted-list"><li style="list-style-type:circle">Nếu hợp lệ, server sẽ trả về response kèm với header <code>Access-Control-Allow-Origin</code>. </li></ul><ul id="4ab9b10e-c27c-45a7-8caf-6ca374bce31e" class="bulleted-list"><li style="list-style-type:circle">Header này sẽ cho biết xem client có phải là nguồn hợp lệ để browser tiếp tục thực hiện quá trình request.</li></ul><ul id="c9c3af65-d679-4ff5-931c-c2157df5da8f" class="bulleted-list"><li style="list-style-type:circle">Trong trường hợp thông thường, <code>Access-Control-Allow-Origin</code> sẽ có giá trị giống như <code>Origin</code>, một số trường hợp giá trị của <code>Access-Control-Allow-Origin</code> sẽ nhìn giống giống như <a href="https://codeaholicguy.com/2017/10/31/tai-sao-developer-can-biet-regular-expression/">Regex</a> hay chỉ đơn giản là <code>*</code> </li></ul><ul id="e79ad875-1b6e-4fd7-bff0-57e3fd5a5294" class="bulleted-list"><li style="list-style-type:circle">Tuy nhiên thì cách dùng <code>*</code> thường được coi là không an toàn, ngoại trừ trường hợp API của bạn được public hoàn toàn và ai cũng có thể truy cập được.</li></ul><ul id="65695691-9096-4d87-b9c7-630d5d31b796" class="bulleted-list"><li style="list-style-type:circle">Nếu không có header <code>Access-Control-Allow-Origin</code> hoặc giá trị của nó không hợp lệ thì browser sẽ báo lỗi.</li></ul></li></ul><ul id="13044a10-b9bb-48e7-9b7d-a37261991d1b" class="bulleted-list"><li style="list-style-type:disc"><strong>Pre-flight request:</strong><ul id="7a005f4b-83b5-4295-8e0e-6f4ff80898bc" class="bulleted-list"><li style="list-style-type:circle">Khi thực hiện những request ảnh hưởng đến data như: POST, PUT, DELETE, ... thì browser sẽ tự động thực hiện một request gọi là <code>preflight request</code> trước khi thực sự thực hiện request để kiểm tra xem phía server đã thực hiện CORS hay chưa, cũng như để biết được rằng request này có hợp lệ hay không.</li></ul><ul id="3fc8d128-3b30-4a5a-a458-7015a05b116d" class="bulleted-list"><li style="list-style-type:circle">Ngoài ra thì nếu bạn có thêm những custom header vào trong request thì việc gửi một <code>preflight request</code> cũng là cần thiết.</li></ul><ul id="baa8be29-c309-4330-8b21-342d547a0a48" class="bulleted-list"><li style="list-style-type:circle">Preflight request được gửi lên server với dạng là <code>OPTIONS</code> (đây là lý do tại sao khi bạn debug ở client bạn thường thấy có hai request giống nhau nhưng khác request method, một cái là <code>OPTIONS</code> một cái là method thật sự bạn muốn gửi).</li></ul><ul id="bef1d833-d880-454f-841a-c22db0bc1f60" class="bulleted-list"><li style="list-style-type:circle"><span style="border-bottom:0.05em solid"><strong>Ví dụ:</strong></span> bạn muốn gửi request <code>DELETE</code> lên server. <ul id="f51c7a0f-a047-45c3-996f-89ec26b5d3f3" class="bulleted-list"><li style="list-style-type:square">Browser sẽ tự tạo một request <code>OPTIONS</code> sẽ hỏi xem server có cho phép việc gửi request <code>DELETE</code> hay không. </li></ul><ul id="88208df7-ea4c-435d-b9a2-3b955dfe15bd" class="bulleted-list"><li style="list-style-type:square">Nếu server cho phép, nó sẽ gửi về response đính kèm những header như <code>Access-Control-Allow-Origin</code>, <code>Access-Control-Allow-Methods</code>, <code>Access-Control-Max-Age</code>, etc.<ul id="46f05db1-2ddf-48fb-857a-d99248d404dc" class="bulleted-list"><li style="list-style-type:disc">Access-Control-Allow-Methods: mô tả những method nào client có thể gửi đi.</li></ul><ul id="7c461299-c1c5-44c4-a545-933ac4dfabb8" class="bulleted-list"><li style="list-style-type:disc">Access-Control-Max-Age: mô tả thời gian hợp lệ của <code>preflight request</code>, nếu quá hạn, browser sẽ tự tạo một <code>preflight request</code> mới.</li></ul></li></ul><ul id="aeb55db2-f85e-4990-8578-4ca23071ea71" class="bulleted-list"><li style="list-style-type:square">Sau đó browser sẽ có thể gửi request <code>DELETE</code> và nhận response như bình thường. Và ngược lại, browser sẽ báo lỗi</li></ul></li></ul></li></ul></details></li></ul><ul id="3cc598c0-3d88-4955-a1a7-a84458b26840" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Middleware</strong></mark></summary><ul id="039b3b88-f841-4cc1-b205-b0cacc1a8d95" class="bulleted-list"><li style="list-style-type:disc">Middleware đóng vai trò trung gian giữa <strong>request/response </strong>(tương tác với người dùng) và các xử lý logic bên trong web server.</li></ul><ul id="856ca9cb-9aba-45e3-9d50-8ec5c9227381" class="bulleted-list"><li style="list-style-type:disc">Middleware sẽ là các hàm được dùng để tiền xử lý, lọc các request trước khi đưa vào xử lý logic hoặc điều chỉnh các response trước khi gửi về cho người dùng.</li></ul><ul id="86fa79fd-25aa-4a65-8784-890dfd1f8bfd" class="bulleted-list"><li style="list-style-type:disc">Các hàm middleware có thê thực thi ở đầu, giữa, hoặc cuối vòng đời của một request. Trong stack các middleware function luôn được thêm vào theo thứ tự mà chúng ta mong muốn ngay ban đầu.</li></ul><ul id="f2c7114d-9bab-41b4-9a1f-b1b4d16fdae4" class="bulleted-list"><li style="list-style-type:disc">Một số middleware phổ biến trong nodejs như: route, cors, auth, logger, helmet, ... </li></ul></details></li></ul><ul id="e83e6445-04fc-4d49-b3d8-254e0b09ee06" class="toggle"><li><details open=""><summary><strong><mark class="highlight-red">Helmet</mark></strong></summary><ul id="26892d12-fe7b-4c33-9041-d6aa70f84ac1" class="bulleted-list"><li style="list-style-type:disc">Helmet là một package được viết để giúp bạn bảo vệ ứng dụng của mình khỏi những lỗ hổng đã biết bằng cách thiết lập các Http headers một cách phù hợp.</li></ul><ul id="0dc474fa-13ac-4ce7-aa6a-3362f89ddac1" class="bulleted-list"><li style="list-style-type:disc">Thực tế thì Helmet chỉ là một tập hợp các Middleware nhỏ làm nhiệm vụ thiết lập các Http headers liên quan đến bảo mật. </li></ul><ul id="59c48fa1-e63d-4b94-aebf-2c3c0d070a16" class="bulleted-list"><li style="list-style-type:disc">Nó giúp ẩn đi những thông tin không cần thiết trong header và thiết lập lại một số thuộc tính giúp cho server an toàn hơn.</li></ul></details></li></ul><ul id="546a2bc8-bc0a-4db7-b29c-6cc731552135" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Cookies</strong></mark></summary><ul id="f2a8f669-ce73-4578-bdcb-f3b68ffd4bdd" class="bulleted-list"><li style="list-style-type:disc"><strong>Cookie </strong>là những tập tin một trang web gửi đến máy người dùng và được lưu lại thông qua trình duyệt khi người dùng truy cập trang web đó. </li></ul><ul id="ef20771f-4300-416f-8145-ac79f2d9ab04" class="bulleted-list"><li style="list-style-type:disc">Cookie được dùng để lưu trữ với rất nhiều mục đích như lưu phiên đăng nhập, hoạt động của người dùng khi truy cập trang web.</li></ul><ul id="d32397d9-a3ac-4808-8f62-da223c5fa688" class="bulleted-list"><li style="list-style-type:disc"><strong>Cookie</strong> có nhiều loại khác nhau và phân chia theo từng mục đích sử dụng. Một số cookies phổ biến như:<ul id="809328ae-9139-4bfd-bdae-942929cbafc4" class="bulleted-list"><li style="list-style-type:circle"><strong>Session Cookie: </strong>chỉ tồn tại tạm thời trong bộ nhớ của trình duyệt và sẽ bị trình duyệt tự xóa khi người dùng hết phiên đăng nhập, thông thường loại cookie này không có thời hạn.</li></ul><ul id="f29950a2-7f61-4ea5-9c2a-dec0d227c554" class="bulleted-list"><li style="list-style-type:circle"><strong>Third-party cookie : </strong>thông thường cookie của trang web sẽ trùng với thanh địa chỉ của trình duyệt nhưng có một vài trường hợp sử dụng cookie bên thứ 3 có tên miền khác với url trang web</li></ul><ul id="b8913747-7878-4d6d-a8ee-e81a98d06b29" class="bulleted-list"><li style="list-style-type:circle"><strong>Secure cookie: </strong>một loại cookie HTTP có bộ thuộc tính secure giới hạn phạm vi của cookie đối với trình duyệt web.</li></ul></li></ul></details></li></ul><ul id="bfec41de-a35b-4ecf-83de-5f26d16b3bae" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Sessions</strong></mark></summary><ul id="42c37e3d-bc4f-489e-b9b0-d6eb85e04532" class="bulleted-list"><li style="list-style-type:disc">Session dùng để lưu trữ dữ liệu trên Server và đồng thời nó sẽ có một đoạn code dữ liệu được lưu trữ ở client (cookie).</li></ul><ul id="b737606b-20f6-4d2f-8c75-3b8ae15c0a74" class="bulleted-list"><li style="list-style-type:disc">Một số cách lưu trữ sessions ở server:<ul id="1cb1c1d2-cf13-4481-ab2b-e72dc8b86408" class="bulleted-list"><li style="list-style-type:circle"><strong>Cookie</strong>: Chúng ta có thể store sesion trên cookie session nodejs mỗi trình duyệt nhưng chú ý rằng tất cả đều nằm ở Clients. </li></ul><ul id="55d519e5-c52c-45c9-bcbf-5c292bceefdd" class="bulleted-list"><li style="list-style-type:circle"><strong>Memory Cache</strong>: Như chúng ta đã biết, Cache được lưu trữ trong bộ nhớ. Chúng ta cũng có thể sử dụng thêm những cache module như Redis và Memcached. </li></ul><ul id="c3140fe9-0d5f-4aab-8988-64155bcc836f" class="bulleted-list"><li style="list-style-type:circle"><strong>Database</strong>: (ít được sử dụng)</li></ul></li></ul></details></li></ul><ul id="263e3b7e-4355-4665-bd2e-4a27148c25d2" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>WebSocket</strong></mark></summary><ul id="2715bcdd-d011-4c62-a16f-6513cfd81147" class="bulleted-list"><li style="list-style-type:disc"><strong>WebSocket</strong> là công nghệ hỗ trợ giao tiếp hai chiều giữa client và server bằng cách sử dụng một TCP socket để tạo một kết nối hiệu quả và ít tốn kém. </li></ul><ul id="efcf8673-86f4-40e7-86cf-ab9971809433" class="bulleted-list"><li style="list-style-type:disc">Mặc dù được thiết kế để chuyên sử dụng cho các ứng dụng web, lập trình viên vẫn có thể đưa chúng vào bất kì loại ứng dụng nào</li></ul></details></li></ul><ul id="dc76e799-3e34-490c-8f78-80d358582ee1" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Cache</strong></mark></summary><ul id="c7c83261-68eb-4a42-8785-11a9d968c4e7" class="bulleted-list"><li style="list-style-type:disc">Khi cache client cần truy cập data, việc đầu tiên là check cache. Khi request data tìm thấy dữ liệu cần thiết trong Cache, nó được gọi là <em><strong>Cache hit</strong></em>. Tỉ lệ của kết quả tìm kiếm <strong>cache hit</strong> được biết đến như là <em>cache hit rate</em> hay <em>ratio</em>.</li></ul><ul id="2897140a-92f6-4a5a-8f18-e2287df6aec3" class="bulleted-list"><li style="list-style-type:disc">Nếu việc tìm kiếm data không thành công, nó gọi là <em><strong>Cache miss </strong></em>- từ đây dữ liệu sẽ được kéo từ bộ nhớ chính sang bộ nhớ cache. Việc giữ dữ liệu nào cần, hay xoá khỏi bộ nhớ điệm để nhường chỗ cho dữ liệu mới sẽ tùy thuộc vào thuật toán mà system sử dụng.</li></ul><ul id="f3756dc0-5cfb-48f2-9d5c-a265d794aa36" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red"><strong>Cache Replacement Policy</strong></mark> nghĩa nôm na là các thuật toán để thay thế giá trị hoặc xóa các giá trị cũ để thêm giá trị mới vào.<ul id="5eecdfb5-7151-42db-b819-329798305613" class="bulleted-list"><li style="list-style-type:circle">LRU, LFU, MRU, FIFO, LIFO, ...</li></ul></li></ul><hr id="385bee33-aeea-4846-b16c-174b49ddec02"/><ul id="9b8b6961-87e2-4c0b-8c2a-73a7199adb5b" class="bulleted-list"><li style="list-style-type:disc"><strong>Memoization</strong> là một kỹ thuật tối ưu hóa, giúp tăng tốc các ứng dụng bằng cách lưu trữ kết quả của các lệnh gọi hàm (mà các hàm này được gọi là <code>expensive function</code>) và trả về kết quả được lưu trong bộ nhớ cache khi có cùng một đầu vào yêu cầu (đã được thực thi ít nhất 1 lần trước đó rồi).</li></ul><ul id="9eb74a69-3a4e-4078-b5b8-00ee5b80fd75" class="bulleted-list"><li style="list-style-type:disc">Một số thuật toán điều khiển cache:<ul id="5dae2dc9-146a-4757-a1d2-6ff23beb0419" class="bulleted-list"><li style="list-style-type:circle"><strong>Least Frequently Used (LFU)</strong> : theo dõi tần suất truy cập một dữ liệu. Các dữ liệu có số lần truy cập thấp nhất được loại bỏ đầu tiên.</li></ul><ul id="3aa62ede-937f-49cc-9aa0-bc46611a17fd" class="bulleted-list"><li style="list-style-type:circle"><strong>Least Recently Used (LRU)</strong> : lưu trữ các dữ liệu được truy cập gần đây gần đầu bộ đệm. Khi bộ đệm đạt đến giới hạn của nó, các liệu được truy cập gần đây nhất sẽ bị xóa.</li></ul><ul id="f8a48296-2aaf-45ae-83f5-d689fbff7e09" class="bulleted-list"><li style="list-style-type:circle"><strong>Most Recently Used (MRU)</strong> : loại bỏ các dữ liệu truy cập gần đây nhất đầu tiên. Cách tiếp cận này là tốt nhất khi các data cũ có nhiều khả năng được sử dụng.</li></ul></li></ul><ul id="72da5fe0-a587-4122-b060-4e40d6a4cf26" class="bulleted-list"><li style="list-style-type:disc">Các loại cache hay sử dụng:<ul id="a13868a6-b2c4-4d1f-8458-d46ce8897908" class="bulleted-list"><li style="list-style-type:circle"><strong>cache server</strong> : Một dedicated network server hoặc dịch vụ chuyên dụng hoạt động như một máy chủ lưu các trang web hoặc nội dung internet khác cục bộ. Một cache server đôi khi được gọi là proxy cache.</li></ul><ul id="778137b9-58a8-49d2-9b0d-688280212156" class="bulleted-list"><li style="list-style-type:circle"><strong>Cache memory</strong>: Random access memory, hay còn được gọi là <strong>RAM</strong>, Cache memory thường được gắn trực tiếp vào CPU và được sử dụng để cập nhanh các dữ liệu trong CPU.</li></ul><ul id="c0bbe950-76e4-49fc-b618-26e5f72d44a5" class="bulleted-list"><li style="list-style-type:circle"><strong>Flash cache</strong>: Temporary storage of data on NAND flash memory chips -- thường được sử dụng ở **solid-state drives (SSDs) ** , thực hiện các request dữ liệu nhanh hơn có thể nếu bộ đệm nằm trên ổ đĩa cứng truyền thống (HDD)</li></ul><p id="3d4ecac2-f63d-4b2f-8efd-e67dad57c168" class=""><a href="https://pymi.vn/blog/memoization/">https://pymi.vn/blog/memoization/</a></p></li></ul></details></li></ul><ul id="57e72fd9-590a-4577-9e28-1e096641fd57" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Stream, Buffer, Pipe</strong></mark></summary><ul id="66947fd3-6818-4eb0-99bd-bd2450baf782" class="bulleted-list"><li style="list-style-type:disc"><strong>Stream</strong>: là các đối tượng cho phép bạn đọc dữ liệu từ một nguồn và ghi dự liệu đến một đích (<em>là một chuỗi dữ liệu sẵn có qua thời gian, hay có thể hình dung stream là một đối tượng chứa dữ liệu sẽ được truyền đi từ nơi này đến nơi khác.</em>)<ul id="e33bb7c6-e885-4b98-b89d-22e15d4e15ae" class="bulleted-list"><li style="list-style-type:circle">Có 4 loại Stream trong Nodejs:<ul id="5adfdb06-9327-4a96-9294-2f4b9b221121" class="bulleted-list"><li style="list-style-type:square"><strong>Readable</strong>: Là Stream được sử dụng để cho hoạt động đọc</li></ul><ul id="3c58dd63-ede5-4813-9665-b315f829369a" class="bulleted-list"><li style="list-style-type:square"><strong>Writable</strong>: Là Stream được sử dụng cho hoạt động ghi</li></ul><ul id="e7b78c32-50b3-4c62-88fc-65dea3767ac4" class="bulleted-list"><li style="list-style-type:square"><strong>Duplex</strong>: Là Stream được sử dụng cho cả mục đích ghi và đọc</li></ul><ul id="4a28977d-6b4d-4a32-9b6f-bd4f68ee6d3d" class="bulleted-list"><li style="list-style-type:square"><strong>Transform</strong>: Đây là một kiểu Duplex Stream, khác ở chỗ là kết quả đầu ra được tính toán dựa trên dữ liệu bạn đã nhập vào.</li></ul></li></ul><ul id="bd3e391b-965e-458b-b138-142d75025275" class="bulleted-list"><li style="list-style-type:circle">Mỗi loại Stream là một sự thể hiện của đối tượng <a href="https://viettuts.vn/nodejs/lop-event-emitter-trong-nodejs"><strong>EventEmitter</strong></a><strong> </strong>và ném một vài sự kiện tại các thời điểm khác nhau</li></ul><ul id="51341bf7-b861-4e6c-99ef-7284330ce460" class="bulleted-list"><li style="list-style-type:circle"><strong><strong>Piping Stream: </strong></strong>là một kỹ thuật. Với kỹ thuật này, chúng ta cung cấp kết quả đầu ra của một Stream để làm dữ liệu đầu vào cho một Stream khác. Không có giới hạn nào về hoạt động Piping này, tức là quá trình trên có thể vẫn tiếp tục.</li></ul><ul id="2725623a-cefc-4757-a570-8a75d94d6244" class="bulleted-list"><li style="list-style-type:circle"><strong><strong>Chaining Stream: </strong></strong>là một kỹ thuật để kết nối kết quả đầu ra của một Stream tới một Stream khác và tạo một chuỗi bao gồm nhiều hoạt động Stream. Thường thì nó được sử dụng với các hoạt động Piping</li></ul></li></ul><ul id="29e0d9e3-8e06-4763-83bc-9ace73ade038" class="bulleted-list"><li style="list-style-type:disc"><strong>Buffer</strong>: là một vùng dự trữ tạm thời chứa các dữ liệu đang được chuyển từ nơi này đến nơi khác. <ul id="01b47272-54e5-4cec-b2cd-297bb4daceff" class="bulleted-list"><li style="list-style-type:circle">Buffer có kích thước xác định và giới hạn. </li></ul><ul id="54ccc427-ac5f-470c-9d81-1ca0427e1a2d" class="bulleted-list"><li style="list-style-type:circle">Kích thước của buffer được xác định bằng những thuật toán cho từng trường hợp cụ thể. </li></ul><ul id="e43ba22a-a01e-4c15-ae9c-3d5ac59f869b" class="bulleted-list"><li style="list-style-type:circle">Buffer là một kỹ thuật được phát triển nhằm ngăn chặn sự tắc nghẽn dữ liệu khi truyền từ nơi này đến nơi khác.</li></ul><ul id="065a7b3b-c7ad-4690-95cf-2919b18b4d3e" class="bulleted-list"><li style="list-style-type:circle">Ví dụ: <ul id="b7431820-1480-4433-9335-b2c5050a63c3" class="bulleted-list"><li style="list-style-type:square">Trong thực tế, khi chúng ta xem một đoạn phim trên mạng. </li></ul><ul id="5981830f-6915-4fa3-9465-9328823751cb" class="bulleted-list"><li style="list-style-type:square">Nếu đường truyền mạng chúng ta đủ nhanh thì tốc độ stream video sẽ kịp thời làm đầy các buffer (vùng nhớ tạm thời trên RAM) và đoạn dữ liệu này sẽ được gửi đến trình media player để chạy đoạn dữ liệu vừa được làm đầy trong buffer. </li></ul><ul id="0f343548-6b25-4c46-8b03-a1c856e8e4cf" class="bulleted-list"><li style="list-style-type:square">Trong lúc phát nội dung đó, buffer sẽ trống và lại được làm đầy. </li></ul><ul id="5005a1c3-5c7d-4825-83b2-1f76f1afab21" class="bulleted-list"><li style="list-style-type:square">Cứ như vậy cho đến khi kết thúc stream.</li></ul></li></ul></li></ul><p id="6d6880a1-779a-4698-8f09-ae01ebea8e1f" class="">
</p></details></li></ul><ul id="ed14d023-13f3-4175-84c0-b477483e2584" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Queue</strong></mark></summary><ul id="cf68315d-0ae3-43a1-862f-c71d8fd08d78" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>Khái niệm</strong></span>:<ul id="b54232c6-ea51-4dcc-89a3-c434605c89ca" class="bulleted-list"><li style="list-style-type:circle">Message Queue nôm na là Queue (hàng đợi), chứa Message (Tin nhắn) như hộp thư. </li></ul><ul id="a1c66e37-9aaf-48a3-a5a3-c24606ccf5c2" class="bulleted-list"><li style="list-style-type:circle">Và nó cho phép các thành phần/service trong một hệ thống (hoặc nhiều hệ thống), trao đổi thông tin cho nhau. </li></ul><ul id="79490a5a-aca8-4aa4-8929-86dfe03f3eaa" class="bulleted-list"><li style="list-style-type:circle">Ý nghĩa của queue (hàng đợi) là nó thực hiện việc lấy message theo cơ chế vào trước thì ra trước ( First In First Out ). </li></ul></li></ul><ul id="ce06ce98-f6bb-4a75-a752-f9dbffd7df2d" class="bulleted-list"><li style="list-style-type:disc"><strong>Thành phần của 1 MQ: </strong><ul id="a24b123d-a75f-47d9-ad7b-1ee9dbd799d8" class="bulleted-list"><li style="list-style-type:circle"><strong>Message</strong>: Thông tin được gửi đi (có thể là text, binary hoặc JSON)</li></ul><ul id="bcc73970-4496-4777-945b-8480f2006339" class="bulleted-list"><li style="list-style-type:circle"><strong>Message Queue</strong>: Nơi chứa những message này, cho phép producer và consumer có thể trao đổi với nhau</li></ul><ul id="1f041047-949e-4fa4-83d0-d462b930a182" class="bulleted-list"><li style="list-style-type:circle"><strong>Producer</strong>: Chương trình/service tạo ra thông tin, đưa thông tin vào message queue</li></ul><ul id="6c0c5f48-fe70-4f1b-b642-94ce06c93e2a" class="bulleted-list"><li style="list-style-type:circle"><strong>Consumer</strong>: Chương trình/service nhận message từ message queue và xử lý</li></ul><ul id="68067ba0-c29d-4b37-bd90-31d8d4dcbcf3" class="bulleted-list"><li style="list-style-type:circle">Một chương trình/service có thể <strong>vừa là producer, vừa là consumer</strong></li></ul></li></ul><ul id="fd6c9a7a-8fa5-46b2-866e-1df3a2cdf3ca" class="bulleted-list"><li style="list-style-type:disc"><strong>MQ giải quyết được các vấn đề:</strong><ul id="ccb20f85-c0d2-4e44-b6f5-7cf06feba776" class="bulleted-list"><li style="list-style-type:circle"><strong>Đảm bảo duration/recovery</strong>: Do message đã được lưu trong queue, khi 1 service đang xử lý nhưng bị crash hoặc lỗi, ta không lo bị mất dữ liệu. <ul id="936b0c15-15c5-4a35-aff7-7415b38fc40e" class="bulleted-list"><li style="list-style-type:square">Vì có thể lấy message từ trong queue ra và chạy lại. </li></ul><ul id="d49991d9-57a8-4099-9440-9fbc9ccef59e" class="bulleted-list"><li style="list-style-type:square">Trong 1 hệ thống có nhiều consumer, nếu 1, 2 consume bị crash cũng không làm sụp toàn hệ thống</li></ul></li></ul><ul id="173f2851-a3b3-4017-90fb-98d66da1edf2" class="bulleted-list"><li style="list-style-type:circle"><strong>Phân tách hệ thống</strong>: Giúp phân tách hệ thống thành nhiều service nhỏ hơn, mỗi service chỉ xử lý 1 chức năng nhất định</li></ul><ul id="0bc192a9-9702-4adc-b3fb-f645ca87c395" class="bulleted-list"><li style="list-style-type:circle"><strong>Hỗ trợ rate limit, batching</strong>: Trong nhiều trường hợp, năng lực xử lý hệ thống có hạn (chỉ có thể xử lý 300 đơn hàng/s). <ul id="5121fc5e-f63a-4cd2-bcf3-53e294e00f00" class="bulleted-list"><li style="list-style-type:square">Với message queue, ta có thể dần dần lấy đơn hàng trong queue ra xử lý, không sợ thất lại. </li></ul><ul id="2263d92b-43cc-4e7a-8038-bf86252e06bd" class="bulleted-list"><li style="list-style-type:square">Hoặc thay vì mỗi lần gửi email mất thời gian lâu, ta có thể đợi message queue có yêu cầu gửi 200 email rồi gửi luôn 1 lượt.</li></ul></li></ul><ul id="2594dcd2-a277-4535-9132-f1202469d8b4" class="bulleted-list"><li style="list-style-type:circle"><strong>Dễ scaling hệ thống</strong>: Vào giờ cao điểm, nhiều truy vấn, ta có thể tăng số lượng consumer lên để xử lý được nhiều messege hơn. Khi không cần ta có thể giảm lại.</li></ul></li></ul><ul id="d3f2f9c1-8d30-4cd6-93fd-342bdd2e6f4f" class="bulleted-list"><li style="list-style-type:disc"><strong>Một số MQ phổ biến:</strong><ul id="82113ea7-a6ee-4ad8-82c2-d66e3a48f52e" class="bulleted-list"><li style="list-style-type:circle"><strong>Kafka  </strong></li></ul><ul id="20dd115d-cb72-4a97-9707-d6951680be23" class="bulleted-list"><li style="list-style-type:circle"><strong>RabittMQ </strong></li></ul><ul id="231178e2-b372-4a9b-8003-e66205e5a988" class="bulleted-list"><li style="list-style-type:circle"><strong>Bull</strong></li></ul><ul id="f1944e55-7c42-4c20-9002-e6d552cc21f3" class="bulleted-list"><li style="list-style-type:circle">...</li></ul></li></ul></details></li></ul><ul id="5a86cc25-1241-4d29-89d8-6dd90b7be968" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Single sign on</strong></mark></summary><ul id="c1860f3c-4ec8-46a3-a9e9-f83521361d5e" class="bulleted-list"><li style="list-style-type:disc"> <strong>SSO</strong> là viết tắt của Single Sign On, có nghĩa là bạn có thể đăng nhập vào một hệ thống trong một nhóm ứng dụng đa hệ thống (google, youtube, console...) và bạn có thể nhận ủy quyền trong tất cả các hệ thống khác mà không cần đăng nhập lại.</li></ul><ul id="d29d71ac-0260-4e5f-ac72-aba9b9bcaf94" class="bulleted-list"><li style="list-style-type:disc"><em>SSO là cơ chế cho phép người dùng có thể truy cập nhiều trang web, ứng dụng mà chỉ cần đăng nhập một lần. Một khi đã được định danh ở một trang website A, thì cũng sẽ được định danh tương tự ở website B mà không cần lặp lại thao tác đăng nhập</em></li></ul><ul id="7ff416d4-793f-469b-8a77-24495a7467ed" class="bulleted-list"><li style="list-style-type:disc">Ưu điểm:<ul id="4919835e-2adb-4175-8e9d-d1c86403ceba" class="bulleted-list"><li style="list-style-type:circle">Giảm số lượng username và pasword mà người dùng cần phải ghi nhớ</li></ul><ul id="a03afbc7-b11d-4437-95ee-b4f5f311ca59" class="bulleted-list"><li style="list-style-type:circle">Giảm số lần phải nhập thông tin username và pasword</li></ul><ul id="b73e3bd8-1bc5-498a-ba0f-497b9bc989e1" class="bulleted-list"><li style="list-style-type:circle">Rủi ro về việc lộ thông tin người dùng cũng được tiết chế lại</li></ul></li></ul><ul id="9e02c16d-a43c-443d-b1fa-d813dd873d5d" class="bulleted-list"><li style="list-style-type:disc">Nhược điểm:<ul id="26fc3e0e-17ad-4e41-a3b4-7a6a23f58bc6" class="bulleted-list"><li style="list-style-type:circle">Chi phí phát triển khi thông qua service thứ ba</li></ul><ul id="6f67e564-244d-4ba9-b9ad-bc456ede56d2" class="bulleted-list"><li style="list-style-type:circle">Phụ thuộc vào service bên ngoài</li></ul></li></ul><ul id="c3a6a260-242e-40f5-ad45-524532f845fc" class="bulleted-list"><li style="list-style-type:disc">SSO là một phần của hệ thống nhận dạng liên kết (<strong>Federated Identity Glossary</strong>), có liên quan chặt chẽ với việc xác thực thông tin người dùng. Nó sẽ định danh người dùng, và sau đó chia sẻ thông tin định danh được với các hệ thống con.<ul id="5a7eaee5-a522-4dfa-8ca3-7fae269384b9" class="bulleted-list"><li style="list-style-type:circle">Hệ thông nhận dang liên kết là nơi tập trung và liên kết thông tin người dùng. Có 4 yếu tố nền tảng cấu thành:<ul id="9bacb69b-f565-46e0-bbd1-a2f5f3eb5ae8" class="bulleted-list"><li style="list-style-type:square">Xác thực (Authentication)</li></ul><ul id="441de834-c9a3-4bcf-a90b-58ab99c03fee" class="bulleted-list"><li style="list-style-type:square">Phân quyền (Authorization)</li></ul><ul id="1c7df855-51dc-4a2c-86bb-f205015f17e8" class="bulleted-list"><li style="list-style-type:square">Trao đổi thông tin người dùng (User attributes exchange)</li></ul><ul id="86395959-3183-4865-80a9-5086ab2b94c6" class="bulleted-list"><li style="list-style-type:square">Quản lí người dùng (User management)</li></ul></li></ul></li></ul><ul id="3a289cd8-70f5-417e-81e2-db3ed571a134" class="bulleted-list"><li style="list-style-type:disc"><strong>Cơ chế:</strong><ul id="3e5b8ceb-67ff-4b83-b8fa-b5fd304b432c" class="bulleted-list"><li style="list-style-type:circle"><a href="https://www.google.com/search?q=single+sign+on+la+gi&amp;oq=single&amp;aqs=chrome.0.69i59j69i57j69i60l3.1218j0j1&amp;sourceid=chrome&amp;ie=UTF-8">https://www.google.com/search?q=single+sign+on+la+gi&amp;oq=single&amp;aqs=chrome.0.69i59j69i57j69i60l3.1218j0j1&amp;sourceid=chrome&amp;ie=UTF-8</a></li></ul></li></ul></details></li></ul><ul id="f36032a5-71d0-4d3f-bf0d-5cf40d612249" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>JWT, auth</strong></mark></summary><ul id="c516bc4a-716f-4242-846a-563bbd977e2a" class="bulleted-list"><li style="list-style-type:disc"><a href="https://www.notion.so/Authentication-Authorization-d8562babcd034a4abe8ff30a8945a000">link</a></li></ul></details></li></ul><ul id="683dfb97-225d-44d4-88b7-b1abe834e2c7" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Single thread, multiple thread</strong></mark></summary><ul id="c1579792-3aad-4dab-aa69-ee079b647874" class="bulleted-list"><li style="list-style-type:disc"><a href="https://viblo.asia/p/javascript-single-thread-lieu-da-loi-thoi-gAm5yxwkldb">https://viblo.asia/p/javascript-single-thread-lieu-da-loi-thoi-gAm5yxwkldb</a></li></ul><ul id="c1745936-1d18-455d-b138-b234d24b1594" class="bulleted-list"><li style="list-style-type:disc"><strong>Lấy một ví dụ để minh họa JS chạy trên môi trường trình duyệt web chrome là single thread?</strong><pre id="b8e81e46-7bae-4197-aa88-42460d4c9bb4" class="code code-wrap"><code>let loop = true;

setTimeout(() =&gt; {  // callback execution is unreachable because main thread is still busy with below infinite loop code.
    console.log(&#x27;It will never reach here :ohh&#x27;);
    loop = false;
});

while (loop) {
    console.log(&#x27;loop&#x27;, loop);  // Infinite loop
}

console.log(&#x27;after loop&#x27;);  // Unreachable code</code></pre></li></ul><ul id="33679513-94c6-4ec6-871c-4b31dca07ce0" class="bulleted-list"><li style="list-style-type:disc"><em>Single thread theo hướng event-driven nó vậy đó fence, các hoạt động i/o như gọi API thì js nó không tự tạo thread để xử lý mà bắn cho thằng khác(trình duyệt) lo còn bản thân js nó ngồi chơi xơi nước đợi kết quả không à. Ngược lại nếu gọi 1 hàm đệ quy tính toán nặng trong main thread(js tự thân vận động) thì web nó treo đến khi hàm đó chạy xong thì thôi. Đấy mới chính là cái khẳng định js trên browser đơn thuần là single thread. Còn việc có thể tạo lập các service worker thì nó là runtime của browser, browser có hỗ trợ thì dùng, không thì thôi nên không thể nói nó là của js đc.</em></li></ul><ul id="e1759f22-6b90-4cee-aeab-67d2397f0c3d" class="bulleted-list"><li style="list-style-type:disc"></li></ul><ul id="d899e363-1835-49bc-a1fa-684c8b24df8f" class="bulleted-list"><li style="list-style-type:disc"></li></ul></details></li></ul><ul id="ed04e0cc-abc7-47ee-900f-7ec35150a24b" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>pub &amp; sub system</strong></mark></summary><ul id="226ba22f-ba08-48ac-8bef-61042e63fe48" class="bulleted-list"><li style="list-style-type:disc"><strong>Publish/subscribe messaging </strong>là một pattern mà đặc trưng bởi việc gửi (publisher) data (message) mà ko chỉ định người nhận rõ ràng . </li></ul><ul id="30d07996-1bde-4d3e-9701-3ed582ccb737" class="bulleted-list"><li style="list-style-type:disc">Thay vào đó người gửi sẽ phân loại tin nhắn thành các lớp và bằng cách nào đó mà người nhận (subscriber) phải đăng kí vào lớp nhất định để nhận tin nhắn ở lớp đấy. </li></ul><ul id="3510030d-e69c-4487-9c6f-4511a3a1456d" class="bulleted-list"><li style="list-style-type:disc">Hệ thống pub/sub thường có một broker (nhà phân phối) , là trung tâm nơi mà các message được phân phối.</li></ul></details></li></ul><ul id="2d090136-5694-470c-944b-5410432b250a" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>ACL, RBAC </strong></mark></summary><ul id="344e335a-d269-45c5-accf-45ed8d1edb2a" class="toggle"><li><details open=""><summary><strong>ACL</strong>: là hình thức phân quyền dựa trên một danh sách các quyền truy cập.</summary><ul id="135a60d2-ffe1-4a34-a3e1-3b0ae5523a18" class="bulleted-list"><li style="list-style-type:disc"><code>Subject</code> có thể <code>Action</code> tới <code>Object</code></li></ul><ul id="28ffbc72-932d-476b-99b3-84499df7ef46" class="bulleted-list"><li style="list-style-type:disc">Dựa vào người dùng và nhóm người dùng</li></ul><ul id="19aa9193-51cb-4595-a3da-a9342a6c9805" class="bulleted-list"><li style="list-style-type:disc"><strong>Ví dụ</strong>:<ul id="645f3750-acf6-419c-863b-412b69930416" class="bulleted-list"><li style="list-style-type:circle">Cho phép Nguyễn Văn A tạo bài viết</li></ul><pre id="8e8a17b1-0ddd-4039-8239-c5d8c507e960" class="code"><code>&#x27;Subject&#x27; : &#x27;Nguyễn Văn A&#x27;
&#x27;Action&#x27; : &#x27;Tạo&#x27;
&#x27;Đối tượng&#x27; : &#x27;Bài viết&#x27;</code></pre><ul id="cddf3081-ec41-4463-b3dd-dd6e13481510" class="bulleted-list"><li style="list-style-type:circle">Nguyễn Văn A có thể tạo bài viết..</li></ul><ul id="861eefcf-5ff0-4f61-8067-37d5faef1303" class="bulleted-list"><li style="list-style-type:circle">Ví dụ : Phân quyền trong <code>MySql</code>.</li></ul></li></ul></details></li></ul><ul id="8b7baf4a-1f9e-449f-a43a-fdd05bd30a8e" class="toggle"><li><details open=""><summary><strong>RBAC</strong>: là hình thức phân quyền dựa vào vai, mỗi Subject sẽ thuộc một hoặc nhiều Role. Mỗi Role lại có một hoặc nhiều Permission thực thi Action tới Object.</summary><ul id="a3c9784f-d829-4c31-bc2a-d840f4730c1f" class="bulleted-list"><li style="list-style-type:disc">Một <code>Subject</code> thuộc một hoặc nhiều <code>Role</code></li></ul><ul id="f9b93208-103e-4c62-9d17-667c59f06bf3" class="bulleted-list"><li style="list-style-type:disc">Một <code>Role</code> có một hoặc nhiều <code>Permission</code>.</li></ul><ul id="65299b02-fd9b-4077-8182-164886789818" class="bulleted-list"><li style="list-style-type:disc"><strong>Ví dụ</strong>:<ul id="d42b61d6-7197-4bb5-90c1-c181772f9a3e" class="bulleted-list"><li style="list-style-type:circle">Người dùng Nguyễn Văn A có quyền Admin, User.</li></ul><ul id="ac8df7ce-d105-449d-a640-01fe595e1828" class="bulleted-list"><li style="list-style-type:circle">Người dùng Lê Văn B có quyền User.</li></ul><ul id="3f0e5504-aab3-471a-bb87-7e6b5b641941" class="bulleted-list"><li style="list-style-type:circle">User có quyền <code>Đọc</code> bài viết.</li></ul><ul id="d87043a9-23a0-4f04-83f1-2fd4c177f278" class="bulleted-list"><li style="list-style-type:circle">Admin có quyền <code>Đọc</code>, <code>Thêm</code>. <code>Sửa</code>, <code>Xóa</code> bài viết.</li></ul><p id="f83ce8fb-f7e8-4420-91ab-c3c3db679697" class="">⇒  </p><ul id="e9f9e152-38af-48a4-bd89-a62a98bd3309" class="bulleted-list"><li style="list-style-type:circle">Người dùng A có quyền <code>Đọc</code>, <code>Thêm</code>. <code>Sửa</code>, <code>Xóa</code> bài viết.</li></ul><ul id="f2ceae6b-d980-4d4f-8d32-1c86ad35f631" class="bulleted-list"><li style="list-style-type:circle">Người dùng Lê Văn B có quyền <code>Đọc</code> bài viết.</li></ul></li></ul><p id="1a96da02-0742-4a62-b18b-d309922c6f4e" class=""><a href="https://www.phamduytung.com/blog/2021-07-02-mo-hinh-phan-quyen/">https://www.phamduytung.com/blog/2021-07-02-mo-hinh-phan-quyen/</a></p><p id="078289ff-b3ae-4c7b-893e-d68bd18aceea" class=""><a href="https://kipalog.com/posts/Bai-toan-phan-quyen-van-de-muon-thuo-va-rat-kho-hieu">https://kipalog.com/posts/Bai-toan-phan-quyen-van-de-muon-thuo-va-rat-kho-hieu</a></p></details></li></ul></details></li></ul><ul id="d239a727-3ec0-4208-8479-130b9c3de2e6" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Một số cách secure trong nodejs</strong></mark></summary><ul id="c0020f82-fd7f-49a5-aaf4-8e7e87ed3472" class="bulleted-list"><li style="list-style-type:disc">Validate user input to limit SQL injections and XSS attacks</li></ul><ul id="1c3ad8bc-d13f-4c2c-a634-cdf89fb8f258" class="bulleted-list"><li style="list-style-type:disc">Implement strong authentication</li></ul><ul id="57e7e491-18fb-4cda-b691-315a42d6709f" class="bulleted-list"><li style="list-style-type:disc">Avoid errors that reveal too much</li></ul><ul id="d3e1f583-f802-4a73-97eb-7c164b76c225" class="bulleted-list"><li style="list-style-type:disc">Run automatic vulnerability scanning</li></ul><ul id="b36a1f59-99f2-4049-bbf7-2f447ae8f169" class="bulleted-list"><li style="list-style-type:disc">Avoid data leaks</li></ul><ul id="8c71d9cb-8229-40a7-b691-54cded63ef07" class="bulleted-list"><li style="list-style-type:disc">Set up logging and monitoring</li></ul><ul id="0c5e81f0-4507-4da3-98a9-a1dbbbc3c1cc" class="bulleted-list"><li style="list-style-type:disc">Use security linters (eslint)</li></ul><ul id="cd89f158-ba31-4a2c-8b4f-913aeebc654b" class="bulleted-list"><li style="list-style-type:disc">Avoid secrets in config files</li></ul><ul id="c7cb9f4f-a98b-444b-9514-5238069759be" class="bulleted-list"><li style="list-style-type:disc">Implement HTTP response headers</li></ul><ul id="1705a904-f069-47f4-aecd-6dbd53ae62d2" class="bulleted-list"><li style="list-style-type:disc">Don’t run Node.js as root</li></ul><ul id="4e07760c-6c1a-4feb-923a-c8d2a4588630" class="bulleted-list"><li style="list-style-type:disc">Protect and observe your Node.js apps in production</li></ul><p id="303213a9-ca81-4834-b654-913643dc7c5f" class=""><a href="https://blog.sqreen.com/nodejs-security-best-practices/">https://blog.sqreen.com/nodejs-security-best-practices/</a></p><hr id="08e998e6-6f15-4d25-9221-de330a5e2e41"/><ul id="0632f023-c448-49a5-a095-1d78a0650cf4" class="bulleted-list"><li style="list-style-type:disc">Chống DOS, DDOS hay brute-force mật khẩu</li></ul><ul id="f0a03ac1-6565-4fcb-9d94-de376fbc724f" class="bulleted-list"><li style="list-style-type:disc">Lọc dữ liệu người dùng gửi lên server</li></ul><ul id="b97a25af-fda4-40cf-85bf-0a1940032c21" class="bulleted-list"><li style="list-style-type:disc">Sử dụng helmet</li></ul><ul id="42559940-d3ad-461d-bc75-3668b0498965" class="bulleted-list"><li style="list-style-type:disc">Sử dụng <code>express-validator</code> để data gửi lên server</li></ul><ul id="01b9d46a-e0b2-4a5b-8f2c-464a087ee45c" class="bulleted-list"><li style="list-style-type:disc">Sử dụng thư viện ORD/ODM để chống SQL/NoSQL Injection</li></ul><ul id="5313f53e-e7c0-4ad8-a160-415e4103758e" class="bulleted-list"><li style="list-style-type:disc">Sử dụng https</li></ul><ul id="ef16678f-3de8-47bc-8e93-c46ed959ea17" class="bulleted-list"><li style="list-style-type:disc">Sử dụng biến môi trường</li></ul><ul id="ac6ea793-17c8-46ea-ac4d-d52ab52c0dd6" class="bulleted-list"><li style="list-style-type:disc">Dùng <strong>bcrypt</strong> hoặc <strong>pbkdf2</strong> để băm mật khẩu</li></ul><ul id="ed045b01-a3c8-4074-b9e9-58ad610aa517" class="bulleted-list"><li style="list-style-type:disc">Giới hạn kích thước payload request gửi lên server</li></ul><p id="bd72db03-f86c-4dfa-b295-7d8605e3f030" class=""><a href="https://hocweb.vn/toi-uu-bao-mat-app-nodejs-tot-hon">https://hocweb.vn/toi-uu-bao-mat-app-nodejs-tot-hon</a></p></details></li></ul><ul id="886ed51b-af76-4859-9e5b-ee287c18860a" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>CronJob</strong></mark></summary><ul id="df7200b7-af67-440d-97ee-636c726423ca" class="bulleted-list"><li style="list-style-type:disc">Cron là chương trình để xử lý các tác vụ lặp đi lặp lại ở lần sau. </li></ul><ul id="803b828e-22fd-4117-a7d5-07f7145e0b69" class="bulleted-list"><li style="list-style-type:disc">Cron Job đưa ra một lệnh để lên lịch “làm việc” cho một hành động cụ thể, tại một thời điểm cụ thể mà cần lặp đi lặp lại.<ul id="7f511706-dbc2-4f13-87a2-b299a1381970" class="bulleted-list"><li style="list-style-type:circle">Giả sử ứng dụng của bạn có chức năng lưu tạm file, vậy mỗi lần người dùng lưu tạm miết vậy và không dùng, đến một lúc nào đó nó sẽ đầy và tốn dùng lượng. </li></ul><ul id="76e9b236-e5c2-4b56-b642-37a91abd13b0" class="bulleted-list"><li style="list-style-type:circle">Lúc này bạn cần một công việc tự động là 3 ngày nó sẽ dọn các file tạm đó đi. </li></ul><ul id="8ffc9cb5-ff50-4586-a78a-447b9d97e657" class="bulleted-list"><li style="list-style-type:circle">Do đó, đối với các công việc định kì, lặp đi lặp lại thì cron là giải pháp hoàn hảo.</li></ul></li></ul></details></li></ul><p id="01d2c8bf-eb57-42ce-9575-fcca86f20055" class="">
</p><ul id="d28fb48e-d702-478e-a950-c181293671ba" class="toggle"><li><details open=""><summary><strong>IoC</strong></summary><ul id="149e825f-8fe0-444b-a816-50a3f471ef50" class="bulleted-list"><li style="list-style-type:disc"><strong>Inversion of Control</strong> (<em>IoC - Đảo ngược điều khiển</em>) là một nguyên lý thiết kế trong công nghệ phần mềm trong đó các thành phần nó dựa vào để làm việc bị đảo ngược quyền điều khiển khi so sánh với lập trình hướng thủ thục truyền thống.</li></ul></details></li></ul><ul id="763c52cd-beaa-4fa4-8659-25d9d75639b2" class="toggle"><li><details open=""><summary><strong>Dependency Injection</strong></summary><ul id="40f37819-eeee-4531-9631-c4909b84b1cf" class="bulleted-list"><li style="list-style-type:disc"><a href="https://2kvn.com/di-la-gi">https://2kvn.com/di-la-gi</a></li></ul><ul id="03ff87ba-0bd4-4597-b218-38319ec4be31" class="bulleted-list"><li style="list-style-type:disc"><strong>Dependency Injection</strong> (DI) là 1 design pattern được sử dụng để thực hiện <a href="https://2kvn.com/ioc-la-gi">Inversion of Control(loC)</a>. DI giúp loại bỏ việc phụ thuộc trực tiếp của class với đối tượng.</li></ul><ul id="4b67c4c6-d3c4-4104-bfa2-33491869dc0b" class="bulleted-list"><li style="list-style-type:disc">Có thể hiểu Dependency Injection một cách đơn giản như sau:<ul id="7ff4a618-a74e-429a-b51f-b9c251da4296" class="bulleted-list"><li style="list-style-type:circle">Các module không giao tiếp trực tiếp với nhau, mà thông qua interface. Module cấp thấp sẽ implement interface, module cấp cao sẽ gọi module cấp thấp thông qua interface.</li></ul><ul id="3fb2ddbd-3240-486b-a356-0465e6bfc6f0" class="bulleted-list"><li style="list-style-type:circle">Việc khởi tạo các module cấp thấp sẽ do DI Container thực hiện.</li></ul><ul id="37048eba-3e48-4110-a07e-895d2b01b823" class="bulleted-list"><li style="list-style-type:circle">Việc Module nào gắn với interface nào sẽ được config trong code hoặc trong file XML</li></ul><ul id="d320341d-9f1f-4de6-857d-7ec2a0a287e4" class="bulleted-list"><li style="list-style-type:circle">DI được dùng để làm giảm sự phụ thuộc giữa các module, dễ dàng hơn trong việc thay đổi module, bảo trì code và testing.</li></ul></li></ul><p id="591a72ea-bdc4-49a5-a6a0-5698fc90ffb1" class=""><a href="https://toidicodedao.com/2015/11/03/dependency-injection-va-inversion-of-control-phan-1-dinh-nghia/">https://toidicodedao.com/2015/11/03/dependency-injection-va-inversion-of-control-phan-1-dinh-nghia/</a></p><p id="fa8801dd-4e0a-4ff1-a184-f9b456bac6b9" class="">
</p><p id="f5bf77ef-c49b-49d1-afbd-0bf7cb1edec0" class=""><a href="https://kipalog.com/posts/Dependency-injection---Nhung-thu-co-the-ban-bo-qua">https://kipalog.com/posts/Dependency-injection---Nhung-thu-co-the-ban-bo-qua</a></p></details></li></ul><ul id="115bdfc0-349e-4bd8-b2e2-1b2b68ca432f" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Push notification &amp; real time</strong></mark></summary><p id="905c101e-f74b-4d25-81b6-d3bff2e89cc8" class=""><a href="https://kipalog.com/posts/Realtime--Pusher-va-ke-thay-the-Slanger">https://kipalog.com/posts/Realtime--Pusher-va-ke-thay-the-Slanger</a></p><ul id="3039dc7a-485c-4bc1-9299-b36fddc6ec00" class="bulleted-list"><li style="list-style-type:disc">Một số cách push notification từ server đến client<ul id="bc6c8322-96df-47ec-8288-c06e662efc1c" class="bulleted-list"><li style="list-style-type:circle">setInterval gọi 5s hay 10s gì đó thì call api lên server</li></ul><ul id="28af8845-4056-455b-9f56-ed27632e39bc" class="bulleted-list"><li style="list-style-type:circle">Sử dụng Nodejs với websocket</li></ul><ul id="09b3dae1-6040-4eef-ac6d-e45e4534ad51" class="bulleted-list"><li style="list-style-type:circle">Sử dụng cơ chế pub sub của redis</li></ul><ul id="7bd09cef-6d82-4573-a5f5-3048dd667c6d" class="bulleted-list"><li style="list-style-type:circle">Sử dụng một Pusher (trả phí), Slanger (open source)</li></ul><ul id="97be859a-93dd-4fc8-8cf9-01278b4f191e" class="bulleted-list"><li style="list-style-type:circle">Sử dụng firebase</li></ul><ul id="7ac4843e-5692-4a15-8243-17bfc152724b" class="bulleted-list"><li style="list-style-type:circle">...</li></ul></li></ul></details></li></ul></details></li></ul><ul id="b3cd82d9-d7e2-4e34-9043-c8298b86c944" class="toggle"><li><details open=""><summary><strong>Database</strong></summary><p id="88631f47-18e3-4612-82da-62b50d7a47b0" class=""><a href="https://techtfq.com/blog/top-20-sql-interview-questions?ref=morioh.com&amp;utm_source=morioh.com">https://techtfq.com/blog/top-20-sql-interview-questions?ref=morioh.com&amp;utm_source=morioh.com</a></p><ul id="7f25e3b5-0680-460e-a933-54b7a7efb0b2" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>SQL ≠ NO SQL</strong></mark></summary><p id="7ab92877-50f6-491f-8607-4d5418210e34" class=""><a href="https://viblo.asia/p/nhung-diem-khac-biet-giua-sql-va-nosql-gGJ59b4rKX2">https://viblo.asia/p/nhung-diem-khac-biet-giua-sql-va-nosql-gGJ59b4rKX2</a></p><p id="662b85cf-14fa-44ed-801f-f1c5cea5563d" class=""><a href="https://viblo.asia/p/sql-vs-nosql-dau-la-lua-chon-phu-hop-cho-du-an-cua-ban-Qbq5QWAzZD8">https://viblo.asia/p/sql-vs-nosql-dau-la-lua-chon-phu-hop-cho-du-an-cua-ban-Qbq5QWAzZD8</a></p></details></li></ul><ul id="83435317-e3d1-48a8-ab47-9bd2627caa05" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Transaction, ACID</strong></mark></summary><ul id="ffe21acf-0c19-4b43-b01f-e79f203362c7" class="toggle"><li><details open=""><summary><strong>Transaction</strong> là một tiến trình xử lý có xác định điểm đầu và điểm cuối, được chia nhỏ thành các operation (phép thực thi), tiến trình được thực thi một cách tuần tự và độc lập các operation đó theo nguyên tắc hoặc tất cả đều thành công hoặc một operation thất bại thì toàn bộ tiến trình thất bại. Nếu việc thực thi một operation nào đó bị fail (hỏng) đồng nghĩa với việc dữ liệu phải rollback (trở lại) trạng thái ban đầu.</summary><ul id="af21b3a8-5688-41c2-a6ee-92c05e43e18b" class="bulleted-list"><li style="list-style-type:disc">Một transaction đòi hỏi phải có 4 tính chất ACID. </li></ul><ul id="af887dcb-0969-4810-bfdb-743554e47eb7" class="bulleted-list"><li style="list-style-type:disc">ACID là viết tắt của cụm từ Atomicity (nguyên tử), Consistency (nhất quán), Isolation (Cô lập), và Durability (Lâu bền). </li></ul><ul id="3f1c187c-372e-4f54-b3eb-b6f5fb9cf24c" class="bulleted-list"><li style="list-style-type:disc">Đây là các thuộc tính mà mọi transaction đều được đảm bảo bởi SQL Server.<ul id="a27408f5-1ba5-4e3e-8e5c-80dbfc608ebc" class="bulleted-list"><li style="list-style-type:circle"><strong>Atomicity</strong>: Mọi thay đổi về mặt dữ liệu phải được thục hiện trọn vẹn khi transaction thực hiện thành công hoặc không có bất kì sự thay đổi nào về mặt dữ liệu nếu có xẩy ra sự cố. <strong><em>Giải thích thêm:</em></strong><ul id="e12faa17-8040-46de-a465-5ee11955469b" class="bulleted-list"><li style="list-style-type:square">Một giao dịch là đơn vị cơ bản của quá trình xử lý. Tất cả các hoạt động của nó đều được thực thi, hoặc không có hoạt động nào trong số chúng. Giả sử rằng hệ thống bị treo sau thao tác Ghi (A) (nhưng trước khi ghi (B).)</li></ul><ul id="d3064bfd-a6bc-43d6-9fcb-80a597dca23e" class="bulleted-list"><li style="list-style-type:square">Cơ sở dữ liệu phải có khả năng khôi phục các giá trị cũ của A và B (hoặc hoàn thành toàn bộ giao dịch)</li></ul></li></ul><ul id="aa9e15cd-813e-4643-bd1a-7cf487fdfe80" class="bulleted-list"><li style="list-style-type:circle"><strong>Consistency</strong>: Sau khi một transaction kết thúc thì tất cả dữ liệu phải được nhất quán dù thành công hay thất bại. <strong><em>Giải thích thêm:</em></strong><ul id="9d75fec2-b5e6-49f0-a661-a7acc99e017a" class="bulleted-list"><li style="list-style-type:square">Việc thực hiện một giao dịch một mình phải di chuyển cơ sở dữ liệu từ trạng thái nhất quán này sang trạng thái nhất quán khác. </li></ul><ul id="47e9e452-c770-4ef1-b49e-3956f6d3b382" class="bulleted-list"><li style="list-style-type:square">Tổng của A và B phải không thay đổi khi thực hiện giao dịch</li></ul></li></ul><ul id="7758ba61-b49d-420b-98b4-413c577bfedb" class="bulleted-list"><li style="list-style-type:circle"><strong>Isolation</strong>: Các transaction khi đồng thời thực thi trên hệ thống thì không có bất kì ảnh hưởng gì tời nhau.<ul id="ee170f0b-5fa6-434e-8701-7fa3a709dfc5" class="bulleted-list"><li style="list-style-type:square">Một giao dịch không được để các giao dịch khác biết đến ảnh hưởng của nó cho đến khi nó được commit. </li></ul><ul id="5f57fd5b-e278-4047-874b-a2bb8b105260" class="bulleted-list"><li style="list-style-type:square">Nếu hai giao dịch thực hiện đồng thời, có vẻ như một giao dịch đã hoàn thành trước khi giao dịch kia bắt đầu. <strong><em>Giải thích thêm:</em></strong></li></ul><ul id="55c07360-82dc-4b0f-a6ce-5d2ab9d90425" class="bulleted-list"><li style="list-style-type:square">Nếu một giao dịch khác đang thực hiện đồng thời đang đọc (và / hoặc ghi vào) tài khoản A và B, nó sẽ không thể đọc dữ liệu ở trạng thái không nhất quán (sau khi ghi vào A và trước khi ghi vào B)</li></ul></li></ul><ul id="1682d58d-e498-4718-b26f-e13505c7f24a" class="bulleted-list"><li style="list-style-type:circle"><strong>Durability</strong>: Sau khi một transaction thành công thì tác dụng mà nó tạo ra phải bền vững trong cơ sở dữ liệu cho dù hệ thống có xẩy ra lỗi. <strong><em>Giải thích thêm:</em></strong><ul id="bc9e69d1-acb2-4a9d-85c1-7a88b0d01d7e" class="bulleted-list"><li style="list-style-type:square">Sau khi giao dịch được cam kết, các thay đổi đối với cơ sở dữ liệu không thể bị mất do lỗi trong tương lai. </li></ul><ul id="bcee1d1c-c6a1-4028-bd21-b8b66f37385f" class="bulleted-list"><li style="list-style-type:square">Khi giao dịch hoàn tất, chúng tôi sẽ luôn có các giá trị mới của A và B trong cơ sở dữ liệu</li></ul></li></ul></li></ul><hr id="b2e92364-3691-45d9-b978-f677fb85bd39"/></details></li></ul><ul id="91995b0e-f765-4600-919e-14de59b2f4ec" class="toggle"><li><details open=""><summary><strong>Transaction</strong> là một loạt các câu lệnh SQL hoạt động giống như một đơn vị duy nhất. </summary><ul id="72044953-3fbe-4d5c-af6f-acec7d9fb367" class="bulleted-list"><li style="list-style-type:disc">Nói một cách dễ hiểu, giao dịch là một đơn vị mà một chuỗi công việc được thực hiện để hoàn thành toàn bộ hoạt động. <ul id="ac8ae92f-ad76-4657-94f7-0efd92cd1720" class="bulleted-list"><li style="list-style-type:circle">Chúng ta có thể lấy ví dụ về Giao dịch ngân hàng để hiểu điều này.</li></ul></li></ul><ul id="0507ad60-e77e-4737-8c92-eff61d00d972" class="bulleted-list"><li style="list-style-type:disc">Khi chúng ta chuyển tiền từ tài khoản “A” sang tài khoản “B”, một giao dịch sẽ diễn ra. </li></ul><ul id="dff79ee9-1e58-410f-be91-9d1940412aaa" class="bulleted-list"><li style="list-style-type:disc">Mỗi giao dịch đều có bốn đặc điểm, chúng được gọi là thuộc tính ACID.<ul id="f869efe9-8f75-4095-9e94-c25440f5caea" class="bulleted-list"><li style="list-style-type:circle"><strong>Atomicity: </strong>Mọi giao dịch đều tuân theo mô hình tính nguyên tử, có nghĩa là nếu một giao dịch được bắt đầu, thì giao dịch đó phải được hoàn tất hoặc quay trở lại. <ul id="ddde6eb3-8a59-4926-a89e-589546f710b6" class="bulleted-list"><li style="list-style-type:square">Ví dụ: nếu một người đang chuyển số tiền từ tài khoản “A” sang tài khoản “B”, thì số tiền đó sẽ được ghi có vào tài khoản B sau khi hoàn tất giao dịch. </li></ul><ul id="17be183d-b4d8-4274-97a8-af21ada0edaf" class="bulleted-list"><li style="list-style-type:square">Trong trường hợp nếu có bất kỳ lỗi nào xảy ra, sau khi ghi nợ số tiền từ tài khoản “A”, thay đổi sẽ được hoàn lại.</li></ul></li></ul><ul id="4a50b596-b7d5-4c42-b522-f06209151c66" class="bulleted-list"><li style="list-style-type:circle"><strong>Consistency: </strong>Tính nhất quán nói rằng sau khi hoàn thành một giao dịch, các thay đổi được thực hiện trong quá trình giao dịch phải nhất quán. <ul id="9711bde4-40c5-4592-8183-d98b01cf36ff" class="bulleted-list"><li style="list-style-type:square">Ví dụ: nếu tài khoản “A” đã được ghi nợ 200 USD thì sau khi hoàn thành giao dịch, tài khoản “B” sẽ được ghi có 200 USD </li></ul><ul id="cadbbe2c-51a8-45c5-b748-04cd23436aaa" class="bulleted-list"><li style="list-style-type:square">Nó có nghĩa là các thay đổi phải nhất quán.</li></ul></li></ul><ul id="fd300b2a-a540-4b06-8bbf-d54bc634cfa7" class="bulleted-list"><li style="list-style-type:circle"><strong>Isolation: </strong>nói rằng mọi giao dịch nên được cách ly với nhau, không nên có bất kỳ sự can thiệp nào giữa hai giao dịch.</li></ul><ul id="1326732d-7fd0-4ee6-b92a-6f32a16b41ad" class="bulleted-list"><li style="list-style-type:circle"><strong>Durability: </strong>có nghĩa là một khi giao dịch được hoàn thành, tất cả các thay đổi sẽ là vĩnh viễn, có nghĩa là trong trường hợp hệ thống bị lỗi, các thay đổi sẽ không bị mất</li></ul></li></ul></details></li></ul></details></li></ul><ul id="155dab0d-80d3-437e-8680-a5af154991d3" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Master &amp; Slave</strong></mark></summary><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1069f6aa-7a78-48b9-8e3b-54995b15dc79"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><em>Hệ thống sẽ có 2 (hoặc nhiều hơn) database giống hệt nhau, mỗi database được cài trên 1 server khác nhau. Trong số các db đó, có 1 db được gọi là master (ông chủ), các db còn lại được gọi là slave (nô lệ). Khi db master xảy ra một sự kiện làm thay đổi dữ liệu (thêm, sửa, xóa) thì db master sẽ log ra một file, các db slave thì liên tục lắng nghe file log này, và thực hiện việc thay đổi dữ liệu trên db slave như thay đổi trên db master.</em></div></figure><ul id="2c2f94ab-6f4a-48fe-b758-cf4d12a3d821" class="bulleted-list"><li style="list-style-type:disc"><a href="https://viblo.asia/p/gioi-thieu-ve-mysql-replication-master-slave-bxjvZYwNkJZ">https://viblo.asia/p/gioi-thieu-ve-mysql-replication-master-slave-bxjvZYwNkJZ</a></li></ul></details></li></ul><ul id="dfcb3c56-4d2e-4eca-b6f4-2608eecce9f5" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Các mô hình database phổ biến</strong></mark></summary><ul id="9df0b8a5-f16d-41e4-99ac-0710437d253c" class="bulleted-list"><li style="list-style-type:disc"><strong><strong>Replication:</strong></strong> Hiểu nôm na thì đây là kiến trúc nhân bản. Chúng ta có 1 server Master và 1 hoặc nhiều server Slave. Master dùng chủ yếu để ghi dữ liệu (có thể dùng để đọc trong trường hợp cần thiết), Slave dùng để dọc dữ liệu và không thể ghi dữ liệu.</li></ul><ul id="009c6172-7596-44f6-bd8c-499341a4546b" class="bulleted-list"><li style="list-style-type:disc"><strong><strong>Partitioning: </strong></strong>đây là phương pháp giúp tối ưu truy vấn khi dữ liệu trong một bảng quá lớn hàng tram triệu bản ghi. Để dễ hình dung thì 1 bảng dữ liệu gióng như một chiếc hộp nhiều ngăn. Mỗi partition là một ngăn, mỗi một ngăn sẽ chưa một số lượng bản ghi theo một quy luật nào đó. Các cách chia thường theo id của bản ghi, hoặc theo thời gian tạo bản ghi theo ngày tháng</li></ul><ul id="9e6c105d-d236-4977-ae33-b943bc448d2e" class="bulleted-list"><li style="list-style-type:disc"><strong><strong>Cluster: </strong></strong>là mô hình dư liệu phân tán, kết hợp replication + sharding. Dữ liệu đươc lưu ở các datanode, truy vấn qua các sql node, và có 1 node là manager quản lý toàn bộ các sqlnode và datanode</li></ul><ul id="38f269b4-0747-4e48-9716-5551e8481bb9" class="bulleted-list"><li style="list-style-type:disc"><strong><strong>Sharding:</strong></strong> là mô hình tương tự như partition, partition chia dữ liệu theo chiều dọc thì sharding chia dữ liệu theo chiều ngang. Mỗi một partition giờ sẽ là 1 server.</li></ul><p id="ceff7ecb-8d4a-4288-bfd7-b6c6ce0a15b5" class=""><a href="https://kipalog.kaopiz.com/posts/Cac-mo-hinh-database-nen-biet">https://kipalog.kaopiz.com/posts/Cac-mo-hinh-database-nen-biet</a></p></details></li></ul><ul id="d99fe071-6232-41de-a649-cbd871ea8904" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Index</strong></mark></summary><ul id="f4182f36-31e5-4010-8e57-18ec17a6c3a8" class="bulleted-list"><li style="list-style-type:disc"><a href="https://www.notion.so/Index-f8e3ac712e3c4d069d1fb6a81919d2e8">Link</a></li></ul></details></li></ul><ul id="f3a4fa18-ca27-4bc0-a19b-49e48f94a0ac" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Store Procedure</strong></mark></summary><ul id="c4618a59-2422-4b7b-9049-5c1dc13688cb" class="bulleted-list"><li style="list-style-type:disc"><strong>Stored Procedure</strong> là một tập hợp các câu lệnh SQL dùng để thực thi một nhiệm vụ nhất định. Nó hoạt động giống như một <em>hàm</em> trong các ngôn ngữ lập trình khác.</li></ul><ul id="494a1553-8121-4a8a-a1f3-90e5d7c5bd40" class="bulleted-list"><li style="list-style-type:disc">Stored procedure là một khái niệm khá phổ biến và được hầu hết các hệ quản trị cơ sở dữ liệu (DBMS) hỗ trợ, tuy nhiên không phải tất cả đều hỗ trợ Stored Procedure.</li></ul><ul id="37a82e44-3c05-4790-a937-afbbec0bb43f" class="bulleted-list"><li style="list-style-type:disc">Lợi ích:<ul id="2e9fa574-740e-40db-894f-dc357b00e090" class="bulleted-list"><li style="list-style-type:circle">Module hóa: bạn chỉ cần viết SP 1 lần, sau đó có thể gọi nhiều lần trong ứng dụng</li></ul><ul id="a4856ff0-2e19-4819-8a61-c933909cb557" class="bulleted-list"><li style="list-style-type:circle">Hiệu suất: SP thực thi mã nhanh hơn và giảm tải băng thông.</li></ul><ul id="6f2ecdca-9c9b-428e-92b9-7660e7361a45" class="bulleted-list"><li style="list-style-type:circle">Bảo mật:</li></ul></li></ul><p id="afe78705-d568-403c-b7cf-98d947078d3c" class=""> <a href="https://viblo.asia/p/gioi-thieu-stored-procedure-trong-sql-server-m68Z0VpM5kG">https://viblo.asia/p/gioi-thieu-stored-procedure-trong-sql-server-m68Z0VpM5kG</a></p></details></li></ul><ul id="3e2dc239-a8c1-4026-a5d7-36dced7d8fa2" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Trigger</strong></mark></summary><ul id="6d307158-30ce-4af2-8032-e5f75c297c4d" class="bulleted-list"><li style="list-style-type:disc">Hiểu đơn giản thì Trigger là một stored procedure không có tham số. Trigger thực thi một cách tự động khi một trong ba câu lệnh Insert, Update, Delete làm thay đổi dữ liệu trên bảng có chứa trigger</li></ul><ul id="b1734a1f-25f8-4efb-9ea4-826a60cb94ad" class="bulleted-list"><li style="list-style-type:disc">Tác dụng:<ul id="1d833786-228f-465a-ab9c-97c4f26dae9c" class="bulleted-list"><li style="list-style-type:circle">Trigger thường được sử dụng để kiểm tra ràng buộc (check constraints) trên nhiều quan hệ (nhiều bảng/table) hoặc trên nhiều dòng (nhiều record) của bảng.</li></ul><ul id="c9a70614-05be-44c7-8ae0-0146e83f8952" class="bulleted-list"><li style="list-style-type:circle">Ngoài ra việc sử dụng Trigger để chương trình có những hàm chạy ngầm nhằm phục vụ nhưng trường hợp hữu hạn và thường không sử dụng cho mục đích kinh doanh hoặc giao dịch</li></ul></li></ul><p id="f70a5274-d6c4-4341-af5e-0b7abb39d68d" class=""><a href="https://viblo.asia/p/su-dung-trigger-trong-sql-qua-vi-du-co-ban-aWj538APK6m">https://viblo.asia/p/su-dung-trigger-trong-sql-qua-vi-du-co-ban-aWj538APK6m</a></p><p id="51112346-911a-4be8-986a-16d4e1bce4ea" class=""><a href="https://www.ibm.com/docs/en/informix-servers/12.10?topic=triggers-when-use">https://www.ibm.com/docs/en/informix-servers/12.10?topic=triggers-when-use</a></p></details></li></ul><ul id="ce5bc143-f1bb-470f-8588-9c521a3ff328" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>function ≠ procedure</strong></mark></summary><ul id="f69df2ee-d051-4d24-b081-f88726358dcb" class="bulleted-list"><li style="list-style-type:disc">Cả stored procedure và function đều là các đối tượng cơ sở dữ liệu chứa một tập các câu lệnh SQL để hoàn thành một tác vụ.</li></ul><ul id="86169538-b8d3-4bf2-ab2f-f20f828bdd24" class="bulleted-list"><li style="list-style-type:disc">Một stored procedure (thủ tục lưu trữ) có thể sử dụng lại nhiều lần. Vì vậy, nếu bạn có một truy vấn SQL mà bạn có ý định sử dụng nhiều lần thì hãy lưu nó dưới dạng một SP, sau đó chỉ cần gọi nó để nó thực thi truy vấn SQL của bạn. Ngoài ra, bạn củng có thể truyền tham số cho một SP</li></ul><ul id="6e61575b-be90-4247-a3f7-e9c433f6f52d" class="bulleted-list"><li style="list-style-type:disc">Một function (hàm) được biên dịch và thực thi mỗi khi hàm đó được gọi. Hàm phải trả về giá trị...</li></ul><ul id="6d275fd1-15dc-43e5-81c5-ffbe6706446a" class="bulleted-list"><li style="list-style-type:disc">Khác nhau:<ul id="5670c67d-d44f-4d7b-8cab-df32f3444802" class="bulleted-list"><li style="list-style-type:circle">Thủ tục lưu trữ có thể trả về giá trị zero, một hoặc nhiều giá trị. Trong khi hàm phải trả về một giá trị duy nhất (có thể là bảng).</li></ul><ul id="baf19a4e-32ab-4d7a-af3e-e7baca0b1c2c" class="bulleted-list"><li style="list-style-type:circle">Các hàm chỉ có thể có các tham số đầu vào cho nó trong khi thủ tục lưu trữ có thể có các tham số đầu vào hoặc đầu ra.</li></ul><ul id="f0323e84-ae60-4d11-9918-99ad446f6266" class="bulleted-list"><li style="list-style-type:circle">Hàm có thể được gọi từ thủ tục lưu trữ trong khi thủ tục lưu trữ không thể được gọi từ hàm.</li></ul><ul id="c50b2ef4-7be3-4ebd-8b96-801339d3560b" class="bulleted-list"><li style="list-style-type:circle">Một ngoại lệ có thể được xử lý bằng <strong>try-catch</strong> trong thủ tục lưu trữ, đối với hàm thì không thể.</li></ul><ul id="a4c92719-483c-41c3-a1fd-f4763ed30e77" class="bulleted-list"><li style="list-style-type:circle">Có thể sử dụng <strong>transaction</strong> trong thủ tục lưu trữ, với hàm thì không thể.</li></ul></li></ul><p id="0ef438dd-88d0-44f3-a972-02a1396f21d7" class=""><a href="https://itworld.forumvi.net/t688-topic">https://itworld.forumvi.net/t688-topic</a></p></details></li></ul><ul id="7779aad1-7ad8-4062-bf38-f8c16eaed111" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Aggregate</strong></mark></summary><ul id="c95159ef-dbe9-4025-a9e8-c9d8ef04299e" class="bulleted-list"><li style="list-style-type:disc">Aggregation có thể hiểu là sự tập hợp. Các <strong>Aggregation </strong>operation xử lý các bản ghi dữ liệu và trả về kết quả đã được tính toán. Các phép toán tập hợp nhóm các giá trị từ nhiều Document lại với nhau, và có thể thực hiện nhiều phép toán đa dạng trên dữ liệu đã được nhóm đó để trả về một kết quả duy nhất. </li></ul><ul id="10bbaf1a-f322-4a23-89f6-8a90394a5ead" class="bulleted-list"><li style="list-style-type:disc">Trong SQL, count(*) và GROUP BY là tương đương với Aggregation trong MongoDB.</li></ul></details></li></ul><ul id="52d8538a-6e3f-49e0-8584-27a8ed895686" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>distinct ≠ group by</strong></mark></summary><ul id="341186a0-1a5b-4fb8-9e83-b42bc47a9065" class="bulleted-list"><li style="list-style-type:disc"><strong>DISTINCT </strong>trong SQL được sử dụng kết hợp với câu lệnh SELECT để loại bỏ tất cả các bản ghi trùng lặp và chỉ lấy các bản ghi duy nhất.</li></ul><ul id="d2444c7c-4bfe-4cce-a587-a516a7f9aa01" class="bulleted-list"><li style="list-style-type:disc"><strong>GROUP BY</strong> trong SQL được sử dụng hợp tác với câu lệnh SELECT để sắp xếp dữ liệu giống nhau thành các nhóm. Mệnh đề GROUP BY này tuân theo mệnh đề WHERE trong câu lệnh SELECT và đứng trước mệnh đề ORDER BY.</li></ul><ul id="2abe237a-64ab-4df9-86e8-c507ad706d34" class="bulleted-list"><li style="list-style-type:disc">Cả hai mệnh đề đều làm giảm số lượng record trả về bằng cách loại bỏ các bản ghi trùng lặp</li></ul><ul id="8a237d78-54db-4835-b878-44bce2d15b21" class="bulleted-list"><li style="list-style-type:disc">Nhưng khi dùng <strong>group by</strong> ta có thể dùng kết hợp thêm một số aggregate như sum, count, ... còn <strong>distinct</strong> thì không</li></ul></details></li></ul><ul id="2392e74b-5679-4d85-8d74-2a02e8c6d682" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Inner, outer, left, right join</strong></mark></summary><ul id="80677a42-7614-4958-a5d3-54d592cf403a" class="bulleted-list"><li style="list-style-type:disc"><strong>JOIN</strong> trong SQL được sử dụng để kết hợp các bản ghi từ hai hay nhiều bảng trong cơ sở dữ liệu. JOIN là một phương tiện để kết hợp các trường từ hai bảng bằng cách sử dụng các giá trị chung cho mỗi bảng.</li></ul><ul id="d72a632f-9659-4789-86e2-2070a2a56505" class="bulleted-list"><li style="list-style-type:disc"><strong>INNER JOIN</strong>: Trả về các bản ghi có những giá trị phù hợp trong cả hai bảng.</li></ul><ul id="749deb27-2ad7-4818-a515-64077d4ee05c" class="bulleted-list"><li style="list-style-type:disc"><strong>LEFT (OUTER) JOIN</strong>: Trả về tất cả bản ghi từ bảng bên trái và bản ghi trùng với bảng bên phải.</li></ul><ul id="9a48d69c-f706-4730-a1de-aef9ab500620" class="bulleted-list"><li style="list-style-type:disc"><strong>RIGHT (OUTER) JOIN</strong>: Trả về tất cả bản ghi từ bảng bên phải và bản ghi trùng với bản bên trái.</li></ul><ul id="dd636df0-b24d-468f-be86-d3810519e807" class="bulleted-list"><li style="list-style-type:disc"><strong>FULL (OUTER) JOI</strong>N: Trả về tất cả bản ghi khi có một kết quả phù hợp trong bảng bên trái hoặc bên phải.</li></ul></details></li></ul><ul id="5d1ca363-da2b-4112-9fdf-1d2f08d7a00d" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>where ≠ having clause</strong></mark></summary><ul id="19078119-8b9e-48f8-9058-ccfd8325b3da" class="bulleted-list"><li style="list-style-type:disc">WHERE - filter kết quả theo dòng</li></ul><ul id="132eff1d-ef20-4f83-a288-c4dac584e1f7" class="bulleted-list"><li style="list-style-type:disc">HAVING - filter kết quả theo GROUP</li></ul><hr id="4403c678-8295-4404-a638-f9d6f607cef4"/><ul id="cae566d3-270b-4022-93a6-ebc6dad38245" class="bulleted-list"><li style="list-style-type:disc">Where : Là câu lệnh điều kiện trả kết quả đối chiếu với từng dòng</li></ul><ul id="93211886-0167-4c10-9590-75bbc16423e2" class="bulleted-list"><li style="list-style-type:disc">Having : Là câu lệnh điều kiện trả kết quả đối chiếu cho nhóm (Sum,AVG,COUNT,…)</li></ul><p id="cd9c927a-2f24-43b3-8df2-af034854c693" class="">⇒ Vì vậy mà sau GROUP BY thì sẽ chỉ dùng được Having còn Where thì KHÔNG dùng được sau GROUP BY</p><p id="aa30a82f-573d-4b82-81d4-5ce2c92ca2ab" class="">(HAVING có thể thay thế vị trí dùng cho WHERE nhưng ngược lại WHERE thì KHÔNG thể thay thế vị trí cho HAVING)</p><p id="a16a6652-9fb9-4955-b390-9a9d1fdc7c34" class=""><a href="https://daynhauhoc.com/t/su-khac-nhau-giua-where-va-having/21676/2">https://daynhauhoc.com/t/su-khac-nhau-giua-where-va-having/21676/2</a></p></details></li></ul><ul id="828c7538-1f0b-4f2a-a505-8b69f4d45576" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>delete ≠ truncate ≠ drop</strong></mark></summary><ul id="53c35426-920f-45da-90e3-eb02f9cc8bed" class="bulleted-list"><li style="list-style-type:disc">DELETE : Xóa một hay tất cả dòng trong một bảng theo một điều kiện nhất định, dữ liệu có thể phục hồi lại</li></ul><ul id="30590aad-383d-4f46-8faa-d225f9f9cd3e" class="bulleted-list"><li style="list-style-type:disc">TRUNCATE : Xóa toàn bộ các dòng của bảng, giải phóng bộ nhớ và không thể phục hồi lại</li></ul><ul id="a091e837-a874-4b44-997e-1ade6ebb7ca5" class="bulleted-list"><li style="list-style-type:disc">DROP : Xóa một bảng khỏi database</li></ul><ul id="e49756da-50d6-4cbc-a4db-bd292222d556" class="bulleted-list"><li style="list-style-type:disc">Truncate và drop không thể dùng mệnh đề Where</li></ul></details></li></ul><ul id="ade3b041-77a0-4323-ad84-49b41ed134fd" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Subqueries?</strong></mark></summary><ul id="c84cbc20-0829-43fd-be10-52a703485424" class="bulleted-list"><li style="list-style-type:disc">Subquery hay còn gọi là truy vấn con, đây là cách viết một câu lệnh SQL mà trong đó có lồng thêm một hoặc nhiều câu truy vấn khác, và thường được sử dụng trong bốn lệnh: SELECT, INSERT, UPDATE hoặc DELETE. Cùng với đó là các toán tử ví dụ như =, &lt;, &gt;, &gt;=, &lt;=, IN, BETWEEN…</li></ul><ul id="adfdde81-3a79-42fa-ae1c-5384f12958f5" class="bulleted-list"><li style="list-style-type:disc">Có một vài quy tắc mà Sub query phải tuân theo:<ul id="51062559-3d28-4490-b594-40625843fe9e" class="bulleted-list"><li style="list-style-type:circle">Sub query phải được đặt trong dấu ngoặc đơn.</li></ul><ul id="e7009a6b-89f6-45bb-a175-c073377adcd8" class="bulleted-list"><li style="list-style-type:circle">Một sub query có thể chỉ có một cột trong mệnh đề SELECT, trừ khi nhiều cột trong truy vấn chính cho sub query để so sánh các cột đã chọn của nó.</li></ul><ul id="1d720252-e668-4f6d-bf6c-0fc0e611ecac" class="bulleted-list"><li style="list-style-type:circle">Không thể sử dụng lệnh ORDER BY trong sub query, mặc dù truy vấn chính có thể sử dụng ORDER BY. Lệnh GROUP BY có thể được sử dụng để thực hiện chức năng giống như ORDER BY trong một sub query.</li></ul><ul id="da01c069-978b-405e-b4bc-f049d6a8e97b" class="bulleted-list"><li style="list-style-type:circle">Sub query trả về nhiều hơn một hàng chỉ có thể được sử dụng với toán tử nhiều giá trị như toán tử IN.</li></ul><ul id="b1ca9d9d-4bef-4e67-a8cf-f2a18cd07e09" class="bulleted-list"><li style="list-style-type:circle">Danh sách SELECT không được bao gồm bất kỳ tham chiếu nào đến các giá trị đánh giá BLOB, ARRAY, CLOB hoặc NCLOB.</li></ul><ul id="3358b5f7-f398-4b2b-9625-985053a14704" class="bulleted-list"><li style="list-style-type:circle">Một sub query không thể được chứa trực tiếp một chức năng set.</li></ul><ul id="30f4130a-4cba-4f9c-add3-03525461e81d" class="bulleted-list"><li style="list-style-type:circle">Toán tử BETWEEN không thể được sử dụng với một sub query. Tuy nhiên, toán tử BETWEEN có thể được sử dụng trong sub query.</li></ul></li></ul></details></li></ul><ul id="64c130fd-a83f-47a4-957a-f41acfb82836" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Union?</strong></mark></summary><ul id="654a3c7d-c3d1-4013-a26b-e6059e1626bf" class="bulleted-list"><li style="list-style-type:disc">Toán tử UNION được sử dụng để kết hợp tập hợp kết quả của hai hoặc nhiều câu lệnh SELECT. Mỗi câu lệnh SELECT với UNION phải có cùng số lượng cột, các cột phải có cùng kiểu dữ liệu, các cột trong mỗi câu lệnh SELECT phải có cùng trật tự.</li></ul><hr id="2fa07b23-1976-442f-96da-3a1a8dd338e9"/><ul id="b9f670b5-70da-4b6b-9683-80215d218edb" class="bulleted-list"><li style="list-style-type:disc">Mệnh đề <strong>UNION </strong>trong SQL được sử dụng để kết hợp các kết quả của hai hoặc nhiều câu lệnh SELECT mà không cần trả về bất kỳ hàng trùng lặp nào.</li></ul><ul id="c4def247-e267-4909-a719-8146d3367864" class="bulleted-list"><li style="list-style-type:disc">Để sử dụng mệnh đề UNION này, mỗi câu lệnh SELECT cần phải có<ul id="a852f1ba-92e9-4893-af7f-c256ccf4a89f" class="bulleted-list"><li style="list-style-type:circle">Cùng một số cột được chọn</li></ul><ul id="6df0873e-69c5-4083-9f5e-12c39b3f79d7" class="bulleted-list"><li style="list-style-type:circle">Cùng một số biểu thức cột</li></ul><ul id="c8b9a8bc-42b8-47db-8ed7-fcecb8762639" class="bulleted-list"><li style="list-style-type:circle">Cùng kiểu dữ liệu</li></ul><ul id="bfe3a219-7c5a-4da6-8045-58556b4838ad" class="bulleted-list"><li style="list-style-type:circle">Có chúng trong cùng một trật tự</li></ul></li></ul><hr id="d1575421-1837-4b96-b1f6-eead95b5224d"/><ul id="261a541a-2be6-4431-bdb4-15cc333756d1" class="bulleted-list"><li style="list-style-type:disc"><strong>UNION</strong> kết hợp lại nhưng loại bỏ trùng nhau</li></ul><ul id="821d8619-1c61-46f1-8f6d-f44ccf53157e" class="bulleted-list"><li style="list-style-type:disc"><strong>UNION ALL</strong> kết hợp lại nhưng không loại bỏ trùng nhau</li></ul></details></li></ul><ul id="2ecfb3bd-b8f7-4e9a-86f4-879a10896978" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Connection pool</strong></mark></summary><ul id="6d5662cd-d4c8-4c10-b391-6f7b22b51a30" class="bulleted-list"><li style="list-style-type:disc">Connection pool (vùng kết nối) : là kỹ thuật cho phép tạo và duy trì 1 tập các kết nối dùng chung nhằm tăng hiệu suất cho các ứng dụng bằng cách sử dụng lại các kết nối khi có yêu cầu thay vì việc tạo kết nối mới.</li></ul><ul id="2e50c07e-12be-4dd3-9ef3-037c263d589e" class="bulleted-list"><li style="list-style-type:disc">Connection Pool Manager (CPM) là trình quản lý vùng kết nối, một khi ứng dụng được chạy thì Connection pool tạo ra một vùng kết nối, trong vùng kết nối đó có các kết nối do chúng ta tạo ra sẵn. Và như vậy, một khi có một request đến thì CPM kiểm tra xem có kết nối nào đang rỗi không? Nếu có nó sẽ dùng kết nối đó còn không thì nó sẽ đợi cho đến khi có kết nối nào đó rỗi hoặc kết nối khác bị timeout. Kết nối sau khi sử dụng sẽ không đóng lại ngay mà sẽ được trả về CPM để dùng lại khi được yêu cầu trong tương lai.</li></ul></details></li></ul><ul id="684a7ae9-9ac9-46c3-b123-239e83d83e0c" class="toggle"><li><details open=""><summary>Data warehouse ≠ Data lake</summary><p id="ae231616-602c-4d8c-a5d0-e3d9c5d0b537" class="">
</p></details></li></ul></details></li></ul><ul id="6777e9f2-2c67-4c10-942c-c1332cf08aa3" class="toggle"><li><details open=""><summary><strong>Design patterns</strong></summary><ol type="1" id="772baa25-79a0-4705-baf2-7c69239a2f2c" class="numbered-list" start="1"><li>Strategy</li></ol><ul id="9ba3ba22-0f58-48e4-858c-96b723734d72" class="toggle"><li><details open=""><summary><strong>Singleton</strong></summary><ul id="30e046d0-abde-4f4d-9821-a97efdf630e6" class="bulleted-list"><li style="list-style-type:disc"><a href="https://2kvn.com/design-patterns-singleton-p5f35363236">https://2kvn.com/design-patterns-singleton-p5f35363236</a></li></ul></details></li></ul><ol type="1" id="ac222cd1-4a12-4691-86f6-4d774f5e2812" class="numbered-list" start="1"><li>Observer</li></ol><p id="229e1edd-4cad-45be-9d1f-144c2392d6e7" class=""><a href="https://blog.bitsrc.io/3-design-patterns-every-developer-should-learn-71a51568ac9d">https://blog.bitsrc.io/3-design-patterns-every-developer-should-learn-71a51568ac9d</a></p></details></li></ul><ul id="02ee0dba-17b4-49f1-a455-50233e67fbe3" class="toggle"><li><details open=""><summary><strong>RULE</strong></summary><ol type="1" id="6933697d-b61a-4ab0-9a85-e558c3f2879c" class="numbered-list" start="1"><li>SOLID</li></ol><ol type="1" id="765b4401-900d-4be4-b0e9-217866bc1dd3" class="numbered-list" start="2"><li>DRY</li></ol></details></li></ul><ul id="51331a38-becb-4399-9d00-fd92547eefbe" class="toggle"><li><details open=""><summary><strong>Systems</strong></summary><ul id="13f352a4-355d-4aaa-a1af-291c404da904" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>HTTP ≠ HTTPS, SSL</strong></mark></summary><ul id="c76ede17-70be-476d-8e05-db381f85f4bd" class="bulleted-list"><li style="list-style-type:disc"><strong>HTTP</strong>: giao thức không bảo mật, mọi dữ liệu truyền trên internet sẽ không được mã hoá, nghĩa là khi ta submit một form trên trang đó (VD: đăng nhập bằng password, gửi thông tin tài khoản ngân hàng, hay thậm chí các tin nhắn thông thường) thì mọi thông tin bạn nhập và gửi nếu để ai đó trên internet bắt được gói tin, bạn sẽ bị lộ những thông tin đó.</li></ul><ul id="3edaf732-ae46-4f32-8c30-10691c9d5c5a" class="bulleted-list"><li style="list-style-type:disc"><strong>HTTPS</strong>: giao thức bảo mật, giúp cho gói tin gửi tới server được mã hoá khi đi trên internet, ai đó có bắt được gói tin họ cũng không thể đọc được thông tin nằm trong gói tin đó.<ul id="fa22a7f9-a895-479b-88de-10d6aa71ec76" class="bulleted-list"><li style="list-style-type:circle"><strong>HTTPS </strong>sử dụng giao thức <strong>SSL (còn gọi là TLS) </strong>để mã hoá dữ liệu của <strong>HTTP</strong></li></ul><ul id="6a7b4010-b9fa-4135-9229-88e325d09b2e" class="bulleted-list"><li style="list-style-type:circle">Cách giao thức <strong>SSL</strong> hoạt động: <a href="https://blog.daovanhung.com/post/cach-hoat-dong-cua-ssl-va-https">https://blog.daovanhung.com/post/cach-hoat-dong-cua-ssl-va-https</a></li></ul></li></ul></details></li></ul><ul id="972bb775-a294-4e23-b83b-6ee37610e867" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>stateless ≠ stateful</strong></mark></summary><ul id="8dc69401-ed20-4278-96ec-609a9a96ee59" class="bulleted-list"><li style="list-style-type:disc"><strong>stateless</strong>: là design không lưu dữ liệu của client trên server. Có nghĩa là sau khi client gửi dữ liệu lên server, server thực thi xong, trả kết quả thì “quan hệ” giữa client và server bị “cắt đứt” – server không lưu bất cứ dữ liệu gì của client.</li></ul><ul id="08e2c336-e772-4763-a52c-dc5d91ba4e65" class="bulleted-list"><li style="list-style-type:disc"><strong>stateful</strong>: là một design ngược với stateless, server cần lưu dữ liệu của client, điều đó đồng nghĩa với việc ràng buộc giữa client và server vẫn được giữ sau mỗi request (yêu cầu) của client. Data được lưu lại phía server có thể làm đầu vào (input parameters) cho lần kế tiếp, hoặc là dữ kiện dùng trong quá trình xử lý hay phục vụ cho bất cứ nhu cầu nào phụ thuộc vào bussiness (nghiệp vụ) cài đặt.</li></ul></details></li></ul><ul id="594a86bb-3676-402f-a076-f1e9d3449976" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Vertical scale ≠ Horizontal scale</strong></mark></summary><ul id="883b13da-d693-4b04-84b8-fe657f1ebbf2" class="bulleted-list"><li style="list-style-type:disc"><strong>scaling vertically</strong>: mở rộng theo chiều dọc, là cách mở rộng server hiện tại bằng cách nâng cấp độ mạnh (power) bằng cách nâng cấp CPU, Ram, Storage, v.V… Vertical-scaling thường bị giới hạn bởi vượt quá khả năng về cấu hình vật lý hiện đại hay độ trễ khi “chẳng may” Server bị downtime để nâng cấp hay deploy hệ thống.</li></ul><ul id="c232a5e3-11d6-4f80-92f3-d902d01c2686" class="bulleted-list"><li style="list-style-type:disc"><strong>scaling horizontally</strong>: mở rộng theo chiều ngang, là cách mở rộng bằng cách thêm nhiều Node/Server vào một mạng lưới đang có, làm tăng khả năng chịu tải có hệ thống. Cách làm này rẻ và dễ làm hơn so với Vertical-scaling, đặc biệt là rất dễ dàng downsize cũng như upsize hệ thống.</li></ul></details></li></ul><ul id="4370afa5-553b-4a16-82ca-f3e79b48a948" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>CDN</strong></mark></summary><ul id="09c1ae23-ee5d-41e5-9f67-8e8327a113b2" class="bulleted-list"><li style="list-style-type:disc">CDN là một nhóm server đặt tại nhiều vị trái khác nhau để hỗ trợ nội dung được trải dài ở nhiều khu vực vị trí địa lý khác nhau.</li></ul><ul id="3ecfa1f7-a563-4613-a53a-6d727d6a3544" class="bulleted-list"><li style="list-style-type:disc">CDN cũng được gọi là “distribution networks”. Ý tưởng là tạo được nhiều điểm truy cập (Point of Presence – PoPs) ngoài server gốc. Việc này giúp website quản lý tốt traffic hơn bằng cách xử lý nhanh hơn yêu cầu của khách, tăng trải nghiệm người dùng.</li></ul><ul id="f5f2bd8b-3dd9-4390-9dd7-2c1885dd0a99" class="bulleted-list"><li style="list-style-type:disc">Cách CDN hoạt động:<ul id="e72e9825-6fae-410a-b710-5c938a6daece" class="bulleted-list"><li style="list-style-type:circle">Trong mạng lưới Content Delivery. Mỗi điểm hiện diện (location) được gọi là một <strong>PoPs</strong>.</li></ul><ul id="b1339310-87c1-4353-a0b8-80d1767ddd3b" class="bulleted-list"><li style="list-style-type:circle">Để tăng thời gian phản hồi giữa client và server (người dùng và trang web), các PoPs (node trong mạng lưới) sẽ<strong> lưu nội dung trang web vào bộ nhớ (cached)</strong> của mình và làm mới nó thường xuyên.</li></ul><ul id="83dfa871-5b88-473b-8979-1dd84a17106b" class="bulleted-list"><li style="list-style-type:circle">Khi người dùng yêu cầu nội dung trang web, người dùng sẽ không trực tiếp truy cập tới trang web (ở bờ Tây nước Mỹ chẳng hạn) mà chỉ truy cập với một điểm CDN <strong>gần mình nhất</strong>.</li></ul></li></ul><ul id="d37101d7-9be3-4ea5-9e7b-e6fb84836591" class="bulleted-list"><li style="list-style-type:disc">Khi nào nên sử dụng?<ul id="c45b55a2-9a2d-4e07-9036-8d94d682e224" class="bulleted-list"><li style="list-style-type:circle">Nếu content của bạn chỉ có <strong>một lượng nhỏ truy cập </strong>ở vị trí địa lí <strong>gần nơi đặt máy chủ</strong>, không cần thiết phải dùng CDN.</li></ul><ul id="41a89976-65d8-4343-8d0a-8c73dfc5bb33" class="bulleted-list"><li style="list-style-type:circle">Ngược lại, nếu nội dung của bạn được truy cập và sử dụng ở khắp nơi trên thế giới. Đăng kí tham gia mạng lưới CDN là cần thiết giúp <strong>tăng trải nghiệm người dùng</strong>.</li></ul></li></ul></details></li></ul><ul id="d2a1af62-c506-4ca4-83b1-9d80c34b8d74" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>DNS</strong></mark></summary><ul id="42728502-1efb-45cd-a512-0df2c30cadca" class="bulleted-list"><li style="list-style-type:disc">DNS là viết tắt của Domain Name System tạm dịch là &quot;Hệ thống phân giải tên miền&quot;. Về bản chất cách để máy tính truy cập được một trang web là nhờ địa chỉ IP. </li></ul><ul id="f9860a94-c7c4-40ce-af5d-479c2b851b7f" class="bulleted-list"><li style="list-style-type:disc">Ví dụ bạn muốn truy cập vào <strong>google.com</strong> thì tức là browser đang request tới IP máy chủ của google. </li></ul><ul id="9f88d5a3-f902-4ff1-99da-159878439724" class="bulleted-list"><li style="list-style-type:disc">Tuy nhiên có cả triệu website và bạn phải nhớ địa chỉ IP của từng trang web, điều đó là bất khả thi và chưa kể trường hợp địa chỉ IP của trang web đó có thể thay đổi liên tục. Đó cũng chính là nguyên nhân mà DNS được sinh ra. </li></ul><ul id="a04ca7f2-17f4-436c-bc18-edce4ffc91fb" class="bulleted-list"><li style="list-style-type:disc">DNS sẽ đóng vai trò như một cuốn danh bạ, thay vì phải nhớ 1 dãy IP loằng ngoằng thì bạn sẽ nhớ đến tên miền của trang web đó</li></ul><ul id="ca8db07c-6453-4d5b-9497-d54209e0c6f2" class="bulleted-list"><li style="list-style-type:disc">Ví dụ như <strong>google.com</strong> và tất nhiên như vậy sẽ thân thiện với người sử dụng hơn, và DNS sẽ có vai trò là phân giải tên miền thành địa chỉ IP tương ứng nhờ đó browser có thể gửi request tới server.</li></ul></details></li></ul><ul id="c6212797-164e-4c40-b3ed-72298a4fc219" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Load balancer</strong></mark></summary><ul id="25f17a8d-487b-477f-89fa-b2553dec7f63" class="bulleted-list"><li style="list-style-type:disc">Load Balancing là quá trình của việc phân phối lưu lượng truy cập một cách hiệu quả thông qua nhiều server hay còn được gọi là <code>server farm </code>hay <code>server pool</code></li></ul><ul id="7ffbc9f9-2d79-499f-8cc9-829bb526b3ce" class="bulleted-list"><li style="list-style-type:disc">Việc phân phối đồng một cách đồng đều sẽ cải thiện khả năng đáp ứng và tăng tính khả dụng của các ứng dụng. </li></ul><ul id="8e1d1c7c-4bb1-4e2d-9bc3-fc70be1e562d" class="bulleted-list"><li style="list-style-type:disc">Phương pháp này ngày càng cần thiết vì các ứng dụng ngày nay đã phức tạp hơn, cùng với nhu cầu của người sử dụng tăng và lưu lượng truy cập tăng lên.</li></ul><ul id="a9f6d27f-270d-44ce-a16e-65d1dc66978c" class="bulleted-list"><li style="list-style-type:disc">Load balancer đã giải quyết được các vấn đề như:<ul id="30953f77-23d5-4b3e-8796-e132a8b9654f" class="bulleted-list"><li style="list-style-type:circle">Performance: dễ dàng scale up (vertical scaling) và scale out (horizontal scaling)</li></ul><ul id="4f6002bc-de4f-4d37-82af-d3c86d60d181" class="bulleted-list"><li style="list-style-type:circle">Availability: có server dự phòng và cơ chế tự động khôi phục. Nếu 1 server bị lỗi sẽ không ảnh hưởng đến toàn bộ hệ thống</li></ul><ul id="d97f32d2-1dd6-4012-8a8e-2a8a0bd987d5" class="bulleted-list"><li style="list-style-type:circle">Economy: triển khai một server có hiệu năng lớn thì đắt hơn so với một cụm server có hiệu năng nhỏ. Chi phí để duy trì một cụm server nhỏ thì rẻ hơn và dễ dàng thêm hoặc nâng cấp server trong cụm này so với việc nâng cấp và thay thế một server lớn</li></ul></li></ul><ul id="ddbfb988-93d2-4ccd-a90a-305ca966ea95" class="bulleted-list"><li style="list-style-type:disc">Load balancer có 3 kiến trúc cơ bản:<ul id="6d1e6179-28f2-4c6d-b80c-58b13036f231" class="bulleted-list"><li style="list-style-type:circle">Dựa trên DNS</li></ul><ul id="fcf3329d-46de-4ccc-b24e-c98a25b6a35c" class="bulleted-list"><li style="list-style-type:circle">Dựa trên phần cứng</li></ul><ul id="f22023d3-f4de-40c0-80c8-86e7fdd4a00c" class="bulleted-list"><li style="list-style-type:circle">Dựa trên phần mềm</li></ul></li></ul><ul id="15b23ba0-bdcd-4730-9c97-ce6509f167a8" class="bulleted-list"><li style="list-style-type:disc">Các thuật toán cơ bản: <ul id="019e882d-3746-4e02-9f67-a60bf5391f6d" class="bulleted-list"><li style="list-style-type:circle">Round Robin</li></ul><ul id="0aa4dd47-6c19-4e0c-b7d0-e198a4601447" class="bulleted-list"><li style="list-style-type:circle">Weighted Round Robin</li></ul><ul id="bc68f9d7-47ab-42b3-8c60-a35c646a8ca0" class="bulleted-list"><li style="list-style-type:circle">Dynamic Round Robin</li></ul><ul id="a2112c0b-1094-45f7-988d-87fd8ba8110f" class="bulleted-list"><li style="list-style-type:circle">Fastest</li></ul><ul id="38a4f60a-4a8c-4986-997b-fe47cb7b00ee" class="bulleted-list"><li style="list-style-type:circle">Least Connections</li></ul></li></ul><p id="10e27beb-39e6-4cbe-b3c8-9432f950fc4e" class=""><span style="border-bottom:0.05em solid"><strong>Link</strong></span>: <a href="https://anonystick.com/blog-developer/load-balancer-neu-ban-khong-hieu-khong-sao-nhung-neu-ban-la-mot-ky-su-thi-khong-the-khong-hieu-202006243445464">https://anonystick.com/blog-developer/load-balancer-neu-ban-khong-hieu-khong-sao-nhung-neu-ban-la-mot-ky-su-thi-khong-the-khong-hieu-202006243445464</a></p></details></li></ul><ul id="27de94a5-cb86-4bae-8cd9-fadc89b890e9" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Nginx</strong></mark></summary><ul id="842ad3d7-f533-4704-9002-9b4e7e2ea4a5" class="bulleted-list"><li style="list-style-type:disc">là một máy chủ web server, open source, được thiết kế hướng đến mục đích cải thiện tối đa hiệu năng và sự ổn định.</li></ul><ul id="43665d18-ec05-4e1e-9464-889f83b476bc" class="bulleted-list"><li style="list-style-type:disc">Ngoài ra nhờ vào khả năng của máy chủ http, nginx còn có thể hoạt động như proxy server cho email, reverse proxy, http caching hay load balancer cho các máy chủ http, tcp, udp</li></ul><ul id="1a085255-e4e8-48b7-9e40-5129bf050d9a" class="bulleted-list"><li style="list-style-type:disc">Nginx được sử dụng kiến trúc đơn luồng và event driven (hướng sự kiện) vì thế nó hiệu quả hơn apache server nếu cấu hình chính xác. </li></ul><ul id="b9d82c72-5708-47e5-ab54-c12f61b8c333" class="bulleted-list"><li style="list-style-type:disc">NGINX được cấu hình theo kiểu bất đồng bộ (asynchronous): nghĩa là 1 NGINX process có thể xử lý nhiều request liên tục, dựa vào số lượng tài nguyên còn lại của hệ thống.</li></ul><ul id="e971db54-c4e6-4230-bfed-54a764df41a8" class="bulleted-list"><li style="list-style-type:disc">Nhờ kiểu cấu hình như vậy, NGINX có thể “nhúng” các file lập trình (như .php) vào process riêng của nó. Nghĩa là mọi request yêu cầu data được 1 process riêng của NGINX thực hiện, và trả data lại cho client bằng reverse proxy.</li></ul><ul id="5c076f4e-2c8d-46d6-9089-bdb31e1aacfb" class="bulleted-list"><li style="list-style-type:disc">Bên cạnh đó, đối với những file tĩnh (file .txt, file .css hay các file hình ảnh), NGINX sẽ trả dữ liệu mà không cần sự can thiệp của các module server side.</li></ul></details></li></ul><ul id="763a2c0d-e778-4ea9-bb2c-d5be4a1a3908" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>TCP ≠ UDP</strong></mark></summary><ul id="56c0aca6-7ebb-44f9-a7f9-fcc6e5cbe9ac" class="bulleted-list"><li style="list-style-type:disc"><strong>TCP</strong> là giao thức truyền tải hướng kết nối (connection-oriented), nghĩa là phải thực hiện thiết lập kết nối với đầu xa trước khi thực hiện truyền dữ liệu. Tiến trình thiết lập kết nối ở TCP được gọi là tiến trình <em><strong>bắt tay 3 bước</strong></em> (<em>threeway handshake</em>).<ul id="82000b83-90e7-47e9-a3a7-fffd910b7f9e" class="bulleted-list"><li style="list-style-type:circle">Cung cấp cơ chế báo nhận (Acknowledgement) :Khi A gửi dữ liệu cho B, B nhận được thì gửi gói tin cho A xác nhận là đã nhận. Nếu không nhận được tin xác nhận thì A sẽ gửi cho đến khi B báo nhận thì thôi.</li></ul></li></ul><ul id="3e373d77-1bbe-4661-b2c1-7514724fbef1" class="bulleted-list"><li style="list-style-type:disc"><strong>UDP</strong> là giao thức truyền tải hướng không kết nối (connectionless). Nó sẽ không thực hiện thao tác xây dựng kết nối trước khi truyền dữ liệu mà thực hiện truyền ngay lập tức khi có dữ liệu cần truyền (kiểu truyền best effort) =&gt; truyền tải rất nhanh cho dữ liệu của lớp ứng dụng.<ul id="66ef8eb0-708f-4528-9641-025b771d3dcf" class="bulleted-list"><li style="list-style-type:circle">Không đảm bảo tính tin cậy khi truyền dữ liệu và không có cơ chế phục hồi dữ liệu ( nó không quan tâm gói tin có đến đích hay không, không biết gói tin có bị mất mát trên đường đi hay không) =&gt; dễ bị lỗi.</li></ul></li></ul><p id="77197cbb-9b18-46be-8c14-c1fdd4ede839" class=""><a href="https://viblo.asia/p/tim-hieu-giao-thuc-tcp-va-udp-jvEla11xlkw">https://viblo.asia/p/tim-hieu-giao-thuc-tcp-va-udp-jvEla11xlkw</a></p></details></li></ul><ul id="7ac206e2-dbe7-4a4d-be35-491a99bf29af" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Quy tác bắt tay 3 bước</strong></mark></summary><pre id="49b9b06e-0d4e-4bd6-bae3-79cf48916146" class="code"><code>* Gói dữ liệu với cờ SYN (synchronization &lt;=&gt; Sự đồng bộ) dùng để bắt đầu một connection.
* ACK (acknowledgement &lt;=&gt; Xác nhận).
* FIN (finish &lt;=&gt; hoàn thành) dùng để ngắt một connection.
* ...</code></pre><ul id="53729378-6ea9-4918-8415-d709dcb50751" class="bulleted-list"><li style="list-style-type:disc"><strong>B1</strong>:<ul id="b97c02cb-7020-4b34-9490-bbb2dd4ece0b" class="bulleted-list"><li style="list-style-type:circle">SYN: các chương trình máy con (ví dụ yêu cầu từ browser, ftp client) bắt đầu connection với máy chủ bằng cách gửi một packet với cờ &quot;SYN&quot; đến máy chủ.</li></ul><ul id="3c7aa839-8807-462f-83e4-7720dc334337" class="bulleted-list"><li style="list-style-type:circle">SYN packet này thường được gửi từ các cổng cao (1024 - 65535) của máy con đến những cổng trong vùng thấp (1 - 1023) của máy chủ. </li></ul><ul id="96518b39-4dce-4528-b882-1ae74c06137e" class="bulleted-list"><li style="list-style-type:circle">Chương trình trên máy con sẽ hỏi hệ điều hành cung cấp cho một cổng để mở connection với máy chủ. </li></ul><ul id="9f19eb8d-53dc-4038-a48e-a7d40a108d69" class="bulleted-list"><li style="list-style-type:circle">Những cổng trong vùng này được gọi là &quot;cổng máy con&quot; (client port range). </li></ul><ul id="3784698a-5912-4ad9-b2a5-66d12b27ed0d" class="bulleted-list"><li style="list-style-type:circle">Tương tự như vậy, máy chủ sẽ hỏi HĐH để nhận được quyền chờ tín hiệu trong máy chủ, vùng cổng 1 - 1023. </li></ul><ul id="2fa316c1-b79b-4aef-b6e8-7a61e9220e72" class="bulleted-list"><li style="list-style-type:circle">Vùng cổng này được gọi là &quot;vùng cổng dịch vụ&quot; (service port).<pre id="919e2e23-7bae-413b-b621-3e1b62685b51" class="code"><code>- Ví dụ (mặc định):
    - Web Server sẽ luôn chờ tín hiệu ở cổng 80 và Web browser sẽ connect vào cổng 80 của máy chủ.
    - FTP Server sẽ lắng ở port 21.
    
 Ngoài ra trong gói dữ liệu còn có thêm địa chỉ IP của cả máy con và máy chủ.</code></pre></li></ul></li></ul><ul id="0548055a-73a5-49ad-aa20-1a3082d03bdb" class="bulleted-list"><li style="list-style-type:disc"><strong>B2</strong>: <ul id="2b71b39e-0349-4769-a5cb-28744da0cd48" class="bulleted-list"><li style="list-style-type:circle">SYN/ACK: khi yêu cầu mở connection được máy chủ nhận được tại cổng đang mở, server sẽ gửi lại packet chấp nhận với 2 bit cờ là SYN và ACK.</li></ul><ul id="003aa407-8d2f-4828-b93c-13f32fd657d7" class="bulleted-list"><li style="list-style-type:circle">SYN/ACK packet được gửi ngược lại bằng cách đổi hai IP của server và client, client IP sẽ thành IP đích và server IP sẽ thành IP bắt đầu. Tương tự như vậy, cổng cũng sẽ thay đổi, server nhận được packet ở cổng nào thì cũng sẽ dùng cổng đó để gửi lại packet vào cổng mà client đã gửi.</li></ul><ul id="92ef6fd7-ee49-43c1-801a-8cb2e9fe8d25" class="bulleted-list"><li style="list-style-type:circle">Server gửi lại packet này để thông báo là server đã nhận được tín hiệu và chấp nhận connection, trong trường hợp server không chấp nhận connection, thay vì SYN/ACK bits được bật, server sẽ bật bit RST/ACK (Reset Acknowledgement) và gởi ngược lại RST/ACK packet.</li></ul><ul id="de3a6af3-4d4b-4f9a-a297-8d54451d68c1" class="bulleted-list"><li style="list-style-type:circle">Server bắt buộc phải gửi thông báo lại bởi vì TCP là chuẩn tin cậy nên nếu client không nhận được thông báo thì sẽ nghĩ rằng packet đã bị lạc và gửi lại thông báo mới.</li></ul></li></ul><ul id="988eb659-cb68-4e37-bab9-5388cd3ee0d3" class="bulleted-list"><li style="list-style-type:disc"><strong>B3</strong>:<ul id="5cd09e10-9422-4146-881c-188077c1dd5c" class="bulleted-list"><li style="list-style-type:circle">ACK: khi client nhận được SYN/ACK packet thì sẽ trả lời bằng ACK packet. </li></ul><ul id="2a061a27-f4e4-41b7-aabc-8f20d25dddbf" class="bulleted-list"><li style="list-style-type:circle">Packet này được gởi với mục đích duy báo cho máy chủ biết rằng client đã nhận được SYN/ACK packet và lúc này connection đã được thiết lập và dữ liệu sẽ bắt đầu lưu thông tự do.</li></ul><ul id="8237f577-a2a1-4535-92e7-5078f8ed7183" class="bulleted-list"><li style="list-style-type:circle">Đây là tiến trình bắt buộc phải thực hiện khi client muốn trao đổi dữ liệu với server thông qua giao thức TCP. </li></ul><ul id="7738fd9e-fd56-4d87-9c1e-44ac5800ec81" class="bulleted-list"><li style="list-style-type:circle">Một số thủ thuật dựa vào đặc điểm này của TCP để tấn công máy chủ (ví dụ DOS).</li></ul><p id="f6afd3d9-eff0-400b-8cfc-2276069a1d4e" class="">
</p></li></ul></details></li></ul><ul id="a5b61d77-466b-4655-9c9e-89b1aeda076b" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Reverse Proxy</strong></mark></summary><ul id="ba0f1d66-ca36-476c-ba9b-8f6452688b9b" class="bulleted-list"><li style="list-style-type:disc">Reverse proxy là một loại proxy server trung gian giữa một máy chủ và các client gửi tới các yêu cầu. Nó kiểm soát yêu cầu của các client, nếu hợp lệ, sẽ luân chuyển đến các server thích ứng. </li></ul><ul id="9ffadd28-3864-4113-8296-2da17a53da66" class="bulleted-list"><li style="list-style-type:disc">Trái ngược với một <strong>forward proxy</strong>, là một trung gian cho phép các client liên hệ với nó liên lạc với bất kỳ máy chủ ảo nào, reverse proxy là một trung gian cho các máy chủ liên hệ với nó được liên lạc bởi bất kỳ client nào. </li></ul><ul id="732fd622-5672-4c05-9906-bb75c9f992d7" class="bulleted-list"><li style="list-style-type:disc">Ưu điểm lớn nhất của việc sử dụng reverse proxy là khả năng quản lý tập trung. Nó giúp kiếm soát mọi request do client gửi lên các server được bảo vệ.</li></ul><ul id="24bdb293-efcc-42be-b500-59f95d470d5d" class="bulleted-list"><li style="list-style-type:disc">Reverse proxy server được dùng để làm gì?<ul id="ab4955c3-0af7-49df-8e99-74ab026176f5" class="bulleted-list"><li style="list-style-type:circle">Reverse proxy ở giữa client và network service, như là website. Một số tính năng mà nó mang lại như: <ul id="fa4f62f6-b99f-48c3-a922-c56176b64d76" class="bulleted-list"><li style="list-style-type:square">Bảo mật</li></ul><ul id="51f900b4-7b1e-4a83-8e24-684b5eeeb277" class="bulleted-list"><li style="list-style-type:square">Load balancing</li></ul><ul id="da40e1d1-9e12-4fd8-97d6-bdbf42c51446" class="bulleted-list"><li style="list-style-type:square">Tăng tốc độ trang web</li></ul></li></ul></li></ul><p id="3b0475eb-ce07-4f20-8494-26240cf1a737" class=""><a href="https://viblo.asia/p/reverse-proxy-server-la-gi-eW65GW4P5DO">https://viblo.asia/p/reverse-proxy-server-la-gi-eW65GW4P5DO</a></p></details></li></ul><ul id="26e2cd20-e040-4ec0-97a7-eaabf9b83b89" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Cluster, Node, Container</strong></mark></summary><ul id="8f3700cb-3a1f-4dcb-a2cf-7f6d5ff4c985" class="bulleted-list"><li style="list-style-type:disc"><strong>Clustering </strong>chính là 1 kiến trúc được tạo ra với mục đích đảm bảo nâng cao khả năng sẵn sàng cho những hệ thống mạng. Clustering bao gồm những server riêng lẻ được kết nối với nhau đồng thời hoạt động lại cùng nhau trong 1 hệ thống. Những server này giao tiếp với nhau với mục đích trao đổi thông tin và giao tiếp với cả những mạng bên ngoài để thực hiện những yêu cầu. Trong trường hợp có lỗi xảy ra những dịch vụ trong cluster hoạt động tương tác với nhau để duy trì tính ổn định và độ sẵn sàng cao cho hệ thống.</li></ul><ul id="9fa456c6-5929-44dc-8e61-5b88c07491af" class="bulleted-list"><li style="list-style-type:disc"><strong>Node</strong> là những server con trong cụm cluster</li></ul><ul id="afc6abf5-853c-47ef-82ad-eb9d0f38dda2" class="bulleted-list"><li style="list-style-type:disc"><strong>Container</strong> là nơi chứa ứng dụng hoặc service của chúng ta</li></ul></details></li></ul><ul id="c18a0c23-203f-4360-909e-f9392dcc693d" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Concurrent, latency, consistency</strong></mark></summary><ul id="a883da8f-b8b5-41bb-9cf6-5e53ee6f20f6" class="bulleted-list"><li style="list-style-type:disc"><strong>Latency</strong> được biết tới như là khoảng thời gian từ lúc chúng ta yêu cầu tải trang web cho tới khi thật sự nhìn thấy nội dung trên trang web đó.</li></ul></details></li></ul><ul id="c5ef3674-5eca-4024-83d7-ad07b8112d06" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>10 mẹo cải thiện hiệu suất máy chủ</strong></mark></summary><ul id="769748b5-ba0f-4011-b4d4-39c4aaefca6f" class="bulleted-list"><li style="list-style-type:disc">Sử dụng máy chủ proxy reverse để tăng tốc và bảo vệ các ứng dụng</li></ul><ul id="f922794c-57db-4f33-b06f-0e0298a5a645" class="bulleted-list"><li style="list-style-type:disc">Load balancing</li></ul><ul id="9a61e566-46a5-4f9c-8d5d-2d5d36b499f9" class="bulleted-list"><li style="list-style-type:disc">Cache và content</li></ul><ul id="9f7e40ae-91c3-4e3b-9737-6b0ea4ba87ed" class="bulleted-list"><li style="list-style-type:disc">Nén dữ liệu</li></ul><ul id="48f2b2bf-fd5d-49cc-91a1-44d265b7564f" class="bulleted-list"><li style="list-style-type:disc">Tối ưu hóa SSL / TLS</li></ul><ul id="6e781289-2e7c-4044-b1b3-6a9ca38693ba" class="bulleted-list"><li style="list-style-type:disc">Triển khai HTTP / 2 hoặc SPDY</li></ul><ul id="100018a6-fcbc-47c5-8507-367c74b13ad6" class="bulleted-list"><li style="list-style-type:disc">Cập nhật phiên bản phần mềm liên tục</li></ul><ul id="7d6b0ec7-2a50-407f-9f57-caf2218fc157" class="bulleted-list"><li style="list-style-type:disc">Tối ưu hóa hiệu suất Linux</li></ul><ul id="46fc8335-3b23-48d8-8378-bb1a4eed33b6" class="bulleted-list"><li style="list-style-type:disc">Tối ưu hóa hiệu suất của máy chủ Web</li></ul><ul id="884399aa-533a-492d-bba4-491f00ad7449" class="bulleted-list"><li style="list-style-type:disc">Giám sát các hoạt động thời gian thực để giải quyết các vấn đề và tắc nghẽn</li></ul><ul id="6098d6ee-30b1-4bbf-bd4d-5e54a73c7ecd" class="bulleted-list"><li style="list-style-type:disc"><a href="https://anonystick.com/blog-developer/10-meo-de-cai-thien-hieu-suat-cua-cac-ung-dung-web-len-10-lan-2020051556310698#t-2">https://anonystick.com/blog-developer/10-meo-de-cai-thien-hieu-suat-cua-cac-ung-dung-web-len-10-lan-2020051556310698#t-2</a></li></ul></details></li></ul><ul id="d42a9a73-39f6-4fdc-9bbf-8281b1da9319" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Notification system</strong></mark></summary><figure id="ebbb4996-8bb4-4ce3-83e2-5229617a7796" class="image"><a href="Interview%202022%20ebbb49968bb44ce383e25229617a7796/Screen_Shot_2022-04-26_at_09.24.38.png"><img style="width:768px" src="Interview%202022%20ebbb49968bb44ce383e25229617a7796/Screen_Shot_2022-04-26_at_09.24.38.png"/></a></figure><ul id="7a46bde2-fc22-476d-b435-3af4ebca75ba" class="bulleted-list"><li style="list-style-type:disc"><strong>External software</strong> sẽ send một JSON message qua https với message data giống như address, type, message, ...</li></ul><ul id="156fde28-f027-4f3e-b595-243888189449" class="bulleted-list"><li style="list-style-type:disc"><strong>Rate limiter</strong> validate những rules để bảo vệ system khỏi bị overload và những vấn đề về bảo mật</li></ul><ul id="c515f7b1-478e-4350-8f2e-6ddce936097a" class="bulleted-list"><li style="list-style-type:disc">Notification service sẽ nhận message và chuyển message đó đến với những message queue tương ứng và sau đó sẽ writes một số logs về notification xuống <strong>Data cache cluster </strong></li></ul><ul id="27e65334-02f6-4f7a-bfcd-931da9042154" class="bulleted-list"><li style="list-style-type:disc">Các <strong>workers</strong> sẽ lấy message trong queue và connect đến với third part software để send message đến các thiết bị tương ứng</li></ul><ul id="ec941f9d-29ac-4650-b3cf-c3f2cf1b9ec2" class="bulleted-list"><li style="list-style-type:disc"><strong>Third part software </strong>sẽ call back bằng cách sử dụng web hook để nhận status và một số thông tin của message </li></ul><ul id="8a7ef015-68ef-423e-9155-80a5728339cf" class="bulleted-list"><li style="list-style-type:disc">Sau đó có những <strong>workers</strong> sẽ chạy và lấy những thông tin response và lưu trữ vào <strong>data store</strong> </li></ul><ul id="9a7f9342-1e69-4c5c-bfd1-a166b9f360af" class="bulleted-list"><li style="list-style-type:disc">Thông tin về status và analytics data lúc này sẽ có sẵn trong <strong>Notification status &amp; analytics service</strong> và ta có thể truy cập service này từ bên ngoài với <strong>external service</strong></li></ul><p id="14e1f5c8-bec8-46d8-8adc-2fc429468a27" class="">⇒ <span style="border-bottom:0.05em solid"><strong>Lợi ích:</strong></span><div class="indented"><ul id="b059d324-7d3c-4079-9ea2-9a9efcf9e4e6" class="bulleted-list"><li style="list-style-type:disc"><strong>Reliability</strong>: giảm thiểu lỗi </li></ul><ul id="f7287ae9-14a5-4e22-af3b-8d2319749415" class="bulleted-list"><li style="list-style-type:disc"><strong>Security</strong>: chạy trên https với appKey và appSecret để đảm bảo user đã authorized mới có thể send message</li></ul><ul id="8fdadc96-aad0-4ec9-8139-8ca7b0f360e9" class="bulleted-list"><li style="list-style-type:disc"><strong>Tracking and monitoring</strong>: logs, status và analytics data sẽ được lưu trữ trên db có thể truy vấn cách dễ dàng</li></ul><ul id="a11267fe-1172-41da-a484-08cc525f5871" class="bulleted-list"><li style="list-style-type:disc"><strong>Rate limiting</strong>: bảo vệ hệ thống khỏi overload, và những vấn đề bảo mật không mong muốn  </li></ul></div></p><p id="b4dc54ca-0df6-45ef-9665-e45ea7434beb" class="">
</p></details></li></ul><ul id="c0299577-c0db-4f1c-a1ed-945d4f7907c0" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>HTTP status codes</strong></mark></summary><ul id="b1f2eb66-b5a7-49cb-8ef2-3ce123a5b245" class="bulleted-list"><li style="list-style-type:disc">1xx Informational</li></ul><ul id="c8dee246-ff7e-4af9-bfbf-0818d52334c5" class="bulleted-list"><li style="list-style-type:disc">2xx Succesful</li></ul><ul id="a9b990f7-0112-4c6a-bf2a-d54d87eb2d15" class="bulleted-list"><li style="list-style-type:disc">3xx Redirection</li></ul><ul id="82079f91-9fc0-4dbb-b4d1-7c8caf27c928" class="bulleted-list"><li style="list-style-type:disc">4xx Client Error</li></ul><ul id="0b90738d-2579-4073-ace6-3a8a885478be" class="bulleted-list"><li style="list-style-type:disc">5xx Server Error</li></ul></details></li></ul><ul id="5fe9b4e4-50af-4899-887c-4613c8eb2ffa" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Xử lý đồng thời và xử lý song song</strong></mark></summary><p id="9e476c90-2b66-444a-81c9-a7d40b7abc78" class=""><a href="https://zalopay-oss.github.io/go-advanced/ch1-basic/ch1-05-concurrency-parallelism.html">https://zalopay-oss.github.io/go-advanced/ch1-basic/ch1-05-concurrency-parallelism.html</a></p><ul id="f3c96b9b-5511-4d65-b20a-81f57a5ab993" class="bulleted-list"><li style="list-style-type:disc"><strong>Xử lý đồng thời</strong> là khả năng phân chia và điều phối nhiều tác vụ khác nhau trong cùng một khoảng thời gian và tại một thời điểm chỉ có thể xử lý một tác vụ. Khái niệm này trái ngược với <strong>xử lý tuần tự</strong> (sequential processing). <ul id="1ed2aef3-386a-4bf2-b06e-bc0f92779ccb" class="bulleted-list"><li style="list-style-type:circle"><strong>Xử lý tuần tự </strong>là khả năng xử lý chỉ một tác vụ trong một khoảng thời gian, các tác vụ sẽ được thực thi theo thứ tự hết tác vụ này sẽ thực thi tiếp tác vụ khác.</li></ul></li></ul><ul id="4d91131b-f633-475b-ae69-c006bfa7d402" class="bulleted-list"><li style="list-style-type:disc"><strong>Xử lý song song</strong> là khả năng xử lý nhiều tác vụ khác nhau trong cùng một thời điểm, các tác vụ này hoàn toàn độc lập với nhau. <ul id="4ec6df36-d19a-4265-8965-78e68634e986" class="bulleted-list"><li style="list-style-type:circle">Xử lý song song chỉ có thể thực hiện trên máy tính có số nhân lớn hơn 1. </li></ul><ul id="ffa71519-a404-4686-8b71-33e113b8255d" class="bulleted-list"><li style="list-style-type:circle">Thay vì một nhân CPU chúng ta chỉ có thể xử lý một tác vụ nhỏ tại một thời điểm thì khi số nhân CPU có nhiều hơn chúng ta có thể xử lý các tác vụ song song với nhau cùng lúc trên các nhân CPU.</li></ul></li></ul></details></li></ul><ul id="dee072b8-6a77-451a-b5b0-f97e1bff4bbd" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Processes &amp; Threads</strong></mark></summary><ul id="c7cf3a59-e23c-4614-9652-9a8a76d8cd81" class="bulleted-list"><li style="list-style-type:disc"><strong><strong>Process</strong></strong><ul id="451abf1d-8a98-4241-9543-eec0401060af" class="bulleted-list"><li style="list-style-type:circle">Tiến trình có thể hiểu đơn giản là một chương trình đang chạy trong máy tính. </li></ul><ul id="48d13e20-82ce-467e-bcb8-03a23f0cdbfb" class="bulleted-list"><li style="list-style-type:circle">Khi chúng ta mở trình duyệt và truy cập một trang web thì đây được xem là một tiến trình. </li></ul><ul id="e2e8340a-8af9-4dd4-805f-0c3a4783cd59" class="bulleted-list"><li style="list-style-type:circle">Khi chúng ta viết 1 chương trình máy tính bằng ngôn ngữ lập trình như C, Java, hay Go, sau khi tiến hành biên dịch và chạy chương trình thì hệ điều hành sẽ cấp cho chương trình một không gian bộ nhớ nhất định, PID (process ID),... </li></ul><ul id="69861e37-ce3d-4101-b522-98a5361d1cf9" class="bulleted-list"><li style="list-style-type:circle">Mỗi tiến trình có ít nhất một luồng chính (main thread) để chạy chương trình, nó như là xương sống của chương trình vậy. Khi luồng chính này ngừng hoạt động tương ứng với việc chương trình bị tắt.</li></ul></li></ul><ul id="0da3d90e-f5fc-44aa-a280-6a9d91f8c6cb" class="bulleted-list"><li style="list-style-type:disc"><strong><strong>Thread</strong></strong><ul id="cd72457f-1943-45d6-bf70-9fd6f2e400d5" class="bulleted-list"><li style="list-style-type:circle">Thread hay được gọi là tiểu trình nó là một luồng trong tiến trình đang chạy. </li></ul><ul id="7ec6c1bb-9b7c-4138-be4f-414c1094aafc" class="bulleted-list"><li style="list-style-type:circle">Các luồng được chạy song song trong mỗi tiến trình và có thể truy cập đến vùng nhớ được cung cấp bởi tiến trình, các tài nguyên của hệ điều hành,...<figure id="9b090f3b-b6ae-444b-abe6-a3b59de28037" class="image"><a href="Interview%202022%20ebbb49968bb44ce383e25229617a7796/Screen_Shot_2022-05-05_at_11.08.21.png"><img style="width:336px" src="Interview%202022%20ebbb49968bb44ce383e25229617a7796/Screen_Shot_2022-05-05_at_11.08.21.png"/></a></figure></li></ul><ul id="ddb02690-d16e-4919-8003-80faeaccb058" class="bulleted-list"><li style="list-style-type:circle">Các thread trong process sẽ được cấp phát riêng một vùng nhớ <code>stack</code> để lưu các biến riêng của thread đó. </li></ul><ul id="de3b1adc-8c61-4492-9ad2-7819370cef61" class="bulleted-list"><li style="list-style-type:circle">Stack được cấp phát cố định khoảng <code>1MB-2MB</code>. Ngoài ra các thread chia sẻ chung vùng nhớ <code>heap</code> của process. </li></ul><ul id="d11444d7-428f-4d78-adef-f250a636a6fb" class="bulleted-list"><li style="list-style-type:circle">Khi process tạo quá nhiều thread sẽ dẫn đến tình trạng <a href="https://en.wikipedia.org/wiki/Stack_overflow">stack overflow</a>. Khi các thread sử dụng chung vùng nhớ sẽ dễ gây ra hiện tượng <a href="https://en.wikipedia.org/wiki/Race_condition">race condition</a>. </li></ul></li></ul><p id="1345f352-42bf-48c6-a201-fa107b9a07c6" class=""><a href="https://zalopay-oss.github.io/go-advanced/ch1-basic/ch1-05-concurrency-parallelism.html">https://zalopay-oss.github.io/go-advanced/ch1-basic/ch1-05-concurrency-parallelism.html</a></p><p id="56335dbc-c6ed-4bb3-91e9-6ca8cd59ada1" class=""><a href="https://stackoverflow.com/questions/200469/what-is-the-difference-between-a-process-and-a-thread/200543#200543">https://stackoverflow.com/questions/200469/what-is-the-difference-between-a-process-and-a-thread/200543#200543</a></p></details></li></ul><ul id="2a9737ea-63c1-4c5e-b7d1-1d10bdfa2a1d" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>CI/CD</strong></mark></summary><ul id="717098ba-05f6-424c-bd69-32cbd98d1fbb" class="bulleted-list"><li style="list-style-type:disc"><strong>CI</strong> là Continuous Integration. Nó là phương pháp phát triển phần mềm yêu cầu các thành viên của team tích hợp công việc của họ thường xuyên, mỗi ngày ít nhất một lần. <ul id="59636cd6-d027-4720-9118-74e6c50bd29d" class="bulleted-list"><li style="list-style-type:circle">Mỗi tích hợp được “build” tự động (bao gồm cả test) nhằm phát hiện lỗi nhanh nhất có thể. </li></ul><ul id="9fe9497c-ea80-4c91-801c-f4db5c52ef77" class="bulleted-list"><li style="list-style-type:circle">Cả team nhận thấy rằng cách tiếp cận này giảm thiểu vấn đề tích hợp và cho phép phát triển phần mềm nhanh hơn.</li></ul></li></ul><ul id="1f8e3367-48ea-4d38-859c-18e69ecd11d2" class="bulleted-list"><li style="list-style-type:disc">Nếu CI đảm nhận nhiệm vụ xây dựng và kiểm tra một cách tự động thì CD lại có nhiệm vụ cao hơn một chút. CD được viết tắt bởi Continuous Delivery - chuyển giao liên tục. <ul id="b41ee7ac-bd31-4a7c-96ac-f6e58a322d1b" class="bulleted-list"><li style="list-style-type:circle">Đây là quá trình nâng cao hơn chút đó là kiểm tra tất cả những thay đổi về code đã được build và code trong môi trường kiểm thử. </li></ul><ul id="5e07e755-34fc-4394-a4d5-a9aee6615c53" class="bulleted-list"><li style="list-style-type:circle">CD cho phép các lập trình viên tự động hóa phần mềm testing, kiểm tra phần mềm qua nhiều thước đo trước khi triển khai.</li></ul><ul id="01f97c8a-c028-4399-893d-d107a07ec734" class="bulleted-list"><li style="list-style-type:circle">Những bài test này có thể bao gồm UI testing, <a href="https://itnavi.com.vn/blog/integration-testing-la-gi/">integration testing</a>, API testing,... CD sử dụng Deployment Pipeline giúp chia quy trình chuyển giao thành các giai đoạn. </li></ul><ul id="28e97d9d-8537-46be-bfbb-e1371ed2ce31" class="bulleted-list"><li style="list-style-type:circle">Mỗi giai đoạn có những mục tiêu riêng để xác minh chất lượng của các tính năng từ một góc độ vô cùng khác để có thể kiểm định được chức năng và tránh những lỗi phát sinh ảnh hưởng đến người dùng.</li></ul></li></ul><ul id="55af56f6-10a2-4518-b42a-1b9d4b331af1" class="bulleted-list"><li style="list-style-type:disc">Trên thực tế thì <strong>CI/CD</strong> là một quy trình làm việc, code của bạn sẽ được build test và sau đó deploy trên server hoặc cloud một cách tự động luôn.</li></ul></details></li></ul><ul id="944da7d7-29ca-4529-b1eb-57dd1514ac00" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Docker</strong></mark></summary><ul id="27518bb2-14e6-434d-b5b3-de05901e385f" class="bulleted-list"><li style="list-style-type:disc"><strong>Khái niệm</strong>:<ul id="90b8f340-b760-4bd6-adf1-27ce25acf1f4" class="bulleted-list"><li style="list-style-type:circle">Docker là một nền tảng để cung cấp cách để building, deploying và running ứng dụng dễ dàng hơn bằng cách sử dụng các containers (trên nền tảng ảo hóa) để đóng gói ứng dụng.</li></ul><ul id="9e869374-fa44-466e-8116-fe5e19cc8c25" class="bulleted-list"><li style="list-style-type:circle">Docker sử dụng công nghệ ảo hóa containerization để triển khai các ứng dụng vào trong container ảo hóa.</li></ul><ul id="1aaa6320-e267-40fa-85d0-ace52948d857" class="bulleted-list"><li style="list-style-type:circle">Docker sử dụng nhân kernel linux để chạy các container, trên hệ điều hành Linux, Docker có thể sử dụng trực tiếp nhân của máy host; còn với các hệ điều hành Windows, MacOS – có thể vì lý do bảo mật nên docker không thể trực tiếp xài chung kernel với các hệ điều hành này nên trên các hệ điều hành này docker sẽ tạo ra một máy ảo virtual guest với nhân linux để chạy các container.</li></ul><ul id="378d2540-2c43-461e-adf7-deefd035f7f9" class="bulleted-list"><li style="list-style-type:circle">Container là đơn vị phần mềm cung cấp cơ chế đóng gói ứng dụng, mã nguồn, thiết lập, thư viện... vào một đối tượng duy nhất. Ứng dụng sau khi được đóng gói có thể hoạt động một cách nhanh chóng và hiệu quả trên các môi trường điện toán khác nhau. Từ đó nó có thể tạo ra một môi trường hoàn hảo nơi mà có mọi thứ để chương trình có thể hoạt động được, không chịu sự tác động từ môi trường của hệ thống cũng như không làm ảnh hưởng ngược lại về phía hệ thống chứa nó.</li></ul></li></ul><ul id="6a665977-8b72-4314-b8f7-fab5d98ed679" class="bulleted-list"><li style="list-style-type:disc"><strong>Docker gồm có 3 thành phần chính:</strong><ul id="9499d2b2-f839-48e7-b543-3c944cf36321" class="bulleted-list"><li style="list-style-type:circle"><strong>Docker file: l</strong>à một file dạng text không có phần đuôi mở rộng, chứa các đặc tả về một trường thực thi phần mềm, cấu trúc cho Docker image. Docker image có thể được tạo ra tự động bằng cách đọc các chỉ dẫn trong Dockerfile. Từ những câu lệnh đó, Docker sẽ build ra Docker image</li></ul><ul id="d4d0f20f-dcae-4422-820e-b42a8ed3d8dc" class="bulleted-list"><li style="list-style-type:circle"><strong>Image:</strong> là 1 đơn vị đóng gói chứa mọi thứ cần thiết để 1 ứng dụng chạy. Image được tạo thành từ nhiều layer xếp chồng lên nhau, bên trong image là 1 hệ điều hành bị cắt giảm và tất cả các phụ thuộc (dependencies) cần thiết để chạy 1 ứng dụng.</li></ul><ul id="ca1ac385-129e-45a2-8205-e3282618d04b" class="bulleted-list"><li style="list-style-type:circle"><strong>Container:</strong> là đơn vị phần mềm cung cấp cơ chế đóng gói ứng dụng, mã nguồn, thiết lập, thư viện... vào một đối tượng duy nhất. Ứng dụng sau khi được đóng gói có thể hoạt động một cách nhanh chóng và hiệu quả trên các môi trường điện toán khác nhau. Từ đó nó có thể tạo ra một môi trường hoàn hảo nơi mà có mọi thứ để chương trình có thể hoạt động được, không chịu sự tác động từ môi trường của hệ thống cũng như không làm ảnh hưởng ngược lại về phía hệ thống chứa nó.</li></ul></li></ul><p id="937834ff-35a9-449c-a7ed-57fa6c1734cc" class="">Mỗi container bao gồm mọi thứ cần thiết để chạy được nó: code, runtime, system tools, system libraries, setting. Mỗi container như 1 hệ điều hành thực sự, bên trong mỗi container sẽ chạy 1 ứng dụng</p></details></li></ul><ul id="87c06a02-58cf-4c49-9434-9c7bbc33a2ab" class="toggle"><li><details open=""><summary><strong>How work when clicking to url on browser?</strong></summary><p id="d51afc1d-b449-4df1-9f28-fdbd0759943d" class="">Làm thế nào một trang web khi truy cập bằng địa chỉ url (Ví dụ: <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgoogle.com%2F%3Ffbclid%3DIwAR03_V9cf917kqqfNq7dDzlp1YXZBg_P1EYP92m7RbCpST3zuHcTyGonduU&amp;h=AT17tX8oibgdPcu6V-4bbZ2kKmxz6xuYHvcmhIRAZiuzncytRsDjXms8UO5m8T94nSpxxQsbny-xu0thkunE9zr8NEQBgAhr_hSBUjZUKneWfPnXryY6BcDZKS91j9pwIamOumj7hQ&amp;__tn__=-UK-y-R&amp;c[0]=AT3ky3xYZTuqe1v9jH66i26DAda2I3MEpc7Kk6qlTSTW8Jzec-xgrAQ8z9E3Jlc9QIl1xjdDUXU70BnUu8Sd9-KISqTMxFyipcPGUPMgQe6nYT_-RY0KH21Am6y_E7h5QAk5ILWvxx7TDHkJ3S75vBTgNW9IubOyMKsYqyQBBNzWFz3B57QJ7wQlO1mvXbjkTs3YlzDtJ4C_txnF">https://google.com/</a>) lại có thể hiển thị được. Khi anh em bật trình duyệt lên, nhập địa chỉ một trang web (Ví dụ: <a href="https://google.com/?fbclid=IwAR1QkfKmXAPu02yzUiwSMcqAbTLofT8N78tsR39sfOGIhGL_qma4OiJWoNI">https://google.com/</a>) và bấm Enter, vài giây sau nội dung của trang web sẽ được hiện ra trên trình duyệt. Quá trình đó được tóm tắt như sau:</p><ol type="1" id="317241a4-18bc-4eeb-8b3b-8800454b47ac" class="numbered-list" start="1"><li>Từ tên miền (Ví dụ: <a href="https://google.com/?fbclid=IwAR3A6BbYjuJ6WJ3YebVnwkereX588wn4XT60UJH7sJAf_DRc7aCW2DcnFLc">https://google.com/</a>) máy của anh em sẽ sử dụng DNS để tìm ra địa chỉ IP thực sự của web server tương ứng chứa website có tên miền đó (Ví dụ: <a href="https://google.com/?fbclid=IwAR0Q_LcK3OXF7wccucw3ld4gkgeK9yDnVksknMYjoFLaAGrLegSRtS_fDgE">https://google.com/</a> tương ứng với IP: <a href="https://l.facebook.com/l.php?u=http%3A%2F%2F142.251.10.99%2F%3Ffbclid%3DIwAR2SmrXZXqZ3WFOHICENQ-MxT7rY3rtaDWG03VEKLsI9OrWv-RAUZLOMQL8&amp;h=AT2Tollf7RrBYvRAizU6zqvy4TWrFnKfUy43vVYKbq1hetHjfpWRNKluli3RNYlV77E7eaRsjaCU7JtW1a2H18dilNPtsHhNBxiJ3im1h9nQSf-SCfRxPZHb2hl4q-cZMnvGGVuwlA&amp;__tn__=-UK-y-R&amp;c[0]=AT3ky3xYZTuqe1v9jH66i26DAda2I3MEpc7Kk6qlTSTW8Jzec-xgrAQ8z9E3Jlc9QIl1xjdDUXU70BnUu8Sd9-KISqTMxFyipcPGUPMgQe6nYT_-RY0KH21Am6y_E7h5QAk5ILWvxx7TDHkJ3S75vBTgNW9IubOyMKsYqyQBBNzWFz3B57QJ7wQlO1mvXbjkTs3YlzDtJ4C_txnF">142.251.10.99</a>).</li></ol><ol type="1" id="5b89004d-30aa-4238-8063-1e83fad3bf11" class="numbered-list" start="2"><li>Sau khi đã tìm được địa chỉ IP, trình duyệt sẽ gửi gói tin yêu cầu – HTTP request đến địa chỉ của web server, yêu cầu trả về nội dung trang web. Gói tin yêu cầu đó cũng như tất cả các gói tin, dữ liệu khác trao đổi giữa máy chủ với máy chúng ta (gọi là máy khách) được thực hiện qua một bộ giao thức TCP/IP.</li></ol><ol type="1" id="880f826b-e4c5-4df7-94ab-3f691f137695" class="numbered-list" start="3"><li>Khi nhận được yêu cầu từ máy khách, máy chủ sẽ tiến hành trả về các tập tin HTML, CSS, JS,... để hiển thị trên trình duyệt. Các tập tin này có thể được chia thành nhiều gói tin (packets) nhỏ và gửi về cho trình duyệt của người dùng đang ở máy khách.</li></ol><ol type="1" id="339f9aaf-5e3c-4d10-9ef7-67ae781dd4f9" class="numbered-list" start="4"><li>Khi nhận được, trình duyệt sẽ ghép những gói tin nhỏ nhận được thành những tập tin hoàn chỉnh và hiển thị lên màn hình. Như thế là chúng ta có một trang web hoàn chỉnh.</li></ol></details></li></ul><p id="524a12ba-a278-4c91-8d83-4ce0ab2e27a4" class="">
</p></details></li></ul><ul id="56491c4f-dd00-44f4-adba-277b95996ab9" class="toggle"><li><details open=""><summary><strong>GIT</strong></summary><ul id="1037e926-6981-4f7e-8076-54c9829b18a9" class="toggle"><li><details open=""><summary><strong>Difference between git fetch and git pull?</strong></summary><ul id="260ca37c-9264-4ea8-a006-a6863332a325" class="bulleted-list"><li style="list-style-type:disc">The Git fetch command only downloads new data from a remote repository.</li></ul><ul id="15badb8a-c114-4f29-a0d0-74f7674b7816" class="bulleted-list"><li style="list-style-type:disc">Git pull updates the current branch with the latest changes from the remote server.</li></ul></details></li></ul><ul id="3f3f2051-49df-44d0-852b-9f370c67e167" class="toggle"><li><details open=""><summary><strong>rebase ≠ revert</strong></summary></details></li></ul></details></li></ul><p id="884cf35e-3e57-4c92-a895-c18dede0f115" class="">
</p><p id="604ab4c9-99cb-47bf-90c4-e181bbcfdbe5" class=""><a href="https://blog.it-club.ge/interview-questions-junior-developer">https://blog.it-club.ge/interview-questions-junior-developer</a></p><p id="97591311-d97b-4e45-96ca-6a386667c06e" class="">
</p><p id="75fc5455-7092-4bc0-8ef9-1afa6b5b4237" class=""><strong>VNG interview</strong></p><ul id="5e4c4cb4-6566-4938-874b-7dca9ca894b0" class="bulleted-list"><li style="list-style-type:disc">kiểm tra số chính phương</li></ul><ul id="cb3453c0-64ff-43d0-90f4-4c1391f8f4da" class="bulleted-list"><li style="list-style-type:disc">kiểm tra có 2 kí tự liên tiếp trong 1 string ko, có thì swap 2 kí tự đó Data structure hỏi LL</li></ul><ul id="760790cf-37e6-47ae-9018-f95cbac4bfe3" class="bulleted-list"><li style="list-style-type:disc">quick sort vs merge sort, complexity, binary search tree</li></ul><ul id="246fc9db-2784-448d-ab6d-5f78cc95ad56" class="bulleted-list"><li style="list-style-type:disc">khi nào dùng LL/array</li></ul><ul id="01d68aab-6128-4e43-8dca-242a4afd7444" class="bulleted-list"><li style="list-style-type:disc">OOP hỏi có biết design pattern nào ko?, mình quất ngay singleton 4 characteristic của OOP, polimorphisim, static var, phần cuối cùng là statistic</li></ul><ul id="0b18a476-0028-4778-bcca-16dc192fbc60" class="bulleted-list"><li style="list-style-type:disc">phân biệt mean, mode, median, khi nào sài 3 cái đó</li></ul><ul id="3be80143-9640-4eba-af7e-1128f4c002e1" class="bulleted-list"><li style="list-style-type:disc">cách phân biệt dữ liệu phân tán, tập trung, linear regression vs logistic regression, standard deviation</li></ul><p id="42c7d028-0488-41bc-a16f-4c1ce1bfdea1" class="">
</p><p id="25014a98-8141-47e0-b64b-d733a44ab01d" class="">
</p><p id="1b1d43f2-7dcb-4859-b9ac-ce667534d00f" class="">
</p><ul id="e27ae935-eadc-4cc3-abca-69703271484e" class="bulleted-list"><li style="list-style-type:disc">Cách thiết kế LRU cache</li></ul><ul id="d132c703-a5c6-4bb5-8a78-d71f0c7c1298" class="bulleted-list"><li style="list-style-type:disc">Cách thiết kế bit.ly, rút gọn link</li></ul><p id="7b8bc8d6-39f5-460c-9818-9ca4e4735836" class="">
</p></div></article></body></html>