<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Tổng hợp câu hỏi PV FE REACT</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-opaquegray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="655e3ea1-fce4-47a7-8bed-f5e70db3a386" class="page sans"><header><h1 class="page-title">Tổng hợp câu hỏi PV FE REACT</h1></header><div class="page-body"><hr id="1662c6df-b5a5-41fa-a78f-952237c79184"/><p id="73a4f3fe-22ff-4190-a4b6-a2542fd9ae7d" class="">
</p><h2 id="1c004c09-5b6e-4a81-b2bc-8588ec2202a8" class=""><mark class="highlight-red">HTML</mark></h2><hr id="0516aad7-978f-4cd2-9c0b-16f6fee418f0"/><ul id="e3bec5d3-92ce-48e4-a43a-b0614c63eb2e" class="toggle"><li><details open=""><summary><strong>DOCTYPE là gì ?</strong></summary><ul id="53fb915c-76b6-4e69-b0dd-a363a21e4d76" class="bulleted-list"><li style="list-style-type:disc">là dòng mã đầu tiên được yêu cầu trong HTML</li></ul><ul id="f7adb2cc-311a-4dce-ae3c-b811eb6d899a" class="bulleted-list"><li style="list-style-type:disc">hướng dẫn trình duyệt về phiên bản HTML</li></ul><ul id="8449a03b-fef1-44e4-8841-3325d6944497" class="bulleted-list"><li style="list-style-type:disc">đảm bảo trang web được phân tích cú pháp giống nhau bởi trình duyệt khác nhau.</li></ul></details></li></ul><ul id="f60cc4b8-6da9-468f-88c2-e72055e11474" class="toggle"><li><details open=""><summary><strong>Thuộc tính DATA_? là gì  ?</strong></summary><ul id="87b951af-b89d-4e66-8a7a-18f6c386661b" class="bulleted-list"><li style="list-style-type:disc">cho phép lưu trữ thêm thông tin dữ liệu trong DOM</li></ul><ul id="50bdaac1-1b84-4050-aac4-01b920496d27" class="bulleted-list"><li style="list-style-type:disc">get data → getAttribute trong JS</li></ul><ul id="b39633e8-0764-4f77-a86e-95b39597caf6" class="bulleted-list"><li style="list-style-type:disc">set data → setAttribute trong JS </li></ul></details></li></ul><ul id="d82391e6-454c-494e-a5ec-75fe4573d56f" class="toggle"><li><details open=""><summary><strong>Cách set nhiều ngôn ngữ trên trang ?</strong></summary><ul id="adc71d4b-359a-491b-ad93-81fbb5b2cf10" class="bulleted-list"><li style="list-style-type:disc">dùng thuộc tính <mark class="highlight-red"><strong>lang</strong></mark> trong thẻ html</li></ul></details></li></ul><ul id="eb867f4e-8791-4f7b-8e61-6b63ae039d49" class="toggle"><li><details open=""><summary><strong>HTML SEMANIC là gì ?</strong></summary><ul id="783c935c-0436-4898-bf25-d339bc5c11d7" class="bulleted-list"><li style="list-style-type:disc">sử dụng thẻ thích hợp nhất cho các nhiệm vụ hiện có</li></ul><ul id="c6625c4a-c3a6-48e7-a56e-f0e059504989" class="bulleted-list"><li style="list-style-type:disc">sử dụng những phần tử có ý nghĩa như form, article, table, thay vì sử dụng div hay span</li></ul></details></li></ul><ul id="ca9bd142-3653-4472-96c8-12af642d517c" class="toggle"><li><details open=""><summary><strong>WEB ACCESSIBILITY?</strong></summary><ul id="5c117830-db45-4480-aa07-aa9dd3c58027" class="bulleted-list"><li style="list-style-type:disc">đảm bảo web có thể sử dụng cho người khuyết tất</li></ul></details></li></ul><ul id="00304a68-3a1e-434e-a5a3-585529d12ed9" class="toggle"><li><details open=""><summary><strong>Element ≠ attribute ?</strong></summary><ul id="298e3cb7-dc79-4471-99be-ac7c45e8ebcb" class="bulleted-list"><li style="list-style-type:disc"><strong>element</strong> trong HTML là các thẻ như: div, span, a, img, …</li></ul><ul id="1221b5e4-8a5f-4254-bffe-9fc2d995508e" class="bulleted-list"><li style="list-style-type:disc"><strong>attribute </strong>dùng để mô tả đặc điểm của element như: src, class, id</li></ul></details></li></ul><ul id="601dff6e-afdb-4324-b77b-c2e04c76f459" class="toggle"><li><details open=""><summary><strong>display: none ≠ visibility: hidden</strong></summary><ul id="b45bcd88-7f4c-460c-80db-9e8e7181966e" class="bulleted-list"><li style="list-style-type:disc">cả 2 đều dùng để ẩn element</li></ul><ul id="21dc32a5-ec24-459a-985b-7a6aa219e396" class="bulleted-list"><li style="list-style-type:disc">none sẽ ẩn đi hoàn toàn element và không chiếm không gian trong giao diện</li></ul><ul id="50a611f0-71d7-4b82-9d52-8a282a18ec0c" class="bulleted-list"><li style="list-style-type:disc">hidden chỉ ẩn đi nhưng vẫn chiếm không gian trên giao diện</li></ul></details></li></ul><ul id="aaf5bfe9-5a1b-44d1-bb31-f5977ccf4a42" class="toggle"><li><details open=""><summary><strong>&lt;Script/&gt;, &lt;Script async/&gt;, &lt;Script defer/&gt;</strong></summary><p id="f84dc11e-2789-4570-beb3-51955d67547f" class="">Khi tải trang HTML sẽ có 2 điều chỉnh được thực hiện:<div class="indented"><ul id="7aed032b-6ddf-4273-a44c-0e8b591e4955" class="bulleted-list"><li style="list-style-type:disc">Chuyển đổi HTML</li></ul><ul id="b5664af2-1988-45b8-a9e5-052d885b5a95" class="bulleted-list"><li style="list-style-type:disc">Tải các đoạn script</li></ul></div></p><ul id="9f242454-f9e3-4dfb-b8ff-c542f56fd58c" class="bulleted-list"><li style="list-style-type:disc">&lt;Script/&gt;: thực hiện tuần tự, chặn phân tích HTML → nạp script → thực thi → phân tích lại HTML sau khi thực thi xong</li></ul><ul id="98a77969-c9a1-4b2c-b41e-08b5cf282b23" class="bulleted-list"><li style="list-style-type:disc">&lt;Script async/&gt;: thực hiện không đồng bộ → không chặn phân tích cú pháp HTML</li></ul><ul id="6466f435-1560-4822-b30f-ab451db0ea77" class="bulleted-list"><li style="list-style-type:disc">&lt;Script defer/&gt;: phân tích cú pháp HTML xong rồi mới thực thi script</li></ul></details></li></ul><ul id="a85894ad-b335-4a05-8787-f9fc0b382163" class="toggle"><li><details open=""><summary><strong>DOM là gì?</strong></summary><ul id="4a4a30ca-d131-4991-b076-12d94983a70b" class="bulleted-list"><li style="list-style-type:disc">Là 1  api cho HTML, XML</li></ul><ul id="b131a75b-d0e3-4fda-a351-aea91101577c" class="bulleted-list"><li style="list-style-type:disc">Đại diện các HTML, XML dưới dạng các node và object , có thể sử dụng thông qua JS</li></ul><ul id="6d7fa1a4-1140-4188-b873-9faef1c310d0" class="bulleted-list"><li style="list-style-type:disc">Có cấu trúc dạng tree và mỗi element trên dom là một node</li></ul></details></li></ul><ul id="93046d0f-5159-454e-b478-0f76f122180c" class="toggle"><li><details open=""><summary><strong>Bố cục HTML</strong></summary><ul id="1de254c6-63c5-4ba4-8ce3-d7e05259b74c" class="bulleted-list"><li style="list-style-type:disc">HTML5 giới thiệu 1 số thẻ giúp chúng ta có thể định nghĩa bố cục trang web một cách rõ ràng hơn như:<ul id="2d7b858d-b149-4c14-aa99-5aaa0a1da582" class="bulleted-list"><li style="list-style-type:circle"><code><strong>&lt;header&gt;</strong></code>: Lưu trữ thông tin bắt đầu về trang web.</li></ul><ul id="7878cd65-fb27-4882-9b51-e8196b2bdbb4" class="bulleted-list"><li style="list-style-type:circle"><code><strong>&lt;footer&gt;</strong></code>: Biểu diễn phần cuối cùng của trang.</li></ul><ul id="48755661-0a29-417a-9088-c4e01c5fa97f" class="bulleted-list"><li style="list-style-type:circle"><code><strong>&lt;nav&gt;</strong></code>: Menu điều hướng của trang HTML.</li></ul><ul id="3ca89e4f-8ccc-49a8-bb09-b91c32c78b85" class="bulleted-list"><li style="list-style-type:circle"><code><strong>&lt;article&gt;</strong></code>: Nó là một tập hợp thông tin.</li></ul><ul id="47645042-2e2b-40ba-970d-5b02cc775f73" class="bulleted-list"><li style="list-style-type:circle"><code><strong>&lt;section&gt;</strong></code>: Nó được sử dụng bên trong <code>article</code> để xác định cấu trúc cơ bản của một trang.</li></ul><ul id="495d471a-6dc5-409f-84e5-bb2205637bcc" class="bulleted-list"><li style="list-style-type:circle"><code><strong>&lt;aside&gt;</strong></code>: Nội dung menu dọc của trang.</li></ul></li></ul></details></li></ul><ul id="c6c4d898-af26-4a8d-99cc-0488f245e818" class="toggle"><li><details open=""><summary><strong>Cách tối ưu hiệu suất tải trang web</strong></summary><ul id="c14d36c7-2380-4194-916d-e45a8fcd7b4c" class="bulleted-list"><li style="list-style-type:disc">Lưu trữ CDN → giảm độ trễ</li></ul><ul id="f5ef2343-85cf-47ee-8e50-1ee9c7d7c99c" class="bulleted-list"><li style="list-style-type:disc">Nén tập tin → giảm kích thước nội dung → tăng tốc độ truyền dữ liệu</li></ul><ul id="152fc2fe-b84f-49b3-bf42-9cac61b1132a" class="bulleted-list"><li style="list-style-type:disc">Nối tập tin → giảm số lượng request được gọi</li></ul><ul id="bffb682a-f9a1-47c0-a24f-025a397c9114" class="bulleted-list"><li style="list-style-type:disc">Giảm thiểu (minify) tập lệnh: giảm kích thước tệp JS, CSS</li></ul><ul id="25cd5efa-55bd-43dc-9ad7-f18128bcb6fc" class="bulleted-list"><li style="list-style-type:disc">Lazy loading: tải nội dung cần thiết</li></ul></details></li></ul><ul id="00b083b8-7329-4c7b-8c9f-e3bc9ebb1afb" class="toggle"><li><details open=""><summary><strong>Web worker là gì ?</strong></summary><ul id="0dadb8fe-1866-4581-a038-3af41f563196" class="bulleted-list"><li style="list-style-type:disc">JS đơn luồng, do đó những tác vụ lớn đòi hỏi tính toán phức tạp hoặc thời gian phản hồi lâu thì khả năng làm cho giao diện đơ cứng → Web worker ra đời và giải quyết vấn đề nói trên</li></ul><ul id="23a2b2b3-f0c7-4d5a-9726-11b545612a08" class="bulleted-list"><li style="list-style-type:disc">Web worker không phải của JS mà là tính năng của browser</li></ul><ul id="e1d38a32-9580-4c57-a9a1-b13b251dba31" class="bulleted-list"><li style="list-style-type:disc">Ta chỉ cần khởi tạo và truyền tham số đầu vào là file JS trong đó chứa các code cần xử lý</li></ul><ul id="622b7505-bf35-4523-b8ce-5fdd2d2f27ce" class="bulleted-list"><li style="list-style-type:disc">WW giúp thực thi song song với nhưng chạy dưới dạng background</li></ul><ul id="7a3f6b03-107f-4068-be3c-42ff451cbc72" class="bulleted-list"><li style="list-style-type:disc">WW là đa luồng</li></ul><ul id="03d6c559-b5be-4d3c-abdf-fb8f4415823a" class="bulleted-list"><li style="list-style-type:disc">Gồm 3 loại:<ul id="fc07fd1d-6e35-4c46-bcaf-81e41a56ef8c" class="bulleted-list"><li style="list-style-type:circle">Service worker</li></ul><ul id="3fdca8e2-33bd-446e-8e31-f5e39c173e7a" class="bulleted-list"><li style="list-style-type:circle">Shared worker</li></ul><ul id="b5531ad1-1b32-4cfd-972a-cfa6077d376d" class="bulleted-list"><li style="list-style-type:circle">Dedicated worker</li></ul></li></ul></details></li></ul><ul id="7a92a48a-e033-4905-9e94-96453b4c8d76" class="toggle"><li><details open=""><summary><strong>Thẻ &lt;a/&gt; và &lt;link/&gt; khác gì nhau ?</strong></summary><ul id="3b60be46-7b2b-4509-bc2f-dd78cea3ef5a" class="bulleted-list"><li style="list-style-type:disc">Thẻ &lt;a&gt; được dùng để mở liên kết đến trang web khác hay một phần nào đó ở web hiện tại nên nó có thể click vào. </li></ul><ul id="0e8fed7d-c104-490c-96f7-d3ab95fab9dd" class="bulleted-list"><li style="list-style-type:disc">Thẻ &lt;link&gt; xác định một liên kết đến một nguồn tài nguyên bên ngoài, nó không thể click.</li></ul></details></li></ul><ul id="e19e61d9-077b-4fb6-9768-ee4c7d503856" class="toggle"><li><details open=""><summary><strong>Khi nào sử dụng script ở header hoặc body</strong></summary><ul id="496fdfc5-e291-42c6-b861-e7a145cc1483" class="bulleted-list"><li style="list-style-type:disc">Nếu các script chứa các hàm event-trigger hoặc thư viện jquery thì nên đặt ở head.</li></ul><ul id="2848372f-9ba1-40e2-bdae-e46ae334c0cc" class="bulleted-list"><li style="list-style-type:disc">Nếu script viết nội dung hoặc không nằm trong hàm thì nên đặt ở cuối body. </li></ul><ul id="f2e05d3e-b0a3-4b7c-ab81-716b8c35d88c" class="bulleted-list"><li style="list-style-type:disc">Nói tóm lại có 3 điểm cần nhớ sau:<ul id="aab2d330-765e-46b8-9d50-a468688a3cdb" class="bulleted-list"><li style="list-style-type:circle">Đặt thư viện hoặc sự kiện script ở head.</li></ul><ul id="32bf84d9-8806-4bd7-a171-12faaad5c10a" class="bulleted-list"><li style="list-style-type:circle">Đặt script thông thường ở head cho đến khi có vấn đề gì đó về hiệu suất.</li></ul><ul id="100fa95f-143f-4382-ad9d-6172f48957b7" class="bulleted-list"><li style="list-style-type:circle">Đặt script hiển thị nội dung ở cuối body.</li></ul></li></ul></details></li></ul><ul id="adf909bf-430d-49fb-abad-5ba781694517" class="toggle"><li><details open=""><summary><strong>image ≠ figure </strong></summary><ul id="afa5c44f-5dac-40d4-a9f2-374f9a929462" class="bulleted-list"><li style="list-style-type:disc">Thẻ <code>&lt;figure&gt; </code>chỉ định nội dung như ảnh, sơ đồ, code snippets,...  được dùng để tổ chức các nội dung như ảnh, tiêu đề ảnh</li></ul><ul id="b59433cc-d668-4d47-b248-5faca3331b5d" class="bulleted-list"><li style="list-style-type:disc">Thẻ <code>&lt;img&gt;</code> dùng để nhúng một ảnh vào HTML5.</li></ul></details></li></ul><ul id="657362a6-700c-4606-8fdc-3b769b5d4d63" class="toggle"><li><details open=""><summary><strong>Manifest file là gì ?</strong></summary><ul id="393f8af0-46e4-4462-8ac8-2f42b20754ea" class="bulleted-list"><li style="list-style-type:disc">File manifest được sử dụng để liệt kê các tài nguyên có thể được lưu vào bộ nhớ đệm.</li></ul><ul id="6291f6ea-12a9-4c84-88b5-85f9b330b6d8" class="bulleted-list"><li style="list-style-type:disc">Trình duyệt sử dụng thông tin này để làm cho trang web tải nhanh hơn lần đầu tiên. </li></ul><ul id="001c06c7-1af6-42b6-bc9c-1b89a9061c44" class="bulleted-list"><li style="list-style-type:disc">Có 3 phần trong manifest:<ul id="66615300-8203-4971-8405-01634eb79333" class="bulleted-list"><li style="list-style-type:circle">CACHE Manifest - File cần lưu vào bộ đệm</li></ul><ul id="1a162a5d-b5ac-4473-9295-bdbd977659f1" class="bulleted-list"><li style="list-style-type:circle">Network - File không bao giờ lưu vào bộ đệm, cần kết nối mạng.</li></ul><ul id="88851d16-b4d6-401a-8a0c-478c18e1aac8" class="bulleted-list"><li style="list-style-type:circle">Fallback - File dự phòng trong trường hợp trang không tiếp cận được.</li></ul></li></ul></details></li></ul><ul id="9cee7d41-ae52-4927-aa50-98ad7ea6d6bd" class="toggle"><li><details open=""><summary>s<strong>rcset trong thẻ img là gì ?</strong></summary><ul id="f635e190-1afe-4459-8cea-e604b0888705" class="bulleted-list"><li style="list-style-type:disc">srcset cho phép bạn khai báo một tập hợp các hình ảnh sẽ được hiển thị trên các kích thước khung nhìn khác nhau. </li></ul><ul id="aece9dbc-5569-49ab-a67c-b6663ca37687" class="bulleted-list"><li style="list-style-type:disc">Bạn chỉ cần lưu và hình ảnh ở các độ phân giải khác nhau</li></ul><ul id="120394a3-99f6-47ab-8c19-66da131d4ea0" class="bulleted-list"><li style="list-style-type:disc">VD: img_small.png 200w, img_medium.png 500w, img_large.png 1000w</li></ul><ul id="d1178b72-96a2-425d-8264-3aaa08b50c60" class="bulleted-list"><li style="list-style-type:disc">và chúng được ngăn cách bởi dấy phẩy</li></ul></details></li></ul><ul id="bfab7930-5240-4981-9f7a-b240d1eda061" class="toggle"><li><details open=""><summary><strong>lazy loading là gì ? Các cách triển khai ?</strong></summary><ul id="f076b471-1504-42db-9121-f526d20e649f" class="bulleted-list"><li style="list-style-type:disc">là kỹ thuật ngăn trình duyệt tải tất cả các resource cùng 1 lúc, thay vào đó chỉ tải những resource cần thiết </li></ul><ul id="a661972a-d6cc-47c1-b714-c4385c37a8f3" class="bulleted-list"><li style="list-style-type:disc">Giúp tăng tốc độ tải trang, trải nghiệm người dùng cũng như tiết kiệm băng thông</li></ul><ul id="01933e8a-781a-4c9f-b86f-352fa4f6affd" class="bulleted-list"><li style="list-style-type:disc">Một số cách triển khai:<ul id="abe5ea0e-8fc3-4fb1-86f2-330b500ea3b4" class="bulleted-list"><li style="list-style-type:circle">Bắt sự kiện scroll → tạo data_src → scroll tới target thì copy data_src sang src</li></ul><ul id="1e3bf59f-a297-456b-b91e-fb836fda9f17" class="bulleted-list"><li style="list-style-type:circle">Dùng Intersection Observer API của browser</li></ul><ul id="919a680a-98ba-4f52-94c8-f4158cb1f317" class="bulleted-list"><li style="list-style-type:circle">Dùng thuộc tính loading trong thẻ image</li></ul><ul id="a5ff8376-90ef-4f64-9e4e-9ce6b885dc69" class="bulleted-list"><li style="list-style-type:circle">Sử dụng một số thư viện có sẵn</li></ul></li></ul></details></li></ul><p id="ca0d1140-e914-4734-a1b8-95396c64f797" class="">
</p><hr id="115c8701-38d3-4189-8390-cd0fdce6ac4f"/><h2 id="33402ea1-2733-47a3-8f01-2b3c96b71d3b" class=""><mark class="highlight-red">CSS</mark></h2><hr id="d171acad-2478-4b0b-bf07-39ecdefb544b"/><ul id="5b47ac25-d36c-490b-97c2-a51814d464c3" class="toggle"><li><details open=""><summary><strong>inline ≠ block ≠ inline-block trong display</strong></summary><ul id="e1c97792-80ad-4b94-a7cc-79d55494dd1d" class="bulleted-list"><li style="list-style-type:disc"><strong>inline</strong>: item nằm trên 1 dòng, vượt quá độ dài sẽ tự động xuống dòng. Chỉ điều chỉnh được margin và padding của left, right (span)</li></ul><ul id="67e5a4ac-bf03-426e-8d92-179f45522b0a" class="bulleted-list"><li style="list-style-type:disc"><strong>block</strong>: item luôn được xuống dòng và chiếm toàn bộ width nếu không được set. Ta điều chỉnh được margin, padding của cả 4 hướng (div)</li></ul><ul id="549d1f44-b450-4ba8-95e1-a3d1dcec9b82" class="bulleted-list"><li style="list-style-type:disc"><strong>inline-block</strong>: các item được sắp xếp trên cùng 1 hàng như inline nhưng sẽ có thuộc tính của block như có thể điều chỉnh 4 hướng của margin và padđing</li></ul></details></li></ul><ul id="3a58694c-8f39-42cd-a20e-801ef4d37aa5" class="toggle"><li><details open=""><summary><strong>BEM là gì ?</strong></summary><ul id="f7e5388a-ca46-4d04-875f-fef40daa7aba" class="bulleted-list"><li style="list-style-type:disc"><a href="https://www.notion.so/BEM-CSS-8ab91526913641aa962258d72bea2b83">BEM</a> viết tắt của Blocks, Elements, Modifiers, là một phương pháp đặt tên class cho HTML và CSS. </li></ul><ul id="2bf6444d-44d3-4b84-8261-dc1917b3660f" class="bulleted-list"><li style="list-style-type:disc">Được phát triển tại Yandex giúp lập trình viên hiểu rõ hơn mối quan hệ giữa HTML và CSS trong dự án front end</li></ul><pre id="fe39bb4e-0db6-4441-b212-a4cc0c173373" class="code"><code>/* Một Block (khối) độc lập */
.btn {}

/* Element (phần tử) con, phụ thuộc vào Block ở trên */
.btn__price {}

/* Modifier (bộ điều chỉnh) thay đổi trạng thái của Block hoặc Element */
.btn--orange {}
.btn--big {}
.btn__price--bold {}</code></pre></details></li></ul><ul id="6ef948e6-bcf1-4b4c-bfa1-e8837086607c" class="toggle"><li><details open=""><summary><strong>Box-model là gì ?</strong></summary><ul id="fa45500e-f53a-4c5c-964c-b89805d546a0" class="bulleted-list"><li style="list-style-type:disc">là một hộp chữ nhật bao quanh mọi element trong HTML</li></ul><ul id="9687028f-f508-48b2-87b5-1de7b677e1fa" class="bulleted-list"><li style="list-style-type:disc">được dùng để xác định chiều cao và rộng cảu </li></ul><ul id="ebfd031d-d170-4bd6-87a8-bef7eecfc370" class="bulleted-list"><li style="list-style-type:disc">CSS Box Model giống như là một cái hộp bao quanh element của chúng ta và trong đó có rất nhiều lớp dày mỏng khác nhau, các lớp dày mỏng đó bao gồm: margins, border, padding và cuối cùng là phần nội dung của chúng ta (text và ảnh).</li></ul><ul id="f014362b-45a8-43f5-8171-80d90ecf65df" class="bulleted-list"><li style="list-style-type:disc">Nó bao gồm:<ul id="f9db0b81-5f64-45f1-bc9d-1be2ed65dc25" class="bulleted-list"><li style="list-style-type:circle"><strong>Content:</strong> như đã nói ở trên đây là phần mà text và hình ảnh của chúng ta xuất hiện</li></ul><ul id="7122f145-58ec-4580-b201-e6399f0667aa" class="bulleted-list"><li style="list-style-type:circle"><strong>Padding:</strong> là một khoảng trống kế tiếp bọc xung quanh <strong>content</strong></li></ul><ul id="b0633cbb-9de3-4de1-814c-fa375264ef99" class="bulleted-list"><li style="list-style-type:circle"><strong>Border</strong>: phần khung bao bọc xung quanh <strong>padding</strong> và <strong>content</strong></li></ul><ul id="3189d1af-8cd8-4534-9de0-168339b1f212" class="bulleted-list"><li style="list-style-type:circle"><strong>Margin</strong>: cuối cùng, <strong>margin</strong> là phần ngoài cùng của Box Model, chỉ là một khoảng trống không màu</li></ul></li></ul></details></li></ul><ul id="aba28fbd-2f4c-4815-b6f8-3dfe9e6e02cc" class="toggle"><li><details open=""><summary><strong><strong>Sự khác biệt giữa các thuộc tính Box Sizing?</strong></strong></summary><ul id="fcad5c03-ef92-47e1-98f8-819d96b65750" class="bulleted-list"><li style="list-style-type:disc">Thuộc tính CSS box-sizing quy định cách tính tổng chiều rộng và chiều cao của một phần tử.<ul id="10e4fde7-1e3a-405a-8813-121e1b1ff057" class="bulleted-list"><li style="list-style-type:circle"><strong>Context-box:</strong> Giá trị chiều rộng và chiều cao mặc định chỉ áp dụng cho nội dung của phần tử. Padding và border nằm ở bên ngoài hộp.</li></ul><ul id="40d4a0c0-5f6b-4bc7-949b-4a90493184b4" class="bulleted-list"><li style="list-style-type:circle"><strong>Padding-box:</strong> Giá trị chiều rộng và chiều cao mặc định chỉ áp dụng cho nội dung của phần tử và padding của nó. Border nằm ở bên ngoài hộp. Hiện tại chỉ có Firefox hỗ trợ padding-box.</li></ul><ul id="8762ad5a-76d7-4b23-a1da-dd264e30a6aa" class="bulleted-list"><li style="list-style-type:circle"><strong>Border-box:</strong> Giá trị chiều rộng và chiều cao áp dụng cho nội dung, padding và border.</li></ul></li></ul></details></li></ul><ul id="24f061ca-8230-4fb7-9d3c-fa0ca42675f3" class="toggle"><li><details open=""><summary><strong><strong></strong></strong><code><strong><strong>* { box-sizing: border-box }</strong></strong></code><strong><strong> là gì?</strong></strong></summary><ul id="f97ac53b-b923-41e7-ac0d-925ed9a66e6f" class="bulleted-list"><li style="list-style-type:disc">Nó điều chỉnh tất cả phần tử có bao gồm padding, border trong không gian phần tử cho tính toàn chiều dài và chiều rộng.</li></ul><ul id="d78a544d-a96e-4913-94b6-ecdd114abe33" class="bulleted-list"><li style="list-style-type:disc">Trong <code>box-sizing: border-box</code>, chiều cao phần tử được tính toán với: height + padding dọc + độ dài border dọc. Còn chiều dài là width + padding ngang + độ dài border ngang.</li></ul></details></li></ul><ul id="14ab37fb-a2c0-4c01-9a13-a7143f73ba2f" class="toggle"><li><details open=""><summary><strong>CSS selector là gì ?</strong></summary><ul id="4cd30712-f55f-4eff-b638-f671b2049c90" class="bulleted-list"><li style="list-style-type:disc">CSS Selector giống như là đường đẫn, chỉ định để cho CSS biết bạn đang muốn điều chỉnh, tạo kiểu cho phần tử HTML nào vậy.</li></ul><ul id="d3babdb0-0dd7-4d07-8767-40ba8d5db86c" class="toggle"><li><details open=""><summary><strong><span style="border-bottom:0.05em solid">Một số loại selector:</span></strong></summary><ul id="3406cfc0-5418-4536-a7c6-b45303f8cb5f" class="bulleted-list"><li style="list-style-type:disc"><strong>Universal Selector:</strong> hoạt động như một ký tự đại diện cho tất cả phần tử trong trang. <pre id="07aaf6dd-d76d-4f56-a0a8-f508566d1fd4" class="code"><code>* {
    color: &quot;green&quot;;
}</code></pre></li></ul><ul id="67c85864-3a9b-4398-bbfd-86b2e4e8c91a" class="bulleted-list"><li style="list-style-type:disc"><strong>Element Type Selector: </strong>selector loại này ứng với một hoặc nhiều phần tử HTML cùng tên.<pre id="4c2cff69-2eae-4383-979a-847e2f069958" class="code"><code>ul {
    line-style: none;
}</code></pre></li></ul><ul id="15c53a2c-0d32-4578-a5b1-5e4429961071" class="bulleted-list"><li style="list-style-type:disc"><strong>ID Selector: </strong>selector này ứng với bất kỳ phần tử HTML nào có thuộc tính ID có cùng giá trị với giá trị của selector.<pre id="8ae59446-e1f4-49fa-a412-ad805c11f30f" class="code"><code>#container {
    width: 960px;
}</code></pre></li></ul><ul id="dd89275f-7586-42dc-84a8-eb561e55e106" class="bulleted-list"><li style="list-style-type:disc"><strong>Class Selector: </strong>tương tự như ID Selector nhưng thay vì ứng với ID thì nó ứng với thuộc tính class.<pre id="fbaae37a-0c79-477e-8466-31cdb2108909" class="code"><code>.box {
    padding: 10px;
}</code></pre></li></ul><ul id="96fa28aa-fb27-4b21-90c3-ea499cf94ede" class="bulleted-list"><li style="list-style-type:disc"><strong>Descendant Combinator: </strong>giúp bạn kết hợp hai hoặc nhiều selector để có thể chỉ định phần tử cụ thể.<pre id="3a653e87-82c2-4899-af88-1ad68c959dda" class="code"><code>#container .box {
	float: left;
}</code></pre></li></ul><ul id="228babb7-09f9-4c96-bbdb-964600745dde" class="bulleted-list"><li style="list-style-type:disc"><strong>Child Combinator: </strong>selector sử dụng bộ child combinator tương tự như descendant combinator, ngoại trừ việc nó chỉ nhắm đến các phần tử con.<pre id="b21e36b3-39ed-4299-a69a-2d51c2c5ec96" class="code"><code>#container&gt; .box {
	float: left;
	padding-bottom: 15px;
}</code></pre></li></ul><ul id="57bd2e7c-009e-47bf-b38e-409c3a97db50" class="bulleted-list"><li style="list-style-type:disc"><strong>General Sibling Combinator: </strong>selector này so với các phần tử có quan hệ anh chị em với phần tử tương ứng.<pre id="4db0d05f-d20d-46d9-9ed0-7a432631db18" class="code"><code>h2 ~ p {
	margin-bottom: 20px;
}</code></pre></li></ul><ul id="a309f1c1-6355-4fa5-aa80-103003d4a84f" class="bulleted-list"><li style="list-style-type:disc"><strong>Adjacent Sibling Combinator:</strong> selector sử dụng ký tự <code>+</code> và gần giống với General Sibling Combinator. Sự khác biệt là phần tử được nhắm phải là anh chị ruột thịt chứ không phải anh chị em chung chung.<pre id="f00da871-2ce2-497e-b167-66996bbc6ed4" class="code"><code>p + p {
	margin-bottom: 0;
}</code></pre></li></ul><ul id="f7aa01f5-7c1b-47ce-80df-0afbab7d01c4" class="bulleted-list"><li style="list-style-type:disc"><strong>Attribute Selector:</strong> nhắm đến các phần tử dựa trên sự xuất hiện và giá trị của thuộc tính HTML. Được khai báo bằng dấu ngoặc vuông.<pre id="f59063ef-71e0-4b2e-82fa-c8f5229e1829" class="code"><code>input [type=”text”] {
	width: 200px;
}</code></pre></li></ul></details></li></ul></details></li></ul><ul id="a728f30c-968e-4a05-83bd-c61b4b82c246" class="toggle"><li><details open=""><summary><strong>Có thể hiện thị 1 trang web trong 1 trang web khác không ?</strong></summary><ul id="7486e51e-5a69-47f5-9999-a3110841b14e" class="bulleted-list"><li style="list-style-type:disc">Có</li></ul><ul id="ce3b4c3b-00c3-4256-b02b-e4883f605f98" class="bulleted-list"><li style="list-style-type:disc">Sử dụng iframe để nhúng 1 web khác vào</li></ul><ul id="4e4adb2e-0fce-4fa2-baac-4840f64f89cc" class="bulleted-list"><li style="list-style-type:disc">Có thể nhúng 1 website, video hoặc image, …</li></ul></details></li></ul><ul id="96184043-dc66-4646-8923-f2aca51f31e3" class="toggle"><li><details open=""><summary><strong>z-index dùng để làm gì ?</strong></summary><ul id="4de7ecb5-1e86-48da-a6ce-b47315ac8a38" class="bulleted-list"><li style="list-style-type:disc">z-index được sử dụng để chỉ định cách xếp chồng theo chiều sâu của các phần tử chồng lên nhau xảy ra tại thời điểm định vị nó. </li></ul><ul id="d1a88a00-eb63-49e7-851d-555ba12e9e34" class="bulleted-list"><li style="list-style-type:disc">Nó chỉ định thứ tự ngăn xếp theo chiều sâu của các phần tử được định vị giúp xác định cách hiển thị các phần tử diễn ra như thế nào trong trường hợp chồng chéo.</li></ul></details></li></ul><ul id="2ae20ca5-d41e-4b10-af06-131ce1365674" class="toggle"><li><details open=""><summary><strong><strong>Sự khác biệt giữa reset và normalize CSS?</strong></strong></summary><ul id="6283cba5-0c0a-4381-a837-8cc3823327d9" class="bulleted-list"><li style="list-style-type:disc"><strong>Reset CSS:</strong> nhằm mục đích xoá tất cả thiết lập style mặc định từ trình duyệt. Ví dụ như margin, padding, font-size của tất cả phần tử đó được reset lại giống nhau.</li></ul><ul id="46dfc9be-62af-4b38-8faa-b95b8f028a32" class="bulleted-list"><li style="list-style-type:disc"><strong>Normalize CSS:</strong> nhằm mục đích làm cho các style mặc định nhất quán trên trình duyệt. Nó cũng sửa các lỗi phổ biến trên trình duyệt.</li></ul></details></li></ul><ul id="2695f320-591b-4026-9bc8-e098e2d742e6" class="toggle"><li><details open=""><summary><strong>Float là gì ?</strong></summary><ul id="2a0624d0-1e13-4278-a6dd-2319cf2ed3a3" class="bulleted-list"><li style="list-style-type:disc">dùng để định vị phần tử theo chiều ngang về bên trái hoặc phải</li></ul></details></li></ul><ul id="c418c843-ef1c-4477-8901-8b5d5d8de530" class="toggle"><li><details open=""><summary><strong><strong>Phần tử Pseudo và các lớp Pseudo là gì?</strong></strong></summary><ul id="a04771df-33ae-4de2-aace-f0c4fde88a99" class="bulleted-list"><li style="list-style-type:disc"><strong>Phần tử pseudo</strong> cho phép ta tạo các mục thường không tồn tại trong DOM.<ul id="af4e5853-7915-4d9a-83ae-1b0af3bb5f21" class="bulleted-list"><li style="list-style-type:circle">::before</li></ul><ul id="4b8b2791-6656-46e5-82e1-9d8fb4700b91" class="bulleted-list"><li style="list-style-type:circle">::after</li></ul><ul id="3358a0db-39bd-459f-8b79-16557eaf5169" class="bulleted-list"><li style="list-style-type:circle">::first-letter</li></ul><ul id="25df6672-f099-4266-989e-5fc44bc4d1dc" class="bulleted-list"><li style="list-style-type:circle">::first-line</li></ul><ul id="ea9f67c9-ac0f-495b-b523-f5049a1ad04e" class="bulleted-list"><li style="list-style-type:circle">::selection</li></ul></li></ul><ul id="6ce91f38-97d7-442b-bd23-d564fab35357" class="bulleted-list"><li style="list-style-type:disc"><strong>Lớp pseudo</strong> chọn các phần tử thông thường nhưng trong các điều kiện nhất định như khi người dùng di chuột qua liên kết.<ul id="32ea00a5-68d5-468c-a92d-612de21b9973" class="bulleted-list"><li style="list-style-type:circle">:link</li></ul><ul id="da39a375-485a-4117-97d2-b11ba8add65e" class="bulleted-list"><li style="list-style-type:circle">:visited</li></ul><ul id="51a5491e-892a-4c81-a4c9-f45a2a5de5dc" class="bulleted-list"><li style="list-style-type:circle">:hover</li></ul><ul id="5406eded-f623-4e1d-96f2-e146fb0adc92" class="bulleted-list"><li style="list-style-type:circle">:active</li></ul><ul id="54bf9541-205f-418a-8bd4-e9bc913c8e40" class="bulleted-list"><li style="list-style-type:circle">:focus</li></ul></li></ul></details></li></ul><ul id="3a29000a-f3e1-4e16-951c-38ec03cb1874" class="toggle"><li><details open=""><summary><strong>CSS sprite là gì ?</strong></summary><ul id="df33d195-3bd8-4bfa-af27-49a697e5b247" class="bulleted-list"><li style="list-style-type:disc">CSS Sprite dùng cho kết hợp nhiều hình ảnh thành một hình ảnh lớn. Nó thường dùng cho biểu diễn icons. Các ưu điểm của nó là:<ul id="70fa28ee-ac48-4c0a-ad4c-dcf32dbdf0e3" class="bulleted-list"><li style="list-style-type:circle">Giảm số lượng yêu cầu HTTP để lấy nhiều ảnh vì nó cho phép chỉ gửi một yêu cầu.</li></ul><ul id="0c6e2ad4-523d-42f6-9acd-51a1516cab00" class="bulleted-list"><li style="list-style-type:circle">Nó giúp tải trước các nội dung giúp hiển thị các icon hoặc hình ảnh khi di chuột và các pseudo-state khác.</li></ul><ul id="7eac11fa-2fda-41f9-bbe0-0de59e8cbd76" class="bulleted-list"><li style="list-style-type:circle">Khi có nhiều hình ảnh, trình duyệt sẽ thực hiện các lệnh gọi riêng biệt để lấy hình ảnh cho từng hình ảnh đó.</li></ul></li></ul></details></li></ul><ul id="24d4b29f-53ae-42f1-b034-d4aa0f30ae3a" class="toggle"><li><details open=""><summary><strong>Tích hợp css vào HTML có bao nhiêu cách ?</strong></summary><ul id="d35445eb-2b2c-479a-a1d3-de2d810ec4fe" class="bulleted-list"><li style="list-style-type:disc">inline: css trực tiếp trong element bằng thuộc tính style</li></ul><ul id="8bbc2e16-459a-4618-ac2c-4bbd4e077889" class="bulleted-list"><li style="list-style-type:disc">external: tạo 1 file css riêng và nhúng vào</li></ul><ul id="2e900fe9-ed1f-4b8f-a113-bdc2c8cc5be9" class="bulleted-list"><li style="list-style-type:disc">internal: style thông qua thẻ &lt;style&gt; đặc ở &lt;head&gt;</li></ul></details></li></ul><ul id="8ef92774-279a-4c26-9d86-d75a4c03e9fe" class="toggle"><li><details open=""><summary><strong><strong>Lợi thế của dùng translate() thay vì position absolute?</strong></strong></summary><ul id="3acf8265-0fa7-4995-a37f-5ffc81beee22" class="bulleted-list"><li style="list-style-type:disc">Translate() không làm cho trình duyệt kích hoạt repaint layout, mà chỉ thực hiện soạn thảo.</li></ul><ul id="6c69bd5e-f296-473c-8a46-8d3fa2f30db3" class="bulleted-list"><li style="list-style-type:disc">Còn position: absolute làm trình duyệt phải vẽ lại các luồng DOM. </li></ul><p id="7bfc041b-bd7b-4a68-bd17-f89509e20db5" class="">→ Thế nên <code>translate()</code> đem về hiệu suất tốt hơn</p></details></li></ul><ul id="1afbb6b3-8cf7-472c-84fc-4ca31b7f663a" class="toggle"><li><details open=""><summary><strong><strong>Liệu margin-top hoặc margin-bottom có ảnh hưởng đến các phần tử inline không?</strong></strong></summary><ul id="21147285-2871-428c-8aa3-c092bb385047" class="bulleted-list"><li style="list-style-type:disc">Không, nó không ảnh hưởng đến các phần tử inline. Các phần tử inline ở cùng dòng với nội dung của trang.<strong></strong></li></ul></details></li></ul><ul id="0ea33703-ca9e-4cd6-8bfc-7d7e6c943b17" class="toggle"><li><details open=""><summary><strong>Khi nào xảy ra DOM-reflow ?</strong></summary><ul id="cd2c6237-950c-49eb-ab27-4536e28cb1e3" class="bulleted-list"><li style="list-style-type:disc">Dom-reflow là quá trình browser tính toán lại vị trí và hình dạng của element trong document, nhằm mục đích hiển thị lại 1 phần hoặc toàn bộ DOM</li></ul><ul id="feae9668-6eba-4d10-8296-a4c0cb12c2cd" class="bulleted-list"><li style="list-style-type:disc">Reflow xảy ra khi: <ul id="a35b4687-eac2-4a57-a446-cfcf78eba588" class="bulleted-list"><li style="list-style-type:circle">Chèn, xóa, update element trong DOM</li></ul><ul id="fae25985-ea21-4b02-8c2f-9c754ff96ae1" class="bulleted-list"><li style="list-style-type:circle">Sửa đổi nội dung trang</li></ul><ul id="ea426f93-2cf4-4375-ae29-7a90a19c37e6" class="bulleted-list"><li style="list-style-type:circle">Thay đổi style css</li></ul></li></ul></details></li></ul><ul id="75dd8c72-a59e-4bbe-a8b7-af438728d5b4" class="toggle"><li><details open=""><summary><strong>Làm thế nào để căn giữa 1 thẻ p trong thẻ div ?</strong></summary><pre id="c5896923-5dfc-420f-be54-c7157595eb95" class="code"><code>&lt;div&gt;
	&lt;p&gt;Hello&lt;/p&gt;
&lt;/div&gt;</code></pre><pre id="fc9b9223-91cd-4483-bc33-66757b5bcff4" class="code"><code>// can giua theo chieu ngang
div {
	text-align: center;
}

// can giua theo chieu doc
div {
	position: relative;
	
	p {
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		margin: auto;
	}
}</code></pre></details></li></ul><ul id="7396d490-d86a-4ed3-9994-1a2961c9cfec" class="toggle"><li><details open=""><summary><strong><strong>Làm sao để căn giữa một div trong một div khác?</strong></strong></summary><ul id="ab431800-b7b6-4914-a937-2448414e8b44" class="toggle"><li><details open=""><summary>transform</summary><pre id="8f79ef68-d11b-41f4-b18b-1190c7657d5b" class="code"><code>.cn {
	position: relative;
	width: 500px;
	height: 500px;
}

.inner {
	position: absolute;
	top: 50%; left: 50%;
	transform: translate(-50%,-50%);
	width: 200px;
	height: 200px;
}</code></pre></details></li></ul><ul id="1cfa8274-fac8-4b36-9f74-c6a93a0fee13" class="toggle"><li><details open=""><summary>flex-box</summary><pre id="d5e00981-099b-4908-8830-9572b83b6e6f" class="code"><code>.cn {
	display: flex;
	justify-content: center;
	align-items: center;
}</code></pre></details></li></ul><ul id="4452e052-b8cc-4163-86c5-e6ce0de680e2" class="toggle"><li><details open=""><summary>grid</summary><pre id="0991ee72-df23-48f0-9fbc-4f4011396c32" class="code"><code>&lt;div class=&quot;wrap_grid&quot;&gt;
	&lt;div id=&quot;container&quot;&gt;vertical aligned text&lt;br /&gt;some more text here
	&lt;/div&gt;
&lt;/div&gt;</code></pre><pre id="c410b0c5-f282-4923-8639-9512688823a3" class="code"><code>.wrap-grid {
	display: grid;
	place-content: center;
}</code></pre></details></li></ul></details></li></ul><ul id="fc25b18e-cdf3-441b-85e1-ee112bb46a03" class="toggle"><li><details open=""><summary><strong>Các các ẩn đi 1 phần tử trong css </strong></summary><ul id="57a5c46d-37f2-4aae-a49a-3d30f76f3013" class="bulleted-list"><li style="list-style-type:disc">display: none → phần tử sẽ không xuất hiện trong DOM</li></ul><ul id="a28da327-1874-4923-9187-0b5bd6243936" class="bulleted-list"><li style="list-style-type:disc">visibility: hidden → phần tử có xuất hiện trong DOM nhưng không hiển thị lên màn hình</li></ul><ul id="b7532e10-111f-4fd2-bc7b-5464ae2c217e" class="bulleted-list"><li style="list-style-type:disc">position: absolute → set top, right, bottom hoặc left về số âm để di chuyển element ra ngoài màn hình</li></ul><ul id="b03d7c09-62f2-478e-95ad-5db5396f4369" class="bulleted-list"><li style="list-style-type:disc">transform: translateX(-999px) | translateY(-999px) | scale(0)</li></ul><ul id="84a80bd0-6f9e-4611-a4f3-78cf851eb478" class="bulleted-list"><li style="list-style-type:disc">opacity: 0 → ẩn đi, nó chỉ vô hình nhưng ta vẫn có thể add event lên nó</li></ul></details></li></ul><ul id="97ac66dd-2e48-4d99-a23e-b6b87f477958" class="toggle"><li><details open=""><summary><strong>grid và flex khác nhau gì ?</strong></summary><ul id="009c7b01-efd2-439c-905d-42e54cb091c9" class="bulleted-list"><li style="list-style-type:disc">grid là bố cục 2 chiều cả ngang và dọc → tiếp cận theo hướng layout</li></ul><ul id="01d5f3e1-3c7c-42b5-b276-de7872429ace" class="bulleted-list"><li style="list-style-type:disc">flex 1 chiều, theo chiều ngang hoặc dọc → tiếp cận theo hướng nội dung</li></ul><ul id="24e81789-8c0d-41b7-84f9-b0232deb3542" class="bulleted-list"><li style="list-style-type:disc">Nếu biết rõ nội dung ta cần trình bày thì nên dùng flex ngược lại dùng grid</li></ul><ul id="551a109a-921c-4ff8-9902-1c61debed7c1" class="bulleted-list"><li style="list-style-type:disc">Flex phù hợp web có bố cục đơn giản, grid thì phù hợp UI phức tạp</li></ul></details></li></ul><ul id="67925226-ca32-4df9-8be8-36a2488850de" class="toggle"><li><details open=""><summary><strong>Grid là gì?</strong></summary><ul id="8a3372ac-5c19-4860-9657-0ad9feba9ac7" class="bulleted-list"><li style="list-style-type:disc">hệ thống layout 2 chiều theo trục x và y</li></ul><ul id="6e9948e0-2057-4491-8e60-8394f1f95cb4" class="bulleted-list"><li style="list-style-type:disc">tổ hợp của đường ngang và dọc cắt nhau bao gồm các hàng và cột</li></ul><ul id="30a70175-7eaa-4754-9c2d-a26c9b11482a" class="bulleted-list"><li style="list-style-type:disc">Các phần tử sẽ được đặt trên các hàng và cột này</li></ul></details></li></ul><ul id="2b3f2fa3-67c0-4b53-870e-9a456417e2c0" class="toggle"><li><details open=""><summary><strong>Flexbox là gì?</strong></summary><ul id="e43b98ea-c67f-4c6c-beeb-ffa92fe3d171" class="bulleted-list"><li style="list-style-type:disc">là hệ thống bố cục một chiều (ngang hoặc dọc)</li></ul><ul id="822d6259-5ed5-433d-b42d-41db03df7ffa" class="bulleted-list"><li style="list-style-type:disc">giúp căn chỉnh bố trí những item trong container một cách linh hoạt ngay cả khi kích thước chưa xác định hoặc kích thước động</li></ul><ul id="d19b0bc2-5270-4451-83fd-3f1bfbb482ed" class="bulleted-list"><li style="list-style-type:disc"><a href="https://www.notion.so/Flexbox-686ee4ef94394e80b355b25425dbfa94">Flex</a> bao gồm: <ul id="f89e167f-440b-4fbd-b8c4-64f060f16d4d" class="bulleted-list"><li style="list-style-type:circle">flex-container (parent)<ul id="9aab7532-b96f-40f5-9ea3-c23dc427f75d" class="bulleted-list"><li style="list-style-type:square">flex-direction</li></ul><ul id="adb25112-4c63-4083-8e11-6f07bc7a6223" class="bulleted-list"><li style="list-style-type:square">flex-wrap</li></ul><ul id="be951d10-26ae-44d1-8996-e8329ea80bab" class="bulleted-list"><li style="list-style-type:square">flex-content</li></ul><ul id="b6a6bed2-3dca-4512-872c-6b0fbc798a57" class="bulleted-list"><li style="list-style-type:square">align-items</li></ul><ul id="bc646c6e-60d3-467d-bba7-da2b8f5a816f" class="bulleted-list"><li style="list-style-type:square">align-content</li></ul></li></ul><ul id="fb368b8d-0f10-4a2b-9c67-cb6c14929037" class="bulleted-list"><li style="list-style-type:circle">flex-item (child)<ul id="95f03e84-71eb-4e40-a9be-258c1904be60" class="bulleted-list"><li style="list-style-type:square">order</li></ul><ul id="5526e033-43fe-4c95-b2f9-bb1d34624d2b" class="bulleted-list"><li style="list-style-type:square">align-self</li></ul><ul id="b7c9ab55-ac7a-4dab-9212-e019334c0a0e" class="bulleted-list"><li style="list-style-type:square">flex-grow</li></ul><ul id="07e4575a-d549-4de3-9a02-d5208d97fcb1" class="bulleted-list"><li style="list-style-type:square">flex-shink</li></ul><ul id="dacbc4b8-909b-4c1d-bfa9-cb4d4adf20c3" class="bulleted-list"><li style="list-style-type:square">flex-basis</li></ul></li></ul></li></ul></details></li></ul><ul id="37dda6e4-68f2-4b54-8fc9-207c9d46a47d" class="toggle"><li><details open=""><summary><strong><mark class="highlight-red">Giải thích Position trong css?</mark></strong></summary><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="06bb3e4e-800a-4158-8d01-84c04dae2fb7"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">Normal flow là cách trình duyệt hiển thị những block element từ trên xuống dưới và mỗi block sẽ chiếm toàn bộ chiều ngang của container (div, p), ngược lại thì là inline(a, span, img)</div></figure><ul id="dd7e923a-2535-49df-b828-ebe4df1233bf" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red"><strong>static</strong></mark>: vị trí mặc định, theo dòng chảy thông thường của trang, tuy nhiên ta không thể set <strong>L, T, R, B, z-index </strong>cho nó</li></ul><ul id="faeec538-b20e-4cc6-8715-dfb004eb7bd3" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red"><strong>relative</strong></mark>: tuân theo quy luật của dòng chảy thông thường của trang nhưng có thể set các giá trị <strong>L, T, R, B, z-index</strong></li></ul><ul id="13cdc441-32a7-4450-a6dd-b66582931fb5" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red"><strong>absolute</strong></mark>: element sẽ bị loại bỏ khỏi normal flow và nó sẽ nằm tương đối so với thuộc tính cha gần nhất của nó mà element cha đó phải có thuộc tính position là <strong>relative</strong>, <strong>absolute</strong>, <strong>fixed</strong> hoặc <strong>sticky</strong>. <ul id="a34886b8-7679-432f-8a4b-1efada2cbfa3" class="bulleted-list"><li style="list-style-type:circle">Nếu không có thằng element cha nào mà có các thuộc tính trên thì nó sẽ nằm tương đối với root-element là thẻ html</li></ul></li></ul><ul id="808f0c03-7afc-4675-bb85-b7d96c240298" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red"><strong>fixed</strong></mark>: tương tự absolute nhưng khác là nó chỉ hiện thị tương đối so với thẻ html (root-element)</li></ul><ul id="1b0a8f85-9b6a-43fd-8549-0e4c5dc1310e" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red"><strong>sticky</strong></mark>: là sự kết hợp giữa <strong>relative</strong> và <strong>fixed</strong>. Tức là nó vẫn nằm trong normal flow của trang như <strong>relative</strong> nhưng nó sẽ trở thành <strong>fixed</strong> nếu ta cuộn xuống đúng vị trí của nó. Và nó chỉ hoạt động trên container chứa nó. </li></ul></details></li></ul><ul id="4d15b277-4793-4c01-a1fb-aeea18102fc8" class="toggle"><li><details open=""><summary><strong>overflow là gì ?</strong></summary><ul id="7f172603-219e-4a6c-b8d8-9186d208caca" class="bulleted-list"><li style="list-style-type:disc">dùng để xử lý khi kích thước nội dung vượt quá kích thược container</li></ul></details></li></ul><ul id="241952f1-e210-4f06-bd82-7125adc86e43" class="toggle"><li><details open=""><summary><strong>Độ đặc hiệu, độ cụ thể trong css là gì ?</strong></summary><ul id="0967c7ed-bdd8-4f07-980f-e176ed65c7c1" class="bulleted-list"><li style="list-style-type:disc">Tính đặc hiệu hay độ ưu tiên (specificity) là cách mà trình duyệt quyết định sẽ áp dụng thuộc tính css nào với một phần tử khi có nhiều quy tắc css cùng trỏ đến phần tử đó.</li></ul><ul id="b7593a71-0ace-4fdb-b889-7e1784de24f5" class="bulleted-list"><li style="list-style-type:disc">Inline style sẽ được ưu tiên so với ID rồi đến giá trị lớp (pseudo-class hoặc attribute selector), universal selector <strong>(*)</strong> sẽ không có độ ưu tiên. ID Selector có độ ưu tiên cao hơn attribute selector.</li></ul></details></li></ul><ul id="7ab6bd56-b7e9-4d8a-9b01-d9180b3a01cf" class="toggle"><li><details open=""><summary><strong>Đơn vị trong css ?</strong></summary><ul id="0547fdb5-ca66-4e23-89fe-15d61c0c353b" class="bulleted-list"><li style="list-style-type:disc">Absolute units: px, pt, cm, mm, …</li></ul><ul id="b25b4e26-69c2-457c-957e-acc6cb458472" class="bulleted-list"><li style="list-style-type:disc">Relative units: rem, em, %, vw, vh, vmin, vmax, …<ul id="5f40074a-93f4-43fa-96ac-bcb9402d18e4" class="bulleted-list"><li style="list-style-type:circle">em: giá trị phụ thuộc vào phần tử cha gần nhất hoặc chính nó, được xác định thông qua thuộc tính font-size</li></ul><ul id="737c55b8-4999-4f39-aaa5-6e1d405a6161" class="bulleted-list"><li style="list-style-type:circle">rem: tương tự như em nhưng phụ thuộc vào root</li></ul><ul id="7d499e25-b55e-4fe5-9a57-81074dec0215" class="bulleted-list"><li style="list-style-type:circle">vw: tính theo tỉ lệ <strong>chiều rộng khung nhìn </strong>thiết bị. 1 vw = 1/100 width view-port. <ul id="af29d2a9-9f82-406e-8734-fab24e688d4e" class="bulleted-list"><li style="list-style-type:square">Ví dụ: màn hình của bạn có chiều rộng 1100px thì 1vw = 11px</li></ul></li></ul><ul id="31302c46-7cf2-4e01-b36c-826b8e41df17" class="bulleted-list"><li style="list-style-type:circle">vh: tương tự vw nhưng theo height view-port</li></ul></li></ul></details></li></ul><ul id="3b1a4282-f26f-4849-baf5-48926a0cfbb1" class="toggle"><li><details open=""><summary><strong>Cách css hoạt động?</strong></summary><ul id="673cb23b-1b50-4740-b8fe-6f648d349dd4" class="bulleted-list"><li style="list-style-type:disc">Ngôn ngữ CSS được thiết kế để sử dụng cùng với ngôn ngữ &quot;đánh dấu&quot; như HTML. </li></ul><ul id="631abe1f-2e05-44b2-aa2e-a9339127a755" class="bulleted-list"><li style="list-style-type:disc">CSS xác định cách các phần tử HTML được định dạng - kiểm soát bố cục, màu sắc, phông chữ của chúng, ... </li></ul><ul id="23710fc3-90ce-47e7-9a03-0d921d1a9868" class="bulleted-list"><li style="list-style-type:disc">Khi trình duyệt hiển thị một document, nó phải kết hợp nội dung của document với thông tin style của nó. </li></ul><ul id="9c5abf87-f2b9-4e6c-8d0a-0f8d9cce5d7c" class="bulleted-list"><li style="list-style-type:disc">Nó xử lý document theo một số giai đoạn, mà chúng ta đã liệt kê bên dưới.<ol type="1" id="905840db-1c4d-477d-aaef-0f8f8da2b157" class="numbered-list" start="1"><li>Trình duyệt tải HTML (ví dụ: nhận nó từ mạng).</li></ol><ol type="1" id="95f4d5c0-2d97-49c9-8ae4-6153b222cfa4" class="numbered-list" start="2"><li>Nó chuyển đổi HTML thành DOM.</li></ol><ol type="1" id="21122dde-d6de-49d3-8e99-68ca3197ca80" class="numbered-list" start="3"><li>Sau đó, trình duyệt sẽ tìm nạp hầu hết các tài nguyên được liên kết với tài liệu HTML, chẳng hạn như hình ảnh và video được nhúng và CSS được liên kết.</li></ol><ol type="1" id="2f910f61-1852-46b0-a73a-f351981bc41c" class="numbered-list" start="4"><li>Trình duyệt phân tích cú pháp CSS đã nạp và sắp xếp các quy tắc khác nhau theo kiểu selector của chúng thành các &quot;nhóm&quot; khác nhau, ví dụ: phần tử, lớp, ID, ... Dựa trên các selector mà nó tìm thấy, nó sẽ tìm ra các quy tắc nên được áp dụng cho các nút nào trong DOM và đính kèm kiểu cho chúng theo yêu cầu (bước trung gian này được gọi là cây render).</li></ol><ol type="1" id="afc44bdf-c675-4360-8eb9-6b65fc9021ed" class="numbered-list" start="5"><li>Cây render được bố trí trong cấu trúc mà nó sẽ xuất hiện sau khi các quy tắc đã được áp dụng cho nó.</li></ol><ol type="1" id="485e543c-bcee-4537-bd85-adac00f9d43f" class="numbered-list" start="6"><li>Hiển thị trực quan của trang được hiển thị trên màn hình.</li></ol></li></ul></details></li></ul><p id="5f030699-c580-4196-baa9-25cebe070256" class="">
</p><hr id="a6ae49c8-5d65-43a4-9f91-039dd502bb74"/><h2 id="1f0f3dfb-be76-49e4-8451-c5a66ffa8939" class=""><mark class="highlight-red">JS</mark></h2><hr id="8705d6cb-4b70-4de6-a6cf-7a97fda19210"/><ul id="769e7931-c78f-43e5-b173-b69d84f3a3ab" class="toggle"><li><details open=""><summary><a href="https://www.notion.so/Debounce-Throttle-b859e31d49674819ab37151055e72f83"><strong>Kỹ thuật debounce, throttling và cách code thực tế </strong></a></summary></details></li></ul><ul id="b81d7d36-951c-458d-9ef4-8fcf6ba1a674" class="toggle"><li><details open=""><summary><strong>Từ khóa “</strong><mark class="highlight-red"><strong>this</strong></mark><strong>” trong JS</strong></summary><ul id="f8f1a688-90a1-433f-a2af-dc1b0c9b5bdb" class="bulleted-list"><li style="list-style-type:disc">Từ khoá &quot;this&quot; trong javascript tham chiếu đến một đối tượng có thuộc tính là một hàm.</li></ul><ul id="44e6e654-bca1-4f14-9766-b26703b47991" class="bulleted-list"><li style="list-style-type:disc">Giá trị của &quot;this&quot; phụ thuộc vào đối tượng đang gọi hàm.</li></ul></details></li></ul><ul id="f8543efc-eb94-4057-957a-ee480ee68ebc" class="toggle"><li><details open=""><summary><strong>Giải thích cách hoạt động của </strong><strong><code>this</code></strong><strong> trong JavaScript</strong></summary><ul id="93a6f08c-9bb4-4b40-9df4-a637daaa3fee" class="bulleted-list"><li style="list-style-type:disc">Không có lời giải thích đơn giản nào cho <code><strong>this</strong></code>; nó là một trong những khái niệm khó hiểu nhất trong JavaScript. Giá trị của <code><strong>this</strong></code> phụ thuộc vào cách hàm được gọi.  Các quy tắc sau được áp dụng:<ul id="3ba21a86-3239-4935-ac52-e86dccf53831" class="bulleted-list"><li style="list-style-type:circle">Nếu từ khóa <code><strong>new</strong></code> được sử dụng khi gọi hàm, thì bên trong hàm này là một đối tượng hoàn toàn mới.</li></ul><ul id="443d21cb-cde9-46a3-a4e0-9d810e524ed0" class="bulleted-list"><li style="list-style-type:circle">Nếu <code><strong>apply, call</strong></code><code> </code>hoặc <code><strong>bind</strong></code> được sử dụng để gọi / tạo một hàm, thì bên trong hàm này là đối tượng được truyền vào dưới dạng đối số.</li></ul><ul id="b0afd8d6-4ce6-4135-83d3-82cd2f66cff0" class="bulleted-list"><li style="list-style-type:circle">Nếu một hàm được gọi là một phương thức, chẳng hạn như <code><strong>obj.method ()</strong></code> – thì <code><strong>this</strong></code> là đối tượng mà hàm là thuộc tính của nó.</li></ul><ul id="8e29c45d-2b91-4830-afd5-7d4e2a7ab9c2" class="bulleted-list"><li style="list-style-type:circle">Nếu một hàm được gọi dưới dạng một lệnh gọi hàm miễn phí, nghĩa là nó được gọi mà không có bất kỳ điều kiện nào ở trên, thì đây là đối tượng toàn cục. Trong trình duyệt, nó là đối tượng <code><strong>window</strong></code>. Nếu ở chế độ nghiêm ngặt (<code>&#x27;use strict&#x27;</code>), <code><strong>this</strong></code> sẽ là <code>undefined</code> thay vì đối tượng toàn cục.</li></ul><ul id="f09c1ecb-66fb-41b2-9662-4329fd012590" class="bulleted-list"><li style="list-style-type:circle">Nếu áp dụng nhiều quy tắc trên, quy tắc nào cao hơn sẽ được ưu tiên và sẽ đặt giá trị này.</li></ul><ul id="350cd3f7-e246-45b2-bdac-28e8756b7098" class="bulleted-list"><li style="list-style-type:circle">Nếu hàm là một arrow function ES2015, nó sẽ bỏ qua tất cả các quy tắc ở trên và nhận <code><strong>this</strong></code> của phạm vi xung quanh tại thời điểm nó được tạo.</li></ul></li></ul></details></li></ul><ul id="4aca005c-bd54-4e59-9788-76cbec5c1cf4" class="toggle"><li><details open=""><summary><strong>Phân biệt </strong><mark class="highlight-red"><strong>call</strong></mark><strong>, </strong><mark class="highlight-red"><strong>apply</strong></mark><strong>, </strong><mark class="highlight-red"><strong>bind</strong></mark><strong> </strong></summary><ul id="dba8fd2b-20e4-40c0-ba01-24e29cbab7aa" class="bulleted-list"><li style="list-style-type:disc">cả 3 đều dùng để thay đổi context của từ khóa this</li></ul><ul id="ae95ab63-92b4-4e13-8cfe-01189c136b6a" class="bulleted-list"><li style="list-style-type:disc">thiết đặt và thay đổi giá trị “<strong>this</strong>” theo ý muốn</li></ul><ul id="32ed4a3f-5f27-4a7d-a5a1-74ca132df6e3" class="bulleted-list"><li style="list-style-type:disc">cả 3 hàm đều là các prototype của function. Nên chỉ có Function mới gọi được 3 hàm này.</li></ul><ul id="27c21df5-c5ea-4592-99dd-8317d5d6170f" class="bulleted-list"><li style="list-style-type:disc">Về cơ bản là giống nhau về cách sử dụng nhưng khác nhau về cách gọi và cách truyền tham số<ul id="2b4244b3-4740-421c-9a1f-3f7693502426" class="bulleted-list"><li style="list-style-type:circle"><strong>call</strong>: gọi trực tiếp hàm và cho phép truyền vào 1 object và ds những tham số ngăn cách bởi dấu phẩy</li></ul><ul id="5016d7ec-9e72-4d7b-a77b-3b0d6e1fc8ec" class="bulleted-list"><li style="list-style-type:circle"><strong>apply</strong>: giống như call nhưng nó truyền tham số là 1 array</li></ul><ul id="7727c96d-ad63-4404-b984-993b80006a05" class="bulleted-list"><li style="list-style-type:circle"><strong>bind</strong>: không gọi trực tiếp mà nó sẽ trả về 1 hàm mới và truyền danh sách tham số ngăn cách bởi dấy phẩy</li></ul></li></ul></details></li></ul><ul id="019a7700-bc16-40b8-beaa-7a6226df4547" class="toggle"><li><details open=""><summary><strong>Giải thích cơ chế hoisting trong JS</strong></summary><ul id="b10901b2-5c23-45f9-b3d5-c6ad5465ce10" class="bulleted-list"><li style="list-style-type:disc">Hoisting là một hành vi mặc định của Javascript di chuyển việc khai báo lên đầu trong scope của nó.</li></ul><ul id="aaba90a5-c072-4914-986b-79e44e2c8736" class="toggle"><li><details open=""><summary><strong>Giải thích thêm về  cách bộ máy JS hoạt động:</strong></summary><ul id="7ad058c1-11f6-45c4-896a-1600bb1ce1b2" class="bulleted-list"><li style="list-style-type:disc">Khi bộ máy JS xử lý đoạn code của bạn , nó tạo ra 1 cái gọi là bối cảnh thực thi (execution context). Có 2 quá trình liên quan đến việc tạo cái bối cảnh thực thi này:<ul id="bfd965bf-43d3-4192-a895-c82c489b36fa" class="bulleted-list"><li style="list-style-type:circle"><strong>GD1</strong> (creation) : Trong giai đoạn này các biến và function được thêm vào bộ nhớ. Bộ máy JS sẽ đi qua một lượt đoạn code của bạn và thêm tất cả các biến vào bộ nhớ máy tính. <strong>Nhưng nó chưa gán giá trị cho các biến này.</strong> Trong khi đó các function thì lại được <strong>thêm toàn bộ vào bộ nhớ bao gồm cả tên và khối code bên trong nó.</strong></li></ul><ul id="c5c45e80-30e7-42e0-9895-6dd44befc08a" class="bulleted-list"><li style="list-style-type:circle"><strong>GD2</strong> (execution) : Trong giai đoạn này giá trị sẽ được gán cho các biến và function sẽ được gọi. Nên kể cả bạn khởi tạo 1 biến với giá trị ban đầu thì ở giai đoạn 2 này biến mới được gán giá trị. Ở giai đoạn 1 giá trị không được gán cho biến , nó được thêm vào bộ nhớ với giá trị khởi tạo là undefined.</li></ul></li></ul><ul id="3a00dc6e-f4e7-4630-87ae-956d68e3c7d3" class="bulleted-list"><li style="list-style-type:disc">Trước khi function được thực thi , nó đã được thêm vào bộ nhớ trong giai đoạn 1 (creation) nên bộ máy Javascript biết function này nằm ở đâu. <strong>Nó không chuyển cái function này lên trên đầu.</strong></li></ul><ul id="645a7008-ba02-4e33-be94-eb549eace5bd" class="bulleted-list"><li style="list-style-type:disc">Đối với biến quá trình cũng giống như vậy nhưng có 1 chút khác biệt. Các biến cũng được thêm vào bộ nhớ trong giai đoạn 1 nhưng không có giá trị nào được gán cho chúng. Trong JS khi một biến được khai báo mà không có giá trị nào bộ máy JS tự động thêm giá trị <strong>undefined</strong></li></ul></details></li></ul></details></li></ul><ul id="27cbbd6f-8fea-4ddb-bbd7-0358d998c097" class="toggle"><li><details open=""><summary><strong>Temporal dead zone là gì  ?</strong></summary><ul id="53c3fee6-8db8-4611-b947-5efc7295934a" class="bulleted-list"><li style="list-style-type:disc">Từ es6 trở lên giới thiệu 2 từ khóa <strong>let</strong> và <strong>const</strong> để khai báo biến. </li></ul><ul id="5b30678b-4266-40e6-a8d9-284360ae957d" class="bulleted-list"><li style="list-style-type:disc">Điểm khác biệt so với var là <strong>ở giai đoạn 1 (creation)</strong> <strong>chúng không được khởi tạo với giá trị undefined như với var.</strong> </li></ul><ul id="6c01f1f8-5c3c-43b3-9f3b-71140f08c3c2" class="bulleted-list"><li style="list-style-type:disc">Thay vào đó: chúng được set 1 chế độ đặc biệt gọi là <mark class="highlight-red"><strong>Temporal Dead Zone</strong></mark>. Đây là 1 khoảng thời gian giữa việc khai báo và khởi tạo biến. </li></ul><ul id="bf700a9f-2fa5-48e4-987c-b976d4ac2766" class="bulleted-list"><li style="list-style-type:disc">Trong giai đoạn này bạn sẽ không thể truy cập vào biến đó được. </li></ul><ul id="85fa5ddf-4b1a-4a98-8676-f588ded830b4" class="bulleted-list"><li style="list-style-type:disc">Điều này có nghĩa là chúng vẫn tồn tại ở đó nhưng bạn sẽ không thể truy cập được cho đến khi bạn khởi tạo giá trị cho biến sẽ được thực hiện ở giai đoạn 2.</li></ul></details></li></ul><ul id="b5c41bb2-f267-4f1d-bb84-a445c22b3efd" class="toggle"><li><details open=""><summary><strong>Ép kiểu ngầm trong JS là gì </strong></summary><ul id="f61774f7-1ce4-4e7f-82fa-17dba9055372" class="bulleted-list"><li style="list-style-type:disc">là sự chuyển đổi tự động của giá trị từ kiểu dữ liệu này sang kiểu dữ liệu khác</li></ul><ul id="b416f3b9-fe25-4af6-8f31-5c7880715eab" class="bulleted-list"><li style="list-style-type:disc">Ví dụ:<ul id="dd014b90-c01d-4d40-b2f4-471515126961" class="bulleted-list"><li style="list-style-type:circle">số + chuỗi = chuỗi</li></ul><ul id="60e584dd-0ead-4040-9372-02cc46e15e1e" class="bulleted-list"><li style="list-style-type:circle">số - chuỗi = số</li></ul><ul id="7f9c05b4-fb46-4894-92df-1352f7a0c6d7" class="bulleted-list"><li style="list-style-type:circle">boolean sử dụng toán tử logic<ul id="44da4840-c8cc-4d40-9e8f-32c2e5a27586" class="bulleted-list"><li style="list-style-type:square">Falsy: null, undefined, 0, 0n, -0, NaN, “”</li></ul><ul id="d939b6c4-0bd9-4259-b556-3a6e2b981cf1" class="bulleted-list"><li style="list-style-type:square">Truethy: là những giá  trị khác falsy</li></ul></li></ul></li></ul></details></li></ul><ul id="821f5d54-df21-40d9-9fbb-fdba78c3b6e6" class="toggle"><li><details open=""><summary><strong>JS là static hay dynamic</strong></summary><ul id="88245064-ed62-401b-857c-15f0a0ed3ac5" class="bulleted-list"><li style="list-style-type:disc">là dynamic, kiểu dữ liệu của biến được kiểm tra tỏng khi đang chạy chương trình</li></ul><ul id="3b190baf-08b5-4fbc-9785-e2632052fbd7" class="bulleted-list"><li style="list-style-type:disc">Đối với static thì nó sẽ kiểm tra sau khi biên dịch xong</li></ul></details></li></ul><ul id="aae22caf-4539-4997-88fe-e3b772d3055d" class="toggle"><li><details open=""><summary><strong>Higher order function là gì (HOC)</strong></summary><ul id="a3781fd5-98dd-4edd-9240-6892f17c33b1" class="bulleted-list"><li style="list-style-type:disc">là 1 hàm nhận vào tham số là hàm khác hoặc return về 1 hàm, hoặc cả 2 vừa nhận vừa return về 1 hàm</li></ul></details></li></ul><ul id="bd7cd6e3-b5b9-4a27-9e89-28430088d728" class="toggle"><li><details open=""><summary><strong>Scope trong JS</strong></summary><ul id="0d472603-228d-4974-963a-4f2b30a7a419" class="bulleted-list"><li style="list-style-type:disc">là khái niệm nhắm xác định phạm vi hoạt động của biến</li></ul><ul id="24a834f2-8c21-41d0-9022-85041a0e3f37" class="bulleted-list"><li style="list-style-type:disc">Các loại scope<ul id="a4b26c0b-af94-4ed0-a811-4edacfe74124" class="bulleted-list"><li style="list-style-type:circle"><strong>Global scope: </strong><ul id="91c2992d-87eb-46ab-a55e-9a8323b03b50" class="bulleted-list"><li style="list-style-type:square">biến được định nghĩa ở bên ngoài function</li></ul><ul id="0a5dccd7-be5b-4b6d-9100-1d2b0dba4dc0" class="bulleted-list"><li style="list-style-type:square">sẽ được sử dụng và thay thế ở bất cứ đâu</li></ul><ul id="1c2d4dc1-973e-4ae9-b697-1733e993ba97" class="bulleted-list"><li style="list-style-type:square">nếu ta định nghĩa 1 biến mà không dùng từ khóa nào thì mặc định nó thuộc global scope</li></ul></li></ul><ul id="f3d48d2d-c5bb-4d9c-9c42-271f507aefd5" class="bulleted-list"><li style="list-style-type:circle"><strong>Local scope: </strong><ul id="c4f19b38-ba2f-41e4-bd82-abb5f10d0f63" class="bulleted-list"><li style="list-style-type:square">biến được định nghĩa bên trong 1 function</li></ul><ul id="1c14ba80-eea7-4ece-980f-8056790427e9" class="bulleted-list"><li style="list-style-type:square">mỗi function khi gọi sẽ tạo ra 1 scope mới</li></ul><ul id="a5661ed7-79f6-4876-a298-64d7eec8aba3" class="bulleted-list"><li style="list-style-type:square">mỗi function sẽ tạo ra 1 local scope khác nhau, cho nên ta có thể khai báo các biến trùng tên ở các scope local</li></ul></li></ul><ul id="e9fa740a-3fb8-4122-8fc7-3b28d13b16ef" class="bulleted-list"><li style="list-style-type:circle"><strong>Lexical scope:</strong><ul id="a7679bbe-7394-4c7a-be41-ef334f1aaa11" class="bulleted-list"><li style="list-style-type:square">Ví dụ ta có fn A nằm trong fn B, mà trong A có các biến tham chiếu đến fn B thì ta nói fn A có lexical scope và lexical scope của A chính là scope của nó  + với scope của fn B</li></ul></li></ul><ul id="10f0173d-25f2-4b43-b845-66fec5bf3e29" class="bulleted-list"><li style="list-style-type:circle">Ngoài ra ta còn có block statements ( if/else, switch case, for loop)<ul id="e2261929-8c82-4242-a772-2f0ae22a3138" class="bulleted-list"><li style="list-style-type:square">Không giống như function nó không tạo ra local scope mới mà nó giữ nguyên scope của nó</li></ul><ul id="9815b591-c0c6-48c5-bda6-e55701c66a21" class="bulleted-list"><li style="list-style-type:square">Các biến khai báo bằng var nó sẽ không tạo ra local scope trong block statements</li></ul><ul id="781d694a-da9d-411b-bef5-c5aa2c6980fe" class="bulleted-list"><li style="list-style-type:square">let và const giúp tạo local scope bên trong 1 block</li></ul><ul id="3b458f6e-8df3-4b79-87b4-d9e7ea9ff655" class="bulleted-list"><li style="list-style-type:square">Biên được khai báo trong block {} thì chỉ truy cập được trong block đó thôi, bên ngoài không truy cập được</li></ul></li></ul></li></ul></details></li></ul><ul id="6d5576ff-65b7-4f88-8840-06f913e8c2dc" class="toggle"><li><details open=""><summary><strong>scope chain trong JS ?</strong></summary><ul id="36a04d4d-337a-42b9-81df-53fa586ee714" class="bulleted-list"><li style="list-style-type:disc">JS sử dụng scope để tìm kiếm biến</li></ul><ul id="07c73313-7f67-4467-afb2-657d08e11d2d" class="bulleted-list"><li style="list-style-type:disc">Nếu không tìm thấy biến bên trong function scope thì nó sẽ tiếp tục tìm biến đó ra phạm vi bên ngoài</li></ul><ul id="ff8315b7-7756-4e76-a771-041c2bdf693b" class="bulleted-list"><li style="list-style-type:disc">Nếu không có sẽ tiếp tục tìm ở global scope </li></ul><p id="e3642f4f-817a-4d9c-95ab-6d9506fa96aa" class=""><strong>→ Nếu không có nữa sẽ có lỗi tham chiếu được đưa ra</strong></p></details></li></ul><ul id="b28036d5-ef2d-4250-8899-cc16eb4bf165" class="toggle"><li><details open=""><summary><strong>Closures trong JS là gì ?</strong></summary><ul id="402771f0-184d-4f56-a0d1-1478e9242680" class="bulleted-list"><li style="list-style-type:disc">là 1 hàm mà có khả năng ghi nhớ nơi nó được tạo ra và truy cập được các biến ở bên ngoài phạm vi của nó</li></ul><p id="90aa7980-5903-4ca8-b433-f51791c4141a" class="">→ Vì lexical scope là khái niệm đi với function nên có thể coi closure là tập hợp gồm function và lexical scope của function đó</p><ul id="013598c5-ed36-45f9-893a-2c52e46c3d35" class="bulleted-list"><li style="list-style-type:disc">Giúp ta viết code ngắn gọn hơn, đồng thời ứng dụng được tính <strong>private</strong> trong OOP</li></ul></details></li></ul><ul id="22685a82-e7fc-4673-a6f9-64bc0afcc42e" class="toggle"><li><details open=""><summary><strong>Currying Function là gì ?</strong></summary><ul id="c9e23709-657c-452d-8a2b-9a97d6f322ee" class="bulleted-list"><li style="list-style-type:disc">Biến đổi 1 hàm nhiều tham sô thành n hàm nhận vào 1 tham số</li></ul><ul id="934f6fff-4300-4cca-9bb7-1da3d620494d" class="bulleted-list"><li style="list-style-type:disc">Về bản chất ta không thay đổi chức năng của hàm mà chỉ thay đổi cách gọi hàm</li></ul></details></li></ul><ul id="f57f0887-d811-4a0c-ab83-926bdcccb983" class="toggle"><li><details open=""><summary><strong>var, let, const khác nhau gì ?</strong></summary><ul id="dea2b8a5-b870-4628-a974-79e46cf0f603" class="bulleted-list"><li style="list-style-type:disc">về mặt scope<ul id="fe602cf9-c946-43df-95d7-e8b9aa9e3235" class="bulleted-list"><li style="list-style-type:circle">let, const giúp tạo local scope bên trong block statements</li></ul><ul id="0dfa8fc1-c476-4740-804d-75a819f826b3" class="bulleted-list"><li style="list-style-type:circle">var rất khó xác định scope cụ thể nên bây giờ cũng tránh sử dụng var, ngoài ra các biến khai báo bằng var đều bị hoisting</li></ul></li></ul><ul id="27ba7cfe-c030-44db-bd1d-b4c3134282c4" class="bulleted-list"><li style="list-style-type:disc">Về mặt giá trị<ul id="fdbed843-f91b-4109-aaf0-3ee65c49811f" class="bulleted-list"><li style="list-style-type:circle">const là bất biến ta không thể gán lại giá trị cho biến được khai báo với const </li></ul><ul id="84c7c50a-8f55-4097-9ad4-6cfbd77fe632" class="bulleted-list"><li style="list-style-type:circle">var, let thì có thể gán lại giá trị cho biến</li></ul></li></ul></details></li></ul><ul id="a8dbfa7e-fce7-4372-b7f9-ce54f5375306" class="toggle"><li><details open=""><summary><strong>null ≠ undefined như thế nào ?</strong></summary><ul id="c80a17be-2072-4522-8629-c628ffc22e76" class="bulleted-list"><li style="list-style-type:disc">Khi ta khai báo nhưng chưa gán giá trị cho biến đó thì nó là <strong>undefined</strong> </li></ul><ul id="a7f346a2-ace0-4670-9c31-89a30e08a2cf" class="bulleted-list"><li style="list-style-type:disc">Khi ta lấy giá trị của một biến mà chưa khai báo thì nó sẽ gây ra lỗi <strong>is not define</strong></li></ul><ul id="ad3d479d-8349-47e7-8ce5-3860e878ed8e" class="bulleted-list"><li style="list-style-type:disc"><strong>Null</strong> có nghĩa là giá trị rỗng hoặc giá trị không tồn tại, nó có thể được sử dụng để gán cho một biến như là một đại diện không có giá trị.</li></ul><ul id="8f4750ba-9aaa-4d61-826b-a6cd84417610" class="bulleted-list"><li style="list-style-type:disc"><strong>Null</strong> typeof là <strong>object</strong> còn <strong>undefined</strong> typeof là <strong>undefined</strong></li></ul><ul id="2950b93c-c664-49a8-895d-eb690cc85d00" class="bulleted-list"><li style="list-style-type:disc">null == undefined = true </li></ul><ul id="97fffeb6-60ea-4ebb-94b6-2814fd3648e6" class="bulleted-list"><li style="list-style-type:disc">null === undefined = false</li></ul></details></li></ul><ul id="8866d4fd-4779-4706-b635-76613f3da032" class="toggle"><li><details open=""><summary><strong>Prototype trong JS là gì ?</strong></summary><ul id="7cafd428-313b-446b-9a19-4b906532a2c2" class="bulleted-list"><li style="list-style-type:disc">Prototype là khái niệm cốt lõi trong JavaScript và là cơ chế quan trọng trong việc thực thi mô hình OOP trong JavaScript. </li></ul><ul id="963674ca-a20a-4592-ba9f-4f4ac92c97ba" class="bulleted-list"><li style="list-style-type:disc">Tất cả các object trong javascript đều có một prototype, và các object này kế thừa các thuộc tính (properties) cũng như phương thức (methods) từ prototype của mình.</li></ul><ul id="e7bffb0d-8164-4fc2-a812-35faede1491a" class="bulleted-list"><li style="list-style-type:disc">Trong JavaScript, trừ <em>undefined</em>, toàn bộ các kiểu còn lại đều là object. </li></ul><ul id="78dce1cb-0670-41a1-9d02-9af7f50b50d7" class="bulleted-list"><li style="list-style-type:disc">Các kiểu string, số, boolean lần lượt là object dạng <em>String</em>, <em>Number,</em> <em>Boolean</em>. Mảng là object dạng <em>Array</em>, hàm là object dạng <em>Function</em></li></ul><ul id="cd554304-81d3-4cbc-afa4-05d39fdd3f9f" class="bulleted-list"><li style="list-style-type:disc">Trước kia (ES5) trong JavaScript <strong>không có khái niệm class</strong>, do vậy, để <strong>kế thừa các trường/hàm </strong>của một object, ta phải sử dụng prototype.</li></ul><ul id="42eff81d-0877-44f3-b8fa-2699ffb68205" class="bulleted-list"><li style="list-style-type:disc">Khi ta gọi property hoặc function của một object, JavaScript sẽ tìm trong chính object đó, nếu không có thì tìm lên cha của nó. Do đó, ta có thể gọi các hàm <em>toUpperCase</em>, <em>trim </em>trong String là do các hàm đó đã tồn tại trong <em>String.prototype</em></li></ul><ul id="c5211ae6-5659-4687-8030-de05c931cde4" class="bulleted-list"><li style="list-style-type:disc">Khi ta thêm function cho prototype, toàn bộ những thằng con của nó cũng học được function tương tự.</li></ul><ul id="27efc90b-0907-4aac-b19c-5eb5c3ae49ed" class="bulleted-list"><li style="list-style-type:disc"><strong>Giới hạn của prototype trong JavaScript:</strong><ul id="5818066c-2c4f-4af1-b312-a893529577f3" class="bulleted-list"><li style="list-style-type:circle">Không được phép kế thừa prototype vòng tròn.</li></ul><ul id="128f7895-585b-45b4-aca5-bc23ffcd603c" class="bulleted-list"><li style="list-style-type:circle">Giá trị của <code>__proto__</code> có thể là <code>null</code> hoặc là một object, nhưng các kiểu dữ liệu khác đều bị bỏ qua.</li></ul><ul id="016416b7-0e13-4ce4-980f-b73b0dbcfae2" class="bulleted-list"><li style="list-style-type:circle">Prototype không hỗ trợ thay đổi giá trị thuộc tính</li></ul></li></ul><ul id="ce8460e7-8d42-4894-8d9e-7f76804b7897" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Tóm lại:</strong></mark></summary><ul id="2c8263c6-22d1-4a30-ad6f-fb5704bfd86b" class="bulleted-list"><li style="list-style-type:disc">Trong JavaScript, tất cả các object đều có thuộc tính ẩn <code>[[Prototype]]</code> với giá trị là <code>null</code> hoặc kiểu object.</li></ul><ul id="2db2e705-2150-4d10-93c6-15f811fee03d" class="bulleted-list"><li style="list-style-type:disc">Bạn có thể sử dụng <code>obj.__proto__</code> như là một <strong>getter/setter</strong> để truy cập vào <code>[[Prototype]]</code>.</li></ul><ul id="729beb8e-17c3-4048-91ec-0477c25c2283" class="bulleted-list"><li style="list-style-type:disc">Object ứng với <code>[[Prototype]]</code> được gọi là một prototype.</li></ul><ul id="d6d773ee-885a-4d59-9084-bec610aa8a00" class="bulleted-list"><li style="list-style-type:disc">Khi truy cập một thuộc tính hay phương thức trong object mà nó không tồn tại thì JavaScript sẽ tự động tìm kiếm trong prototype.</li></ul><ul id="5bc76c11-537b-408f-8a24-3ea5522678ea" class="bulleted-list"><li style="list-style-type:disc">Prototype chỉ hỗ trợ việc đọc, không hỗ trợ ghi/xóa thuộc tính trực tiếp trên prototype.</li></ul><ul id="49dc5070-95d0-40ed-a2d4-9b168d909180" class="bulleted-list"><li style="list-style-type:disc">Khi bạn gọi <code>obj.method()</code> và <code>method()</code> được lấy từ prototype, giá trị của <code>this</code> vẫn tham chiếu đến <code>obj</code> chứ không phải prototype.</li></ul><ul id="7e3498d1-bad1-4612-a7e5-cbc2967b2b2c" class="bulleted-list"><li style="list-style-type:disc">Vòng lặp <code>for...in</code> duyệt tất cả các thuộc tính trong object và thuộc tính của prototype thông qua kế thừa.</li></ul></details></li></ul></details></li></ul><ul id="44b3d0da-9cc7-4fc9-aae6-caaae4aa1e2a" class="toggle"><li><details open=""><summary><strong>Class trong JS? </strong></summary><ul id="64a74673-c1ac-4862-aca5-94dac31fbc9d" class="bulleted-list"><li style="list-style-type:disc">sử dung oop mà không cần dùng prototype</li></ul><ul id="33e607fa-bce6-4f3a-ba2a-00ea474ebdca" class="bulleted-list"><li style="list-style-type:disc">không bị hoistring như function, cần khai báo trước khi sử dụng</li></ul><ul id="556e403a-0708-471f-8ad2-ffd8c190c9fb" class="bulleted-list"><li style="list-style-type:disc">tuân thủ use strict </li></ul><ul id="173975c0-c937-4115-8c91-506fc468910e" class="bulleted-list"><li style="list-style-type:disc">sử dụng extends để kế thừa</li></ul></details></li></ul><ul id="82392d13-f6a2-4989-872d-25536414ae75" class="toggle"><li><details open=""><summary><strong>Constructor trong JS</strong></summary><ul id="a9ab8d83-1105-43f2-8612-53f0cbbe46fe" class="bulleted-list"><li style="list-style-type:disc">Dùng để tạo ra các thuộc tính mặc định của đối tượng trong JS</li></ul><ul id="71dcba44-0e3b-404f-9cb3-bcec48c928bf" class="bulleted-list"><li style="list-style-type:disc">khi chúng ta muốn tạo ra 1 đối tượng với những thuộc tính và phường thức giống nhau nhưng khác giá trị</li></ul></details></li></ul><ul id="9dd994e2-f83a-4a56-ab90-9e83ad5aa7c5" class="toggle"><li><details open=""><summary><strong>Arrow Function là gì </strong></summary><ul id="1daaec1c-b064-4f42-9014-9093b4202868" class="bulleted-list"><li style="list-style-type:disc">Arrow function được giới thiệu từ phiên bản ES6 của javascript.</li></ul><ul id="028b4f55-d8ca-437c-9a58-4564bc6cd55b" class="bulleted-list"><li style="list-style-type:disc">Nó cung cấp một cú pháp mới và ngắn hơn cho khai báo hàm. </li></ul><ul id="672c3047-0e0d-448d-ab72-05cf31ec7c63" class="bulleted-list"><li style="list-style-type:disc">Hàm arrow có thể xử dụng như là một biểu thức hàm. Ta sẽ so sánh khai báo hàm thông thường với hàm arrow.</li></ul><ul id="6440daa2-25c0-4832-9d69-6ca33d1cac6b" class="bulleted-list"><li style="list-style-type:disc">Sự khác biệt lớn nhất giữa nhất giữa hàm truyền thống với arrow, là ở từ khoá <strong>this</strong>.<ul id="4c194c47-a201-424a-9a3f-84cd1d70e275" class="bulleted-list"><li style="list-style-type:circle">Như định nghĩa, từ khoá this tham chiếu đến đối tượng chứa hàm được gọi.</li></ul><ul id="c7338001-bbb3-4846-83be-2a4f5574306e" class="bulleted-list"><li style="list-style-type:circle">Còn ở hàm arrow, không có ràng buộc nào của từ khóa this.</li></ul><ul id="17ef70ef-02e9-4b6a-94bb-1f9e4f3ec94e" class="bulleted-list"><li style="list-style-type:circle">Từ khoá this trong hàm arrow, không tham chiếu đến đối tượng đang gọi nó. Nó kế thừa giá trị của nó từ phạm vi cha là <code>window object</code> trong trường hợp này.</li></ul></li></ul></details></li></ul><ul id="3433061f-d295-4b12-8da2-8883971ac816" class="toggle"><li><details open=""><summary><strong>Destructuring, spread operator và rest parameter ?</strong></summary><ul id="25098ea0-2fbf-4dad-92d7-e202de634827" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>Destructuring</strong></span><strong>: </strong>Là một cú pháp cho phép bạn gán các thuộc tính của một Object hoặc một Array. Điều này có thể làm giảm đáng kể các dòng mã cần thiết để thao tác dữ liệu trong các cấu trúc này</li></ul><ul id="d5d484ea-3732-436b-8be1-f76113d6e0da" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>Spread operator: </strong></span>Là ba dấu chấm <mark class="highlight-yellow_background"><strong>(...)</strong></mark>, có thể chuyển đổi một mảng thành một chuỗi các tham số được phân tách bằng dấu phẩy. Spread có thể tao ra một cấu trúc dữ liệu shallow copy để tăng tính thao tác dữ liệu.</li></ul><ul id="343d41e2-2761-4d5a-9062-49eb27eda01e" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>Rest parameter: </strong></span>Là một cú pháp tạo ra một array từ một số lượng giá trị không xác định Giúp chúng ta có thể định nghĩa một hàm với số lượng tham số có thể thay đổi tuỳ ý. Hay nói theo cách khác khi chúng ta không biết chắc chắn số lượng tham số cần có của một hàm chúng ta có thể sử dụng rest parameter</li></ul></details></li></ul><ul id="9be100c0-69eb-4cc7-85c9-e10fb676a24f" class="toggle"><li><details open=""><summary><strong>Generator trong JS </strong></summary><ul id="3d1750e7-9791-42ec-baeb-977285e3dec4" class="bulleted-list"><li style="list-style-type:disc">es6</li></ul><ul id="6998c147-1a7a-4a21-bcdd-ab829f235037" class="bulleted-list"><li style="list-style-type:disc">là function có khả năng hoãn lại quá trình thực thi mà vẫn giữ nguyên context</li></ul><ul id="19598895-bf2d-4d0f-a752-9c35010eb5aa" class="bulleted-list"><li style="list-style-type:disc">Nó có khả năng tạm dừng trước khi hàm kết thúc và có khả năng thực hiện lại tại 1 thời điểm khác, khác với những function bình thường là thực thi hết tất cả câu lệnh trong function</li></ul></details></li></ul><ul id="cbd2af84-314b-432b-bc22-288a2fc580e3" class="toggle"><li><details open=""><summary><strong>ES6 có gì nổi bật</strong></summary><ul id="1a176c67-f651-4a1c-81b4-303a7e567258" class="bulleted-list"><li style="list-style-type:disc">let, const</li></ul><ul id="947e68ea-711a-4912-ac43-c9f5b72ad019" class="bulleted-list"><li style="list-style-type:disc">arrow function</li></ul><ul id="de798905-7e20-44c6-bd8f-7a0bfe11f5ce" class="bulleted-list"><li style="list-style-type:disc">generator function</li></ul><ul id="adbbe029-ea51-4bda-903b-fc879ec7833c" class="bulleted-list"><li style="list-style-type:disc">Destructuring, spread operator và rest parameter</li></ul><ul id="043c0346-e555-425a-a3e0-f29c53ebe6de" class="bulleted-list"><li style="list-style-type:disc">class</li></ul><ul id="a1e7d4dd-7cd6-4a5d-869d-55256a956355" class="bulleted-list"><li style="list-style-type:disc">async/await</li></ul><ul id="bb67fd24-c63e-4442-b077-0ccbff2cdacd" class="bulleted-list"><li style="list-style-type:disc">module </li></ul><ul id="ae05a0c5-faf0-4697-b211-bfede75a3ae2" class="bulleted-list"><li style="list-style-type:disc">map, set</li></ul><ul id="f6308af2-e992-4cb7-8ea0-389c8d5ea12c" class="bulleted-list"><li style="list-style-type:disc">template literal</li></ul></details></li></ul><ul id="7c402704-215b-4a55-933e-9f62ad200585" class="toggle"><li><details open=""><summary><strong>const ≠ Object.freeze() gì ?</strong></summary><ul id="27ce1ccf-ff1e-487a-950b-f39b572de31a" class="bulleted-list"><li style="list-style-type:disc">const là 1 key dùng để ràng buộc các biến không thể thay đổi giá trị </li></ul><ul id="40016324-6be9-4e7c-b4c3-d01eb6e0ceb6" class="bulleted-list"><li style="list-style-type:disc">object.freeze() hoạt động với giá trị đối tượng. Làm đối tượng trở nên bất biến. Chỉ read không được write các thuộc tính trong đối tượng</li></ul></details></li></ul><ul id="aeb386a3-b037-4747-93fb-eaea72e56553" class="toggle"><li><details open=""><summary><strong>Proxy trong JS là gì</strong></summary><ul id="0d985052-ae57-46c6-93ee-007cccc46e85" class="bulleted-list"><li style="list-style-type:disc"><strong>Proxy</strong> là một class được giới thiệu từ ES6, cho phép bạn can thiệp và thay đổi hành vi của một đối tượng (object). </li></ul><ul id="3f6b0ead-d214-449c-9f02-a80ffc87fbc5" class="bulleted-list"><li style="list-style-type:disc">Các hành vi này bao gồm: truy xuất/thiết lập (getter/setter) thuộc tính của một đối tượng, thay đổi prototype, gọi hàm, khởi tạo đối tượng bằng từ khóa <code>new</code></li></ul><ul id="e37293c8-68ae-4f1e-936b-52cc799ed9d4" class="bulleted-list"><li style="list-style-type:disc">Chúng ta có thể áp dụng Proxy cho bất cứ object nào trong JavaScript, kể cả mảng, hàm hay một proxy khác.</li></ul></details></li></ul><ul id="f04d5a30-9e66-49b7-8dbe-9c64ce8875a5" class="toggle"><li><details open=""><summary><strong>Memoization là gì ?</strong></summary><ul id="a9c5abb9-8734-412e-8f25-52a09cd4a656" class="bulleted-list"><li style="list-style-type:disc">là một kỹ thuật tối ưu, nhằm tăng tốc chương trình bằng cách lưu trữ kết quả của các câu gọi function và trả về các kết quả này khi function được gọi với cùng input đã gọi.</li></ul></details></li></ul><ul id="96af0866-df23-42c9-9ba8-d697334a7e7a" class="toggle"><li><details open=""><summary><strong>Có thể dùng những vòng lặp nào trong JS (for-loop) ?</strong></summary><ul id="72e4ffb1-b9d0-40b7-b0c7-9691827a1674" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-yellow_background"><strong>map</strong></mark>: để thực hiện một chức năng trên mỗi phàn tử của một mảng. Sử dụng <mark class="highlight-yellow_background"><strong>map</strong></mark> nếu chúng ta muốn thực hiện cùng một thao tác hoặc chuyển đổi trên từng phần tử của mảng và lấy lại một array mới có cùng <mark class="highlight-yellow_background"><strong>length</strong></mark> với các <mark class="highlight-yellow_background"><strong>value</strong></mark> được chuyển đổi.</li></ul><ul id="ec8a3f0a-8ddb-4cdc-9180-84d844db6acc" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-yellow_background"><strong>filter</strong></mark>: khi chúng ta muốn xoá các mục không thoã mãn điều kiện. Mỗi phần tử của mãng được truyền cho hàm callback. Trên mỗi lần lặp nếu callback trả về true, thì phần tử đó sẽ được thêm vào mảng mới và ngược lại</li></ul><ul id="61ff3568-44e3-437d-a5c5-b5508491faeb" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-yellow_background"><strong>reduce</strong></mark>: sử dụng để lặp qua các phần tử của mảng sau đó tính toán và trả về 1 kết quả cuối cùng. Thường được sử dụng để giải quyết các bài toán như lặp qua một mảng → xử lý gì đó → trả về một kết quả cuối cùng</li></ul><ul id="a349d00a-8840-4148-b869-cde19f26959d" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-yellow_background"><strong>for...in</strong></mark>: dùng để lặp lại trong một object. Số lượng vòng lặp sẽ tương ứng với số lượng thuộc tính trong object. Array cũng là object nên ta có thể sử dụng cho cả array, nhưng key sẽ là giá trị index của phần tử</li></ul><ul id="7d2dffd1-63eb-4abc-aeac-812884994e55" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-yellow_background"><strong>for...of</strong></mark>: dùng để lặp các đối tượng từ Array, String, Map, WeakMap, Set, ... <mark class="highlight-yellow_background">Đặc biệt có thể dùng bất đồng bộ trong vòng lặp</mark></li></ul><ul id="335d424f-3dd1-4ab2-8e25-fdd90357bda7" class="bulleted-list"><li style="list-style-type:disc">for, do while, forEach, while</li></ul></details></li></ul><ul id="4b78f7d3-e397-4104-a72c-7c32d91881ec" class="toggle"><li><details open=""><summary> <strong>CORS</strong></summary><ul id="cf69b82f-481d-45bc-a315-68538d9d35a7" class="bulleted-list"><li style="list-style-type:disc">(Cross-Origin Resource Sharing) là một kĩ thuật được sinh ra để làm cho việc tương tác giữa client và server được dễ dàng hơn, nó cho phép JavaScript ở một trang web có thể tạo request lên một REST API được host ở một domain khác.</li></ul><ul id="28c9fe61-bf60-49e4-8fba-416a149f308b" class="bulleted-list"><li style="list-style-type:disc">Hiểu sâu hơn đó chính là chia sẻ tài nguyên có nhiều nguồn gốc khác nhau. Chính sách nguồn gốc giống nhau của trình duyệt là một cơ chế bảo mật quan trọng. Khách hàng từ các nguồn khác nhau không thể truy cập tài nguyên của nhau nếu không được phép. Định nghĩa của tương đồng là <mark class="highlight-yellow_background">protocol</mark>, <mark class="highlight-yellow_background">domain</mark> và <mark class="highlight-yellow_background">port</mark> của liên kết truy cập là giống nhau. </li></ul></details></li></ul><ul id="0a308c9d-494c-4913-a301-f72c80936a54" class="toggle"><li><details open=""><summary><strong>Xử lý bất đồng bộ là gì ?</strong></summary><p id="90c121f9-1d36-4c22-a476-0f81488d7497" class="">Giả sử bạn có một nhiệm vụ bao gồm 2 công việc tốn thời gian, tạm gọi là A và B.<strong></strong></p><ul id="4a56e7db-12db-4fee-a2bb-547a57ff8665" class="bulleted-list"><li style="list-style-type:disc"><strong>Xử lý đồng bộ: </strong><ul id="d70d0126-844c-4021-b9c6-a07b2e63246f" class="bulleted-list"><li style="list-style-type:circle">bạn sẽ thực hiện công việc A</li></ul><ul id="9a832883-116d-484d-9546-167385897718" class="bulleted-list"><li style="list-style-type:circle">đợi A hoàn thành xong thì sẽ thực hiện B </li></ul><ul id="3769ee06-15d2-4627-b6e8-d84405b6fbf3" class="bulleted-list"><li style="list-style-type:circle">rồi lại đợi B hoàn thành thì nhiệm vụ cuối cùng mới coi như xong. </li></ul><ul id="11d13ab6-854f-423d-bd60-0aae7e79845c" class="bulleted-list"><li style="list-style-type:circle">Nghĩa là thời gian để hoàn thành nhiệm vụ là tổng của thời gian hoàn thành A và B. Hơn nữa, trong khoảng thời gian này bạn sẽ không thể thực hiện thêm 1 hành động nào khác </li></ul><ul id="692f5113-d6ed-4207-9312-7c6aadf5b59d" class="bulleted-list"><li style="list-style-type:circle">Điều này rõ ràng làm giảm hiệu năng và trải nghiệm người dùng đối với chương trình.</li></ul></li></ul><ul id="28e60834-de36-4bac-8062-087a9afad9c6" class="bulleted-list"><li style="list-style-type:disc"><strong>Xử lý đa luồng: </strong><ul id="0ad9d08d-968e-4d75-aac4-a29b1e1563d4" class="bulleted-list"><li style="list-style-type:circle">Để khắc phục tình trạng này, các ngôn ngữ lập trình như C/C++, Java,... sẽ sử dụng <strong>cơ chế đa luồng (multi-thread)</strong>. </li></ul><ul id="27379691-1f65-41db-94ad-b86b0ce22eb4" class="bulleted-list"><li style="list-style-type:circle">Nghĩa là mỗi công việc tốn thời gian sẽ được thực hiện trên một thread riêng biệt mà không can thiệp vào thread chính. </li></ul><ul id="7fe4851e-bfe8-4c51-9b65-125490c7c37b" class="bulleted-list"><li style="list-style-type:circle">Bạn vẫn có thể thực hiện các công việc tốn thời gian mà vẫn có thể bắt các sự kiện ở thread chính.</li></ul><ul id="5c706edc-e1f6-43d3-835f-e5cf6f0764fe" class="bulleted-list"><li style="list-style-type:circle">Với ví dụ trên, thời gian để hoàn thành nhiệm vụ sẽ chỉ bằng thời gian hoàn thành của A hoặc B. Cái nào thực hiện xong trước sẽ đợi cái còn lại hoàn thành thì nhiệm vụ sẽ kết thúc.<strong></strong></li></ul></li></ul><ul id="2e29fc02-8841-486f-987c-a78c685dd09e" class="bulleted-list"><li style="list-style-type:disc"><strong>Xử lý bất đồng bộ:</strong><ul id="f156c5b9-a99d-4faa-8c79-e3baf198dfcd" class="bulleted-list"><li style="list-style-type:circle">Tuy nhiên, JavaScript lại là một câu chuyện khác. Hai nền tảng quan trọng với JavaScript đều là <strong>single-thread. </strong></li></ul><ul id="3db357f6-8962-4326-ab15-66594f4fc686" class="bulleted-list"><li style="list-style-type:circle">Chính vì vậy, bạn không thể xử lý đa luồng với JavaScript được mà phải sử dụng cơ chế <strong>xử lý bất đồng bộ</strong></li></ul><ul id="71ddd7b1-a632-4397-af23-648c4b540fb0" class="bulleted-list"><li style="list-style-type:circle">Với cách xử lý bất đồng bộ, khi A bắt đầu thực hiện, chương trình tiếp tục thực hiện B mà không đợi A kết thúc. </li></ul><ul id="d1c06fdb-cd29-4a4f-8707-642e896c2ecc" class="bulleted-list"><li style="list-style-type:circle">Việc mà bạn cần làm ở đây là cung cấp một phương thức để chương trình thực hiện khi A hoặc B kết thúc.</li></ul></li></ul></details></li></ul><ul id="451aa112-9295-48b6-a2c9-8ffb574136ee" class="toggle"><li><details open=""><summary><a href="https://www.notion.so/Callback-Asynchronous-574f492417c6462c925c927766468258"><strong>Callback function là gì, Promise là gì, async await là gì? so sánh?</strong></a></summary><ul id="72a4d0c5-a3b1-4560-9576-7e8b0891e220" class="toggle"><li><details open=""><summary><strong>callback function</strong></summary><ul id="846d55a7-89f3-470f-9d8f-b16eebe79164" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-yellow_background">Là một hàm sẽ được thực hiện sau khi một khác đã thực hiện xong</mark></li></ul><ul id="ece861ca-c676-46d0-a9fb-9ec8fe62af7b" class="bulleted-list"><li style="list-style-type:disc">Trong JS, hàm là các Object dạng function. Do đó các hàm có thể lấy các hàm làm đối số và có thể được trả về bởi các hàm khác. Các hàm thực hiện điều này gọi là <strong><mark class="highlight-yellow_background">HOC</mark></strong>. </li></ul><ul id="80132797-0ca8-4c54-a687-91342644177a" class="bulleted-list"><li style="list-style-type:disc">Bất kỳ hàm nào được truyền dưới dạng đối số thì đều được gọi là hàm <mark class="highlight-yellow_background"><strong>callback</strong></mark></li></ul></details></li></ul><ul id="9dba59a2-c1f3-4029-88b8-cd0ce164e93e" class="toggle"><li><details open=""><summary><strong>Promise</strong></summary><ul id="c3c382cd-6fd2-463c-a2f2-2b1882359ef7" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-yellow_background">Là một đối tượng sẽ trả về một giá trị trong tương lai</mark>. </li></ul><ul id="8e53b50a-574d-4b7f-b654-267a981b5164" class="bulleted-list"><li style="list-style-type:disc">Rõ hơn thì một object <strong><mark class="highlight-yellow_background">Promise</mark></strong> đại diện cho một giá trị ở thời điểm hiện tại có thể chưa tồn tại, nhưng sẽ được xử lý và có giá trị vào một thời gian nào đó trong tương lai.</li></ul><ul id="172571a5-7590-4469-a5aa-ad3d0fc08191" class="bulleted-list"><li style="list-style-type:disc">Ta thường hay gặp các trường hợp sử dụng quá nhiều <mark class="highlight-yellow_background"><strong>callback</strong></mark> dãn đến tình trạng gọi <mark class="highlight-yellow_background"><strong>callback hell</strong></mark>, nên <mark class="highlight-yellow_background"><strong>promise</strong></mark> là cách để giải quyết vấn đề trên</li></ul><ul id="b222cd0a-a700-4143-9489-d3441efa36f7" class="bulleted-list"><li style="list-style-type:disc">Việc sử dụng promise sẽ giúp cho việc cử lý không đồng bộ sẽ trở nên đồng bộ và gọn gàng hơn.</li></ul><ul id="f33525f4-f280-4ea4-b791-574b1279e098" class="bulleted-list"><li style="list-style-type:disc"><strong>Promise có 3 trạng thái</strong><ul id="11bb9200-4157-490d-b867-3c79e4d22361" class="bulleted-list"><li style="list-style-type:circle"><mark class="highlight-yellow_background">Pending (đang xử lý)</mark></li></ul><ul id="3aed17e5-327d-40f9-a0cb-f8f1bfed5709" class="bulleted-list"><li style="list-style-type:circle"><mark class="highlight-yellow_background">Fulfilled (đã hoàn thành)</mark></li></ul><ul id="7133e4a1-ff7e-4cca-af37-0d8c3b98915d" class="bulleted-list"><li style="list-style-type:circle"><mark class="highlight-yellow_background">Rejected (đã bị từ chối)</mark></li></ul></li></ul></details></li></ul><ul id="17f27b54-8aa6-4d96-a749-2cc4df309c28" class="toggle"><li><details open=""><summary><strong>Async await</strong></summary><ul id="bdb03703-382c-42b0-9ed9-bb43b5d2d1ef" class="bulleted-list"><li style="list-style-type:disc">Trước đây, để làm việc với code bất đồng bộ, chúng ta sử dụng callback và promise, <mark class="highlight-yellow_background"><strong>Async/Await</strong></mark> là một cách mới để viết code bất đồng bộ.</li></ul><ul id="3672258d-d472-413d-8f6f-7a8f2e8c7b18" class="bulleted-list"><li style="list-style-type:disc">Nó được xây dựng trên Promise và tương thích với tất cả Promise dựa trên API</li></ul><ul id="da6d70d5-5496-4b38-b51c-1fbaa2ba478e" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-yellow_background"><strong>Async</strong></mark> được dùng để khai báo một hàm bất đồng bộ<ul id="8e9d2c0f-dd59-42e1-8711-ef4f995c8670" class="bulleted-list"><li style="list-style-type:circle">Tự động biến đổi một hàm thông thường thành một Promise.</li></ul><ul id="9d3f0598-e1e3-4af1-aa2a-a0ac362aa922" class="bulleted-list"><li style="list-style-type:circle">Khi gọi tới hàm async nó sẽ xử lý mọi thứ và được trả về kết quả trong hàm của nó.</li></ul><ul id="8cd3da20-7444-4fe3-b75d-7609a35c2df0" class="bulleted-list"><li style="list-style-type:circle">Async cho phép sử dụng Await</li></ul></li></ul><ul id="f6d2c783-9059-4fbb-a6e7-f73985860d89" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-yellow_background"><strong>Await</strong></mark> được sử dụng để chờ một Promise. Nó chỉ có thể được sử dụng bên trong một khối Async.<ul id="ee249ce9-bdc4-4653-9035-ca561f9fa296" class="bulleted-list"><li style="list-style-type:circle">Khi được đặt trước một Promise, nó sẽ đợi cho đến khi Promise kết thúc và trả về kết quả.</li></ul><ul id="c7fd6409-ffbe-41f0-8e02-177a19fab70f" class="bulleted-list"><li style="list-style-type:circle">Await chỉ làm việc với Promises, nó không hoạt động với callbacks.</li></ul><ul id="aa0c47ba-f971-4230-b199-6e6d4b9fb4ed" class="bulleted-list"><li style="list-style-type:circle">Await chỉ có thể được sử dụng bên trong các function async.</li></ul></li></ul><ul id="ddb9d7ba-212d-4c1f-8b3b-2d84651ccb3f" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-yellow_background"><strong>Dùng Async Await vì</strong></mark>:<ul id="14a9e3d5-8085-48ed-8cba-ec468b7efce9" class="bulleted-list"><li style="list-style-type:circle">Ngắn gọn, sạch sẽ: viết code tuần tự, làm cho số lượng code viết giảm đáng kể.</li></ul><ul id="a793b1a5-8b47-4c84-b9d1-23fa7b69b94f" class="bulleted-list"><li style="list-style-type:circle">Xử lý lỗi: giúp ta xử lý cả error đồng bộ lẫn bất đồng bộ theo cùng 1 cấu trúc</li></ul><ul id="1490af99-17e7-4598-852a-5e6a1b173a95" class="bulleted-list"><li style="list-style-type:circle">Câu lệnh điều kiện: giúp ta xử lý những câu điều kiện dựa vào kết quả trả về một cách dễ hiểu và nhanh hơn</li></ul><ul id="b7877302-4e31-4ac3-a833-e3b4574b76b2" class="bulleted-list"><li style="list-style-type:circle">Debug: việc debug trở nên dễ dàng hơn</li></ul></li></ul><ul id="eaab5858-2a4a-4f42-97ca-033bcf6fab41" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-yellow_background"><strong>Async / Await làm cho promise lỗi thời ?</strong></mark><ul id="f4b2702f-e606-4700-869b-34360d524e4d" class="bulleted-list"><li style="list-style-type:circle">Khi làm việc với Async / Await, thật ra chúng ta vẫn đang sử dụng ngầm Promises.</li></ul><ul id="4e2684c6-f399-42f2-ae95-cdcb08cbf22d" class="bulleted-list"><li style="list-style-type:circle">Vì thế, kể cả khi đang sử dụng Async / Await cần một sự hiểu biết tốt về Promises sẽ rất tốt cho chúng ta.</li></ul><ul id="a68065ad-6fab-451d-bd42-2e34c9c14954" class="bulleted-list"><li style="list-style-type:circle">Ngoài ra, có những trường hợp mà Async / Await không sử dụng được và chúng ta phải sử dụng Promises.</li></ul><ul id="c244a7a1-3656-42a1-a518-72210cfb3493" class="bulleted-list"><li style="list-style-type:circle">Ví dụ khi ta sử dụng để gọi song song các tác vụ bất đồng bộ và không phụ thuộc vào nhau thì async await không giải quyết được, nhưng <mark class="highlight-yellow_background"><strong>Promise.all()</strong></mark> có thể làm được</li></ul></li></ul></details></li></ul></details></li></ul><ul id="bd4fb49b-f557-4158-9aff-9aa472c44800" class="toggle"><li><details open=""><summary><a href="https://www.notion.so/Shallow-Deep-Copy-2331df1919544a089db204d0aaae3ac5"><strong>Shallow copy và deep copy trong js</strong></a></summary><ul id="87a94700-5a04-49d9-bab1-b09706dd1342" class="bulleted-list"><li style="list-style-type:disc"><strong>shallow copy</strong>: nhiệm vụ của nó chỉ copy những giá trị nông, nghĩa là nó sao chép những giá trị đối tượng bình thường nhưng các giá trị lồng nhau vẫn sử dụng để tham chiếu (reference) đến đối tượng ban đầu.</li></ul><ul id="7ee97108-51bb-4705-88d4-38b945436b6e" class="bulleted-list"><li style="list-style-type:disc"><strong>deep copy</strong>: đơn giản cũng giống với shallow copy nhưng các giá trị của reference trong object gốc không thay đổi trong object đã clone</li></ul></details></li></ul><ul id="b6452b67-8d8f-415f-8696-d529876d5f5b" class="toggle"><li><details open=""><summary><strong>localStorage &amp; sessionStorage &amp; cookies</strong></summary><ul id="4677fbca-1728-4802-a0ea-bf9ae62b9875" class="toggle"><li><details open=""><summary><mark class="highlight-yellow_background"><strong>sessionStorage</strong></mark><strong>:</strong> Dữ liệu chỉ tồn tại cho đến khi người dùng đóng tab hoặc đóng trình duyệt, còn lại mọi thứ đều giống localStorage</summary></details></li></ul><ul id="66a806dc-3d3a-4eaf-9974-b92672369943" class="toggle"><li><details open=""><summary><mark class="highlight-yellow_background"><strong>cookie</strong></mark><strong>:</strong> Thường có khoảng thời gian sống nhất định và tuỳ thuộc vào mục đích sử dụng sẽ có khoảng thời gian sử dụng khác nhau, ngoài hạn sử dụng cookie còn có thời gian sống (max-age) </summary><ul id="1e57a432-bca2-42a3-abce-3ad5fd092d2e" class="bulleted-list"><li style="list-style-type:disc">Khả năng lưu trữ thông thường khoảng 4 KB</li></ul><ul id="68bf9af4-e190-43c6-94bc-ab706ba53a7a" class="bulleted-list"><li style="list-style-type:disc">Thông tin được gửi lên server</li></ul><ul id="815be634-79e8-46bb-801a-34997509c4f7" class="bulleted-list"><li style="list-style-type:disc">Có thể đọc ở phía máy chủ khác với Local/Session Storage chỉ đọc được ở phía máy khách.</li></ul></details></li></ul><ul id="2b0fbaab-06c7-4615-9dc6-a15f298350e6" class="toggle"><li><details open=""><summary><mark class="highlight-yellow_background"><strong>localStorage</strong></mark><strong>: </strong>Dữ liệu được lưu trữ vô thời hạn, dữ liệu sẽ không mất đi trừ khi sử dụng chức năng xoá của trình duyệt hoặc dùng localStorage API để xoá.</summary><ul id="5d39a984-9176-4c22-81e5-7e82f73cd8ee" class="bulleted-list"><li style="list-style-type:disc"> Khả năng lưu trữ khoảng 5MB. </li></ul><ul id="5fc8807c-4f75-4d26-99f2-7d5a82c31221" class="bulleted-list"><li style="list-style-type:disc">Dữ liệu không được gửi đi đến server thông qua các request header.</li></ul><ul id="47a3cac4-f323-47fd-8b74-e0874737911d" class="bulleted-list"><li style="list-style-type:disc">Được lưu trữ trên trình duyệt của người dùng nên việc sử dụng sẽ không ảnh hưởng đến hiệu suất của trang web nhưng sẽ làm nặng trình duyệt (rất nhỏ gần như không đáng kể).</li></ul></details></li></ul></details></li></ul><ul id="a8ea59c7-5bc5-4e15-9bdd-69a477396d5f" class="toggle"><li><details open=""><summary><strong>Map, Set, WeakMap, WeakSet là gì?</strong></summary><ul id="76ee6504-934e-44ea-ab18-d1847339c638" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Map</strong></mark> trong JavaScript là một <strong>cấu trúc dữ liệu</strong> cho phép lưu trữ dữ liệu theo kiểu <strong>key-value</strong>, tương tự như object. Tuy nhiên, chúng khác nhau ở chỗ là:</summary><ul id="7a23c44f-5070-4124-8f16-e2c5fdb6c6ef" class="bulleted-list"><li style="list-style-type:disc"><strong>Object</strong> chỉ cho phép sử dụng String hay Symbol làm key</li></ul><ul id="46fca98e-7a7e-474b-871e-2763f533ced7" class="bulleted-list"><li style="list-style-type:disc"><strong>Map</strong> cho phép mọi kiểu dữ liệu (String, Number, Boolean, NaN, Object,...) có thể làm key và Map có thuộc tính <strong>size</strong> và một số phương thức đặc trưng</li></ul><ul id="73e0aa26-bb3e-4f82-83a9-af69ed6d4861" class="bulleted-list"><li style="list-style-type:disc">Một số phương thức và thuộc tính của Map:<ul id="599c0ab5-8cba-4a03-90ca-38ff53c545c9" class="bulleted-list"><li style="list-style-type:circle"><code>new Map([iterable])</code>: khởi tạo Map với tham số là một iterable object (không bắt buộc) với mỗi phần tử có dạng <code>[key, value]</code>.</li></ul><ul id="2fe96b72-0712-47a4-a304-5485b4e27748" class="bulleted-list"><li style="list-style-type:circle"><code>map.set(key, value)</code>: lưu <code>value</code> bởi <code>key</code> và trả về <code>map</code>.</li></ul><ul id="85426c4f-478c-418f-b759-aeec37bce5ac" class="bulleted-list"><li style="list-style-type:circle"><code>map.get(key)</code>: trả về <code>value</code> bởi <code>key</code>, nếu <code>key</code> không tồn tại thì trả về <code>undefined</code>.</li></ul><ul id="c40d8952-5c6a-43a6-86b8-abe97395f61c" class="bulleted-list"><li style="list-style-type:circle"><code>map.has(key)</code>: trả về <code>true</code> nếu <code>key</code> tồn tại, ngược lại thì trả về <code>false</code>.</li></ul><ul id="a6baabdc-cc23-4577-a290-24e6c72ab7d5" class="bulleted-list"><li style="list-style-type:circle"><code>map.delete(key)</code>: xóa giá trị ứng với <code>key</code> và trả về <code>true</code> nếu <code>key</code> tồn tại, ngược lại thì trả về <code>false</code>.</li></ul><ul id="e6ed5a92-9479-4606-a13e-db3130956464" class="bulleted-list"><li style="list-style-type:circle"><code>map.clear()</code>: xóa tất cả các phần tử trong <code>map</code>.</li></ul><ul id="e298eb49-9f17-4c26-a87e-4b3d25bfdf47" class="bulleted-list"><li style="list-style-type:circle"><code>map.size</code>: trả về số phần tử hiện tại có trong <code>map</code>.</li></ul></li></ul></details></li></ul><ul id="d19f5947-f8bf-4a1d-ad3e-48410626604e" class="toggle"><li><details open=""><summary><strong><mark class="highlight-red">Set</mark></strong><strong> trong Javascript </strong>là một loại object cho phép bạn lưu trữ dữ liệu một cách duy nhất, không trùng lặp.</summary><ul id="b8bb375b-0142-4710-a894-b4df94357f65" class="bulleted-list"><li style="list-style-type:disc">Set là một loại object</li></ul><ul id="98dae7cd-aea3-4d0c-b886-02353d0646b8" class="bulleted-list"><li style="list-style-type:disc">Dữ liệu trong set là duy nhất và không trùng lặp. Không trùng lặp ở đây được hiểu là các phần tử không được giống nhau. </li></ul><ul id="3c6ad00b-688a-49db-92db-fcd4722d86dc" class="bulleted-list"><li style="list-style-type:disc">Có thể lưu <code>NaN </code>và <code>undefined</code> vào Set trong JavaScript.</li></ul><ul id="8127feda-c675-410e-abfd-5276bc9c1008" class="bulleted-list"><li style="list-style-type:disc">Các phương thức của Set là:<ul id="5271292f-d466-4f40-b483-16b3c2d4c7c3" class="bulleted-list"><li style="list-style-type:circle"><code>new Set(iterable)</code>: khởi tạo Set bằng cách truyền vào một iterable object (không bắt buộc), trường hợp không truyền vào tham số nào thì Set sẽ rỗng.</li></ul><ul id="a1428443-ca73-4a65-8559-43279b1ce74b" class="bulleted-list"><li style="list-style-type:circle"><code>set.add(value)</code>: thêm phần tử <code>value</code> vào Set và trả về chính Set đó.</li></ul><ul id="d42e8774-2243-4087-9b38-30f495c56705" class="bulleted-list"><li style="list-style-type:circle"><code>set.delete(value)</code>: xóa một phần tử trong Set và trả về <code>true</code> nếu giá trị <code>value</code> tồn tại trong Set, ngược lại trả về <code>false</code>.</li></ul><ul id="d0882d03-89d5-4723-88f4-ce1c3f4bce5b" class="bulleted-list"><li style="list-style-type:circle"><code>set.has(value)</code>: trả về <code>true</code> nếu giá trị <code>value</code> tồn tại trong Set, ngược lại thì trả về <code>false</code>.</li></ul><ul id="efdb415c-f593-4a40-a908-7c919907743b" class="bulleted-list"><li style="list-style-type:circle"><code>set.clear()</code>: xóa tất cả các phần tử trong Set.</li></ul><ul id="cb384436-44de-4e10-a347-2195c01492ff" class="bulleted-list"><li style="list-style-type:circle"><code>set.size</code>: trả về số lượng phần tử trong Set.</li></ul></li></ul><p id="1cd21a83-a90c-498c-b386-21e952a97912" class=""><a href="https://completejavascript.com/ban-biet-gi-ve-set-trong-javascript/">https://completejavascript.com/ban-biet-gi-ve-set-trong-javascript/</a></p></details></li></ul><ul id="0aa16017-3761-47b8-a297-a646f7aedabb" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>WeakMap </strong></mark></summary><ul id="cf6473dc-a35a-4cf1-8b7d-0456b2ff9662" class="bulleted-list"><li style="list-style-type:disc">WeakMap trong JavaScript tương tự như Map, cho phép lưu trữ dữ liệu theo kiểu <code>key-value</code>. Tuy nhiên, WeakMap chỉ chấp nhận <strong>object</strong> làm <strong>key </strong>còn map thì cho phép tất cả mọi kiểu dữ liệu</li></ul><ul id="775abad9-0e46-424e-bdda-e22f076ab8e5" class="bulleted-list"><li style="list-style-type:disc">Khi object bị hủy, object tương ứng trong WeakMap sẽ bị giải phóng vì không còn cách nào để truy cập vào object đó nữa.<pre id="ba0d0387-02a1-4aa9-8759-3f5fbccfe94e" class="code"><code>let alex = { name: &quot;Alex&quot; };

// khai báo map và sử dụng biến alex làm key cho map
let map = new Map();
map.set(alex, &quot;1&quot;);

// ghi đè giá trị của biến alex
alex = null;

// mặc dù biến alex bị gán bằng null, nhưng object alex vẫn tồn tại trong map
console.log(map.size); // 1
for (let item of map) {
  console.log(item);
  /**
   * [{name: &#x27;Alex&#x27;}, &#x27;1&#x27;]
   */
}
// Để hủy ta phải dùng method delete trong map</code></pre><pre id="45bacaa5-6e03-4bbc-a915-f42379e29fb2" class="code"><code>let alex = { name: &quot;Alex&quot; };

// khai báo map và sử dụng biến alex làm key cho weakMap
let weakMap = new WeakMap();
weakMap.set(alex, &quot;1&quot;);

// ghi đè giá trị của biến alex
alex = null;

// Sau khi biến alex bị gán bằng null, 
// không còn cách nào có thể truy cập vào phần tử với key là alex trước đó. 
// Vì vậy, object với alex sẽ bị hủy.</code></pre></li></ul><ul id="be6741fe-40c4-4345-94b6-2b3c63aa211d" class="bulleted-list"><li style="list-style-type:disc">WeakMap không phải iterable object nên không có cách nào để duyệt hết các phần tử trong WeakMap (như cách dùng <code>for...of</code> với Map).</li></ul><ul id="8f09e634-3b09-4aca-b07e-c960de818ee4" class="bulleted-list"><li style="list-style-type:disc">Ứng dụng của weakMap:<ul id="81e75991-4533-4729-9df1-e589a7f4edc7" class="bulleted-list"><li style="list-style-type:circle">Lưu dữ liệu ví dụ lưu lại số lần truy cập của một đối tượng user</li></ul><ul id="762c4c7b-8d01-4bea-a8fd-324218eec1be" class="bulleted-list"><li style="list-style-type:circle">Caching dữ liệu</li></ul></li></ul><ul id="7db67477-c477-41e0-b701-b0aa59882d87" class="bulleted-list"><li style="list-style-type:disc">Các phương thức của WeakMap là:<ul id="17f494fb-bbaf-4148-b4ec-332227017c0f" class="bulleted-list"><li style="list-style-type:circle"><code>weakMap.set(key, value)</code>: lưu giá trị <code>value</code> vào thuộc tính <code>key</code> và trả về chính WeakMap.</li></ul><ul id="e9dc6b89-f6fd-4e40-ae93-ab03071efbed" class="bulleted-list"><li style="list-style-type:circle"><code>weakMap.get(key)</code>: trả về giá trị của thuộc tính <code>key</code>, nếu <code>key</code> không tồn tại thì trả về <code>undefined</code>.</li></ul><ul id="f28c4a2d-bc6a-405e-8052-57a435264682" class="bulleted-list"><li style="list-style-type:circle"><code>weakMap.delete(key)</code>: xóa thuộc tính <code>key</code> trong WeakMap, nếu <code>key</code> tồn tại thì trả về <code>true</code>, ngược lại thì trả về <code>false</code>.</li></ul><ul id="0b47f151-80d1-41ac-9a25-1094b9335e78" class="bulleted-list"><li style="list-style-type:circle"><code>weakMap.has(key)</code>: trả về <code>true</code> nếu <code>key</code> tồn tại trong <code>weakMap</code>, ngược lại thì trả về <code>false</code>.</li></ul></li></ul><p id="d6e8d463-3d6d-4563-91ed-ab040409ff58" class=""><a href="https://completejavascript.com/weakmap-trong-javascript/">https://completejavascript.com/weakmap-trong-javascript/</a></p></details></li></ul><ul id="2abd1b95-65be-498b-be0c-7c8ff25a1db6" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>WeakSet </strong></mark></summary><ul id="849e0984-37d8-4f16-836b-4b9ce0495f30" class="bulleted-list"><li style="list-style-type:disc">WeakSet trong JavaScript tương tự như Set, cho phép <strong>lưu trữ dữ liệu một cách duy nhất</strong>, không trùng lặp. Tuy nhiên, WeakSet chỉ chấp nhận phần tử kiểu object.</li></ul><ul id="8d98bf9c-ee58-4995-9a99-82dd73c93c27" class="bulleted-list"><li style="list-style-type:disc">Khi object bị hủy, object tương ứng trong WeakSet sẽ bị giải phóng vì không còn cách nào để truy cập vào object đó nữa.</li></ul><ul id="f4ad48c2-ba50-4a8a-9b5d-9e576458a37d" class="bulleted-list"><li style="list-style-type:disc">WeakSet không phải iterable object nên không có cách nào để duyệt hết các phần tử trong WeakSet (như cách dùng <code>for...of</code>
 với Set).</li></ul><ul id="f35e2523-6023-4950-8219-7793d0730c69" class="bulleted-list"><li style="list-style-type:disc">Các phương thức của WeakSet là:<ul id="1734b314-a6cf-4514-9e9d-be7e067aee80" class="bulleted-list"><li style="list-style-type:circle"><code>weakSet.add(value)</code>: lưu giá trị <code>value</code> vào WeakSet và trả về chính WeakSet.</li></ul><ul id="a9dfd861-8dd6-4a81-b1b0-f685d8ee3774" class="bulleted-list"><li style="list-style-type:circle"><code>weakSet.delete(value)</code>: xóa phần tử <code>value</code> trong WeakSet, nếu <code>value</code> tồn tại thì trả về <code>true</code>, ngược lại thì trả về <code>false</code>.</li></ul><ul id="9b467c33-e691-4eff-bc7b-67c641befd62" class="bulleted-list"><li style="list-style-type:circle"><code>weakSet.has(value)</code>: trả về <code>true</code> nếu <code>value</code> tồn tại trong <code>weakSet</code>, ngược lại thì trả về <code>false</code>.</li></ul></li></ul></details></li></ul></details></li></ul><ul id="875467dc-9d8e-4a1a-ac4d-6dbe65a99bd7" class="toggle"><li><details open=""><summary><strong>Sự khác biệt giữa </strong><strong><code>Set</code></strong><strong>, </strong><strong><code>WeakSet</code></strong><strong>, </strong><strong><code>Map </code></strong><strong>và </strong><strong><code>WeakMap</code></strong><strong> trong JavaScript là gì?</strong></summary><ul id="4bc62a3d-66f1-4b30-83e4-bd0f8709de3f" class="bulleted-list"><li style="list-style-type:disc"><code><strong>WeakSet</strong></code><code> </code>và <code><strong>Set</strong></code><strong> </strong>đều là tập hợp các giá trị duy nhất. Sự khác biệt chính là <code><strong>WeakSet</strong></code><code> </code>chỉ lưu trữ đối tượng và không thể chứa các giá trị tùy ý thuộc bất kỳ loại nào, nhưng các <code><strong>Set</strong></code>thì có thể.</li></ul><ul id="a960b252-0c7c-4266-9649-7b5f0b7330d3" class="bulleted-list"><li style="list-style-type:disc">Sets hữu ích khi bạn cần nối từng dữ liệu một vào cấu trúc dữ liệu nhưng cũng muốn loại bỏ các phần trùng lặp. Các hoạt động tập hợp có giá trị trung bình là <code><strong>O(1)</strong></code>, điều này làm cho chúng tiết kiệm thời gian.</li></ul><ul id="9aa65dc9-cf83-47b4-851a-4a78922eda48" class="bulleted-list"><li style="list-style-type:disc"><code><strong>WeakMap</strong></code> và <code><strong>Map</strong></code> là tập hợp các cặp khóa / giá trị. Sự khác biệt chính là trong <code><strong>WeakMap</strong></code>, các khóa phải là các đối tượng. Trong <code><strong>Map</strong></code>, các khóa có thể thuộc bất kỳ loại nào.</li></ul><ul id="3e4592e1-f499-4b2c-bb6e-39428f7ba981" class="bulleted-list"><li style="list-style-type:disc">Cũng cần biết rằng các giá trị <code><strong>WeakMap</strong></code> không thể được lặp lại và chúng giữ một tham chiếu yếu (weak reference) đến khóa. Ví dụ: nếu bạn xóa thủ công một khóa được tham chiếu trong <code><strong>WeakMap</strong></code>, khóa đó sẽ được thu gom.</li></ul></details></li></ul><ul id="6353ce9d-0d00-4464-9dc9-0e4b6d977595" class="toggle"><li><details open=""><summary><strong>setTimeout, setInterval</strong></summary><ul id="ca89d4b1-2123-4b2f-92e3-267031f6a406" class="bulleted-list"><li style="list-style-type:disc">Là những hàm cho phép bạn thực hiện một đoạn mã Javascript tại một thời điểm nào đó trong tương lai. Nó được gọi là &quot;lập lịch một cuộc gọi&quot; (scheduling a call)<ul id="3b470e2e-5089-4124-beb6-25b1abb7e47f" class="bulleted-list"><li style="list-style-type:circle"><strong><mark class="highlight-yellow_background">setTimeout</mark></strong>: sử dụng để thực thi một hàm hoặc đoạn mã được chỉ định chỉ một lần sau một khoảng thời gian nhất định.</li></ul><ul id="a1217a2f-7a56-4672-8c8c-9b18c2a8604f" class="bulleted-list"><li style="list-style-type:circle"><strong><mark class="highlight-yellow_background">setInterval</mark></strong>: sử dụng để thực thi một hàm hoặc đoạn mã được chỉ định lặp đi lặp lại vào những khoảng thời gian cố định.</li></ul></li></ul><ul id="a279ee38-ee7d-4c69-8960-f061771c2fc1" class="bulleted-list"><li style="list-style-type:disc">Dừng thực thi bộ đếm thời gian sử dụng: <mark class="highlight-yellow_background"><strong>clearTimeout() </strong></mark>và <strong><mark class="highlight-yellow_background">clearInterval()</mark></strong></li></ul></details></li></ul><ul id="c97a3078-7b31-4396-90bc-719f2485e8ae" class="toggle"><li><details open=""><summary><strong>Event loop trong JS</strong></summary><ul id="faababc3-672a-4b70-bd0f-b31600e07d28" class="bulleted-list"><li style="list-style-type:disc"><strong><mark class="highlight-yellow_background">Event Loop</mark></strong> là cơ chế giúp Javascript có thể thực hiện nhiều thao tác cùng một lúc (concurrent model)</li></ul><ul id="d7a2f797-613c-4abc-9d47-59a493b9a875" class="bulleted-list"><li style="list-style-type:disc"><a href="https://viblo.asia/p/cuoi-cung-thi-event-loop-la-gi-LzD5dX705jY">Cuối cùng thì event loop là gì ?</a></li></ul><ul id="861b5e95-c644-4f86-be74-02fbe837882b" class="bulleted-list"><li style="list-style-type:disc"><a href="https://dynonguyen.com/event-loop-bat-dong-bo-trong-javascript/">Event loop trong JS</a></li></ul><hr id="bfacc40e-2269-4381-b1ee-769b7e05996d"/><ul id="e409dc13-3bae-424b-9deb-8b1967a19ec3" class="bulleted-list"><li style="list-style-type:disc">Do JS đơn luồng nên nó chỉ xử lý được duy nhất một tác vụ trong cùng một thời điểm, điều này rất khác với các ngôn ngữ đa luồng (multi-thread) khác như C#, Java, PHP với mỗi tác vụ thì nó sẽ chia ra một luồng để xử lý.</li></ul><ul id="b9277a0b-dd82-43af-a704-d7bf8ac58f74" class="bulleted-list"><li style="list-style-type:disc">Nếu như thế thì JS rất dễ rơi vào tình trạng <strong>Blocking</strong> nếu gặp phải các tác vụ mất nhiều thời gian như xử lý nhiều request, call APIs, … </li></ul><ul id="50eed6a1-25b7-4574-a809-54e36213a3f9" class="bulleted-list"><li style="list-style-type:disc">Event Loop ra đời để giải quyết vấn đề này, khiến JS chỉ đơn luồng như cân tất nhiều tác vụ cùng lúc </li></ul><ul id="9fbc70ec-eb19-4a6f-9cd3-b9ff76d9635f" class="bulleted-list"><li style="list-style-type:disc"> Về Event Loop thì cần biết thêm 2 khái niệm đó chính là:<ul id="0512c5e7-5363-4c4f-a0a1-dcc190031680" class="bulleted-list"><li style="list-style-type:circle"><strong>Web APIs</strong>: bản chất Runtime của Javascript chỉ có 1 luồng và không thể chạy multi-thread, vì thế browser đã viết thêm một Web APIs để bọc runtime này lại (tương tự dưới NodeJS sẽ dùng C++ để bọc V8 lại). Web APIs này sẽ giúp cho JS có thể hoạt động một cách bất đồng bộ như multi-thread.</li></ul><ul id="35518d2e-defa-407e-8fff-c7afbf83b40a" class="bulleted-list"><li style="list-style-type:circle"><strong>Callback Queue</strong>: Như tên của nó là hàng đợi các callback do thằng Web APIs ở trên trả về.</li></ul></li></ul><ul id="e47e5088-2dde-49cd-b207-10349747ace3" class="bulleted-list"><li style="list-style-type:disc"><strong>Cách hoạt động:</strong><ul id="a1f2c948-db56-44d3-9026-bff4afaacda7" class="bulleted-list"><li style="list-style-type:circle">Khi hàm main được chạy thì các đoạn code trong main sẽ được thực thi. Nó sẽ lần lượt đẩy các hàm vào bên trong call stack theo nguyên tắc LIFO</li></ul><ul id="f8c84123-c83d-48a9-b3b4-28aaa91def3e" class="bulleted-list"><li style="list-style-type:circle">Các hàm hay tác vụ liên quan đến Events (click, change, listener, …), AJAX (Call APIs), Timing (setTimeout, setInterval) sẽ được đẩy từ call stack sang Web APIs. Còn lại thì sẽ được thực thi trong call stack đến khi nào xong thì pop nó ra cho hàm bên dưới được thực thi.</li></ul><ul id="d38e8e0d-58c6-421c-8401-de390d01f273" class="bulleted-list"><li style="list-style-type:circle">Ở Web APIs sẽ tận dụng các nhân của thiết bị để xử lý riêng biệt các tác vụ này. Sau khi hoàn tất thì Web APIs sẽ trả về một callback và đẩy nó vào trong Callback Queue.</li></ul><ul id="168931d5-414a-42eb-a819-e9bed4d4f975" class="bulleted-list"><li style="list-style-type:circle">Callack Queue hoạt động theo nguyên tắc của queue là FIFO (vào trước ra trước) không như stack.</li></ul><ul id="7b446982-d914-4921-a597-7a91dfec052b" class="bulleted-list"><li style="list-style-type:circle">Event loop hiểu nôm na là một vòng lặp vô tận, nó luôn trực chờ ở đó để quan sát Callback Queue và bé Call stack.</li></ul><ul id="25658759-d894-4e77-8868-d9cf60bf69da" class="bulleted-list"><li style="list-style-type:circle">Bất kể khi nào mà call stack trống (tất cả các hàm được pop ra) thì nó sẽ nắm các thằng callback ở trong Callback Queue và ném vào trong Call Stack để tiếp tục thực thi.</li></ul></li></ul></details></li></ul><p id="3c697df8-c540-46c5-ae00-17c22e1fac55" class="">
</p><hr id="ed2bffd7-8d7c-4bc3-9f6a-521732c6a7af"/><p id="2a2cb52a-0b4f-49d5-8208-81c2fd430c7a" class="">
</p><h2 id="c80655d6-f557-4b8c-b1be-0f81086e73b8" class=""><mark class="highlight-red">TS</mark></h2><hr id="c7bfd0e3-0026-45a3-9266-e263a2992c1a"/><ul id="b87de303-60e6-453f-a5fe-3150b03c0a56" class="toggle"><li><details open=""><summary><strong>Các kiểu dữ liệu trong TS?</strong></summary><ul id="494e05e9-15c5-4b72-81ec-015318029e1c" class="bulleted-list"><li style="list-style-type:disc"><strong>union</strong>: cho phép sử dụng nhiều kiểu dữ liệu trong 1 biến</li></ul><ul id="9155980c-16b3-437c-be42-68b4d8ec5863" class="bulleted-list"><li style="list-style-type:disc"><strong>any</strong>: khi không biết trước kiểu dữ liệu là gì </li></ul><ul id="545cab8b-814b-42b7-b4fb-95f558c31205" class="bulleted-list"><li style="list-style-type:disc"><strong>void</strong>: dùng để thông báo function không có giá trị trả về</li></ul><ul id="000fe067-5760-4bc0-b2d3-ec71df1bd4dc" class="bulleted-list"><li style="list-style-type:disc"><strong>never</strong>: giá trị đó sẽ không xảy ra. Được sử dụng khi chắc chắn việc gì đó không xảy ra </li></ul><ul id="030a27b8-4847-4cb9-815f-da4b94b2d9e8" class="bulleted-list"><li style="list-style-type:disc"><strong>unknown: </strong>giống như any nhưng ta không thể thực hiện bất kỳ thao tác nào khi mà chưa xác định type cụ thể của biến đó.</li></ul><ul id="a2023614-87a1-439b-9d3c-769c787951fb" class="bulleted-list"><li style="list-style-type:disc"><strong>tuple</strong>: có thể hiểu là kiểu dữ liệu mở rộng của array. Giúp chúng ta kiểm soát được thứ tự kiểu dữ liệu của các phần tử trong array.</li></ul><ul id="4c134bb8-f693-4a1f-a90c-f5114aabe70f" class="bulleted-list"><li style="list-style-type:disc"><strong><strong>intersection: </strong></strong>cho phép bạn kết hợp các thành viên của hai hoặc nhiều kiểu bằng cách sử dụng toán tử <code>&amp;</code>. Điều này cho phép bạn kết hợp các kiểu hiện có để có được một kiểu duy nhất với tất cả các tính năng bạn cần.</li></ul></details></li></ul><ul id="e056b3b0-8e5d-4752-8ca3-be69869a7571" class="toggle"><li><details open=""><summary><strong>null và undefined trong TS?</strong></summary><ul id="ab48ac03-4f57-4cb3-948f-5727f6845b14" class="bulleted-list"><li style="list-style-type:disc"><strong>null</strong>: giá trị null cho biết không có giá trị. Một biến null không trỏ đến bất kỳ đối tượng nào. Do đó, bạn không thể truy cập bất kỳ thuộc tính nào trên biến hoặc gọi một phương thức trên đó.</li></ul><ul id="70231076-fa8b-457c-bca3-3555a9a7e341" class="bulleted-list"><li style="list-style-type:disc"><strong><strong>undefined: </strong></strong>khi một biến được khai báo mà không tạo giá trị, nó sẽ được gán giá trị undefined.</li></ul></details></li></ul><ul id="e1e1f2a6-8a15-418e-993c-986d917aa05a" class="toggle"><li><details open=""><summary><strong>Enum trong TS?</strong></summary><ul id="3bda00e2-e7ce-4860-9038-af5ee7b5865a" class="bulleted-list"><li style="list-style-type:disc">Enum là từ viết tắt của Enumeration (sự liệt kê), Enum dùng để định nghĩa kiểu dữ liệu với số lượng giá trị hữu hạn.</li></ul></details></li></ul><ul id="0f73f087-8e09-471d-b2f4-5a1e6d220b7a" class="toggle"><li><details open=""><summary><strong>Tự suy trong TS là gì ?</strong></summary><ul id="5e20997c-51c0-4556-878f-9cdd322ef57d" class="bulleted-list"><li style="list-style-type:disc">TypeScript có thể tự suy kiểu của biến nếu bạn không cung cấp kiểu cụ thể.</li></ul><ul id="78869d22-9592-4811-add7-72d511a149b0" class="bulleted-list"><li style="list-style-type:disc">Diều này gọi là tự suy kiểu. Nó thường dùng khi các biến hoặc tham số được khởi tạo khi khai báo.</li></ul></details></li></ul><ul id="2d962a78-6c7a-45e7-9dac-f079ea8be712" class="toggle"><li><details open=""><summary><strong><strong>Interface và type khác nhau gì ?</strong></strong></summary><ul id="5ecaf3f4-0039-4770-921a-d7db3358f17b" class="bulleted-list"><li style="list-style-type:disc">Cả <strong>Interface</strong> và <strong>type</strong> trong ts cho phép bạn định nghĩ thuộc tính và phương thức là gì mà đối tượng cần để được triển khai (implement).</li></ul><ul id="2ce19bb2-679b-484b-82f0-87b852c3ad40" class="bulleted-list"><li style="list-style-type:disc">Nếu đối tượng tuân thủ đúng theo khuôn mẫu thì sẽ được thực thi đúng ngược lại sẽ báo lỗi</li></ul><ul id="b3bd198e-dc97-45dc-8c35-a1e813f8a2d1" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>Một số điểm khác nhau:</strong></span><ul id="70f2d60d-aa7f-4748-b7f1-ac24529c9adf" class="bulleted-list"><li style="list-style-type:circle"><strong><strong>Type aliases có thể sử dụng computed properties </strong></strong><ul id="23be2f4c-8968-4d49-aba1-61189b5f2ee6" class="bulleted-list"><li style="list-style-type:square">Từ khóa <code>in </code>có thể được sử dụng để iterate tất cả các item bên trong một tập hợp keys. Chúng ta có thể sử dụng tính năng này để tạo mapped types.</li></ul></li></ul><ul id="5eadff70-5527-455d-addf-1a15b8400f4d" class="bulleted-list"><li style="list-style-type:circle"> <strong>interface</strong> có thể kế thừa từ 1 interface khác được còn <strong>type</strong> thì không</li></ul><ul id="f46c7406-aead-4cad-bb4c-9b3a31066040" class="bulleted-list"><li style="list-style-type:circle"><strong>Interface</strong> có thể <strong>merge</strong>, <strong>type</strong> thì không. Nhiều khai báo có cùng tên chỉ hợp lệ khi sử dụng <code>interface</code>. Làm như vậy sẽ không ghi đè trước đó mà tạo ra kết quả hợp nhất chứa từ tất cả các khai báo</li></ul></li></ul></details></li></ul><ul id="840d979a-f1f2-4b8d-b034-2e06488e7ab1" class="toggle"><li><details open=""><summary><strong>Generic trong TS?</strong></summary><ul id="c877c321-4257-441e-8a44-9bfbc2377965" class="bulleted-list"><li style="list-style-type:disc">Hiểu nôm na: kiểu dữ liệu mà có nhận tham số và trả về kiểu dữ liệu tương ứng.</li></ul><ul id="6160445f-eed0-43ae-a1de-e17e421dcacd" class="bulleted-list"><li style="list-style-type:disc">Hoặc hiểu đơn giản thì Generic type là việc cho phép truyền type vào components(function, class, interface) như là 1 tham số.Điều này sẽ giúp các components mềm dẻo hơn. Tái sử dụng tốt hơn.</li></ul></details></li></ul><p id="877130e8-42c3-4e57-869b-70c39fc5c776" class="">
</p><hr id="2e317dea-2df3-42b4-8c6b-f3206ef02d0e"/><p id="52e5140f-f904-440e-bedf-e91d88e718f0" class="">
</p><p id="8b5f154c-9662-4738-ae10-b9098c8821ec" class="">
</p><h2 id="edfabd27-b6c3-45db-b01d-21ed89b715d7" class=""><mark class="highlight-red">REACTJS</mark></h2><hr id="9d11150b-19f3-4645-97ea-ec08f30d45a4"/><ul id="89935c99-86b8-4695-845a-709555bf19ab" class="toggle"><li><details open=""><summary><strong>React là gì, ưu điểm, hạn chế?</strong></summary><ul id="10d699bd-58e9-4610-8c9d-543954d38856" class="bulleted-list"><li style="list-style-type:disc">React là một lib, open source đùng để phát triển giao diện người dùng. Dùng cho các app SPA. Nó hữu ích trong việc tạo các UI phức tạp và có thể tái sử dụng tuân theo mô hình component.</li></ul><ul id="43f62c98-307f-4503-ae36-ee274534e77a" class="bulleted-list"><li style="list-style-type:disc">Một số tính năng của react như: <ul id="6354b28d-d069-4a1e-96b1-2aa0b08f0278" class="bulleted-list"><li style="list-style-type:circle">Tăng hiệu suất của app bằng việc sử dụng Virtual DOM</li></ul><ul id="d6e53f33-9085-4818-ab49-fbca1cae272c" class="bulleted-list"><li style="list-style-type:circle">JSX giúp code dễ đọc và dễ viết</li></ul><ul id="7a9280ec-c9d4-42ce-82bb-c252d2ae88e7" class="bulleted-list"><li style="list-style-type:circle">Có thể render cả 2 phía client và server</li></ul><ul id="209a0207-8936-4b17-afd7-f7e67a0bb34c" class="bulleted-list"><li style="list-style-type:circle">Dễ testing hoặc kết hợp với những framework khác</li></ul><ul id="2efaf58c-7a2d-4c54-88c2-ec9d244be980" class="bulleted-list"><li style="list-style-type:circle">Cộng đồng lớn và được hậu thuẫn bởi facebook</li></ul></li></ul><ul id="90ce6b16-6f0d-4c8c-9f28-fbd12f4ae5c2" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>Ưu điểm</strong></span><ul id="fe1b1932-c5c2-497e-bb71-57eb63b2e582" class="bulleted-list"><li style="list-style-type:circle">Viết code dễ dàng hơn khi sử dụng JSX có thể nhúng mã HTML CSS và JS</li></ul><ul id="8c1973b2-4bcc-4119-be78-2270e1f85c60" class="bulleted-list"><li style="list-style-type:circle">Sử dụng component, giúp chia nhỏ ứng dụng thành phần những thành phần nhỏ hơn và có thể tái sử dụng được</li></ul><ul id="e842acd3-86c5-4c3b-9e89-ddbaa85c05dd" class="bulleted-list"><li style="list-style-type:circle">Hệ sinh thái đa dạng từ app CSR, SSR, app native, hay app desktop với electron, …</li></ul></li></ul><ul id="302b9fd5-1242-4499-b72d-116febbc201e" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>Nhược điểm:</strong></span><ul id="cb0d31c6-3c50-45ba-91ec-ec363375e384" class="bulleted-list"><li style="list-style-type:circle">React không phải là 1 framework hoàn chỉnh mà chỉ là thư viện, phụ thuộc vào cộng đồng và LIB bên ngoài nhiều</li></ul></li></ul></details></li></ul><ul id="521b7624-8a91-4e3f-bb9f-7f0ca2f9b5c8" class="toggle"><li><details open=""><summary><strong>Vòng đời life cycle của REACT</strong></summary><p id="e389a6c9-4b83-4472-a2d9-56a40a97bdb9" class=""><strong>Có 3 giai đoạn trong vòng đời component React.</strong></p><ul id="afb42756-4094-4930-8d61-2fb6af95ac2c" class="bulleted-list"><li style="list-style-type:disc"><strong>Mounting</strong>: đề cập đến việc đưa phần tử vào DOM của trình duyệt. Vì React dùng virtual DOM, toàn bộ DOM của trình duyệt đã render sẽ không được làm mới. Bao gồm các phương thức trong giai đoạn này như: <code>constructor</code> và <code>componentDidMount</code>.</li></ul><ul id="214ae5b3-ac94-4238-b29a-79ff99dc1159" class="bulleted-list"><li style="list-style-type:disc"><strong>Updating</strong>: Trong giai đoạn này, component sẽ được cập nhật khi có thay đổi state hoặc props của component. Các phương thức trong giai đoạn này: <code>getDerivedStateFromProps</code>, <code>shouldComponentUpdate</code>, <code>render</code>, và <code>componentDidUpdate</code>.</li></ul><ul id="9f112a4d-26b2-404c-b147-493bafb6ae76" class="bulleted-list"><li style="list-style-type:disc"><strong>Unmounting</strong>: Ở giai đoạn cuối, component sẽ bị xoá khỏi DOM. Giai đoạn này sẽ có phương thức là <code>componentWillUnmount</code></li></ul><p id="f875721b-5d17-4381-ab49-0bae50c3f9d7" class="">
</p><p id="756115ee-fcb5-409f-b9e1-6d89e227adcd" class="">Ngoài ra còn có nhiều method khác nữa nhưng đây là những method hay dùng nhất trong vòng đời react</p><hr id="8277863d-3b26-4190-a8cc-16f20356f657"/><p id="a7a293fd-fa00-4dc1-a6d9-9a3bc1a93d9a" class=""><strong>Các phương thức trong vòng đời:</strong></p><ul id="13f32c16-bb82-41e2-92e6-30e63fdc7e74" class="bulleted-list"><li style="list-style-type:disc"><code>constructor()</code>: phương thức được gọi khi component được tạo trước khi thực hiện bất kỳ hành động gì. Nó giúp tạo state và props.</li></ul><ul id="99ca0846-6d7e-4705-af64-77bfed9c54a0" class="bulleted-list"><li style="list-style-type:disc"><code>getDerivedStateFromProps()</code>: nó sẽ gọi trước khi phần tử được render vào DOM. Nó giúp thiết lập đối tượng state dựa trên props khởi tạo. Phương thức <code>getDerivedStateFromProps</code> sẽ có một state như đối số và trả về một đối tượng để thay đổi state. Nó sẽ là phương thức đầu tiên được gọi khi thực hiện cập nhật.</li></ul><ul id="2aeabdf1-5c81-4439-93ac-5c1130c71ccd" class="bulleted-list"><li style="list-style-type:disc"><code>render()</code>: phương thức này sẽ render HTML từ DOM với thay đổi mới nhất. Phương thức <code>render</code> sẽ được gọi mỗi khi có thay đổi đến component.</li></ul><ul id="adf58291-7a0d-434e-8c52-dc629975a39a" class="bulleted-list"><li style="list-style-type:disc"><code>componentDidMount()</code>: phương thức sẽ được gọi sau khi render component. Ta có thể chạy lệnh cần component đã được lưu trong DOM.</li></ul><ul id="e5a5ef3c-cc0e-459e-b225-169bd53449ca" class="bulleted-list"><li style="list-style-type:disc"><code>shouldComponentUpdate()</code>: trả về giá trị boolean để quyết định xem có render hay không. Mặc định sẽ là True.</li></ul><ul id="d59a6265-32f0-4348-b769-68fcc9a961f9" class="bulleted-list"><li style="list-style-type:disc"><code>getSnapshotBeforeUpdate()</code>: cung cáp truy cập cho props cung như state trước khi cập nhật. Nó dùng cho kiểm tra giá trị trước khi cập nhật.</li></ul><ul id="1bf7e278-16a1-4033-a22b-752a44f8f4e4" class="bulleted-list"><li style="list-style-type:disc"><code>componentDidUpdate()</code>: được gọi sau khi cập nhật component trong DOM.</li></ul><ul id="2581f5fc-90f4-40a8-b4db-8c6e13161840" class="bulleted-list"><li style="list-style-type:disc"><code>componentWillUnmount()</code>: phương thức được gọi khi component bị xoá khỏi DOM.</li></ul></details></li></ul><ul id="0c8f2ecf-226a-4c28-9269-25eb41d86d84" class="toggle"><li><details open=""><summary><strong>Virtual DOM và Real DOM</strong></summary><ul id="0b912cec-7850-42ef-92f5-3847eb32e5c2" class="bulleted-list"><li style="list-style-type:disc"><code>DOM</code> là viết tắt của Document Object Model (Mô hình Đối tượng Tài liệu) dùng để truy xuất các tài liệu dạng HTML và XML. DOM đại diện cho một tài liệu như là một cây cấu trúc dữ liệu. Còn node thì đại diện cho một phần tử trong DOM.</li></ul><ul id="2b8059a3-c73e-49f8-b580-b74bfc7c78da" class="bulleted-list"><li style="list-style-type:disc"><code>Virtual DOM</code> (VDOM hay DOM ảo) , là cách thể hiện DOM thật của một trang web dưới dạng các Javascript object. Khi thay đổi state của app thì VDOM sẽ được cập nhật lại và so sánh với VDOM cũ (VDOM cũ được đồng bộ hóa với DOM thật trước đó) bằng thuật toán gọi là diffing hay change detection để tìm ra những node cần thay đổi. Cuối cùng nó sẽ cập nhật những node đó trên DOM thật.</li></ul></details></li></ul><ul id="2962a547-3142-4f94-aa28-a51d9686c63f" class="toggle"><li><details open=""><summary><strong>Tại sao cần VirtualDom ?</strong></summary><ul id="d57afa63-9097-489c-a264-4b38cf09fe29" class="bulleted-list"><li style="list-style-type:disc">Thao tác DOM là 1 phần không thể thiếu của bất ký app nào. Tuy nhiên thao tác DOM khá chậm so với các thao tác trong JS</li></ul><ul id="463f3071-f3cc-42a1-ae0f-fcccc24a9a4c" class="bulleted-list"><li style="list-style-type:disc">Dẫn đến hiệu năng của app bị ảnh hưởng khi thực hiện thao tác trực tiếp trên DOM</li></ul><ul id="c8278099-671a-460c-ad23-02ebfe6c070e" class="bulleted-list"><li style="list-style-type:disc">Trước đó thì những Framework JS sẽ cập nhật toàn bộ lại DOM dù cho ta chỉ có thay đổi 1 hoặc 1 vài thành phần</li></ul><ul id="2d36bf29-068c-4efe-8b42-4d64e10ca0f8" class="bulleted-list"><li style="list-style-type:disc">React đưa ra khái niệm VD để giải quyết vấn đề đó</li></ul><ul id="54ed8120-ebe0-419c-8879-02ca57db861e" class="bulleted-list"><li style="list-style-type:disc">Đối với mỗi đối tượng DOM sẽ có 1 VD tương ứng, nó có các tính giống nhau. </li></ul><ul id="f3feed49-6851-4013-8347-3b93f67f48bf" class="bulleted-list"><li style="list-style-type:disc">Sự khác nhau cơ bản là khi có sự thay đổi trên VD nó sẽ không phản ánh trực tiếp lên màn hình.</li></ul><ul id="f622cdd1-ca07-468a-9d3c-85c8697c053b" class="bulleted-list"><li style="list-style-type:disc">React sử dụng 2 VD để hiển thị. Một cái dùng để lưu trữ trạng thái hiện tại và 1 cái là trước đó. </li></ul><ul id="e583654a-33b1-4c0a-9560-b0d69fdaa846" class="bulleted-list"><li style="list-style-type:disc">Khi có sự cập nhật trên VD nó sẽ so sánh 2 bản VD đó để tìm ra node cần thay đổi.</li></ul><ul id="21f63c00-b68b-4f3a-8bb5-831062aa3d14" class="bulleted-list"><li style="list-style-type:disc">Và chỉ cập nhật những node đó trên DOM thật, thay vì toàn bộ.</li></ul></details></li></ul><ul id="923cb004-b5d1-49e4-af95-b488d8127c6d" class="toggle"><li><details open=""><summary>N<strong>guyên tắc </strong><mark class="highlight-red"><strong><em>single source of truth</em></strong></mark><strong><em> </em></strong><strong>ở trong React là gì ?</strong></summary><ul id="c71d0fed-1440-4494-bc12-2f50e7536622" class="bulleted-list"><li style="list-style-type:disc">Thông thường với việc sử dụng HTML + JS thì state hoặc value của thẻ <code>&lt;input /&gt;</code>
 được điều khiển bằng <strong>browser</strong> chứ không phải là do <strong>JS</strong>. </li></ul><ul id="09f07c45-0980-4bc5-822d-7a1151f2a3bf" class="bulleted-list"><li style="list-style-type:disc">Nếu bạn cũng giữ giá trị của đầu vào như vậy trong JS thì nó có nghĩa rằng có ít nhất &quot;two sources of truth - 2 nguồn của sự thật&quot;</li></ul><ul id="590cfed4-e487-4292-b530-19dfee8837be" class="bulleted-list"><li style="list-style-type:disc">Với controlled component trong React thì <strong>state</strong> và <strong>value</strong> luôn luôn khớp với nhau. </li></ul><ul id="64621e53-d49c-4a90-b23f-99a29cc82e3e" class="bulleted-list"><li style="list-style-type:disc">Bởi vì, React luôn đảm bảo rằng giá trị của element input trong browser bằng với giá trị bạn cung cấp từ JS. </li></ul><p id="fcf6dd1f-35f4-4e4f-bfb1-e8f2156b755f" class="">→ Nó chính là &quot;single source of truth&quot;.</p></details></li></ul><ul id="e42a62d6-3c41-4d48-834f-05d16d0f198f" class="toggle"><li><details open=""><summary><strong>Controlled component khác gì uncontrolled component?</strong></summary><ul id="89e596e6-a727-4b1b-81c9-71e98c103bee" class="bulleted-list"><li style="list-style-type:disc"><strong>Controlled component: </strong><ul id="78c5b82f-1e38-41ff-a29f-7b3ad7b6ae33" class="bulleted-list"><li style="list-style-type:circle">giá trị của phần tử <strong>input</strong> được điều khiển bởi <strong>React</strong></li></ul><ul id="938887d6-0a2a-4c7f-9208-1ace1d6f4eb7" class="bulleted-list"><li style="list-style-type:circle">Ta lưu trữ trạng thái của phần tử input trong code, và sử dụng <strong>callback, </strong>với bất kỳ thay đổi nào đến input sẽ được phản ánh tương tự trong code.</li></ul><ul id="807ee0c5-3ad4-4548-8227-34b36e52fba0" class="bulleted-list"><li style="list-style-type:circle">Khi người dùng nhập dữ liệu vào phần tử input trong controlled component, hàm <code>onChange </code>kích hoạt </li></ul><ul id="6cad9bb1-3371-450c-a01b-256bc096dab5" class="bulleted-list"><li style="list-style-type:circle">và ta kiểm tra giá trị nhập vào là hợp lệ hay không. Nếu hợp lệ, ta thay đổi trạng thái và re-render phần tử input với giá trị mới.</li></ul></li></ul><ul id="59a0a056-253e-4f02-94d0-2821c40f90af" class="bulleted-list"><li style="list-style-type:disc"><strong>Uncontrolled component:</strong><ul id="080798d3-fbcd-4e65-a2e3-13404b81eef2" class="bulleted-list"><li style="list-style-type:circle">gái trị của phần tử input được xử lý bởi DOM</li></ul><ul id="249e39d8-730a-4af5-b5e1-2a97dfd79abd" class="bulleted-list"><li style="list-style-type:circle">các phần tử input này hoạt động giống như phần tử input HTML.</li></ul><ul id="6a3e39e0-97e4-4805-ba99-01c370b06e6f" class="bulleted-list"><li style="list-style-type:circle">trạng thái của phần tử input được xử lý bởi DOM. </li></ul><ul id="06b6dcfe-778a-46ff-ba80-e76ad7682926" class="bulleted-list"><li style="list-style-type:circle">Nên khi giá trị input thay đổi, callback sẽ không được gọi. </li></ul><ul id="4728dec0-bff2-4b7b-947e-d1fc893f121b" class="bulleted-list"><li style="list-style-type:circle">Hoặc có thể nói là React không thực hiện bất cứ hành động nào khi xảy ra thay đổi.</li></ul><ul id="c33281d0-ac8b-405e-b011-c820f43ad47a" class="bulleted-list"><li style="list-style-type:circle">Khi người dùng nhập dữ liệu vào trường input, dữ liệu cập nhật được hiển thị trực tiếp. </li></ul><ul id="82134bf6-f3cc-4bf8-a4c5-317733b7bfbb" class="bulleted-list"><li style="list-style-type:circle">Để truy cập giá trị phần tử input, ta có thể dùng <strong>ref</strong>.</li></ul></li></ul></details></li></ul><ul id="78619359-6410-499c-b831-2e1b98a7cc48" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>state</strong></mark><strong> và </strong><mark class="highlight-red"><strong>props</strong></mark><strong> trong react là gì ?</strong></summary><ul id="00e91107-ee29-4587-b7ea-0e41736a5b75" class="bulleted-list"><li style="list-style-type:disc"><strong>State </strong>là đối tượng bên trong 1 component dùng để chứa thông tin hoặc dữ liệu về component. Bất cứ sự thay đổi nào về state trong component cũng dẫn đến việc re-render.  Chỉ được khởi tạo và chỉnh sửa chỉ chính bản thân component chứa nó</li></ul><ul id="c8002fb9-9073-4a8a-837b-b2cae59414d7" class="bulleted-list"><li style="list-style-type:disc"><strong>Props</strong> là đối tượng nhận vào của 1 component, cho phép giao tiếp những component với nhau bằng cách truyền tham số qua lại giữa các component </li></ul><p id="2bbc255f-2b66-4c15-8a72-b4406f4d08e5" class="">→ Điểm khác nhau lớn nhất giữa props và state đó là props không thể thay đổi, còn state có thể thay đổi do đó hiệu năng của props tốt hơn state.</p></details></li></ul><ul id="dd2f2a54-b1e4-471a-af56-0da946c04099" class="toggle"><li><details open=""><summary><strong>stateless và stateful component là gì ?</strong></summary><ul id="b1ec36f9-4875-4fd6-a90b-d2a918249f26" class="bulleted-list"><li style="list-style-type:disc">Stateless component là các component chỉ chứa props, các component loại này chỉ dùng để render() thì sẽ hiệu quả hơn.</li></ul><ul id="e6e21a39-91ef-44f6-b571-c656083a1db1" class="bulleted-list"><li style="list-style-type:disc">Stateful Component là các component chứa cả props và state, các component này được dùng xử lý data, phản hỏi yêu cầu người dùng, phù hợp cho mô hình client server…</li></ul></details></li></ul><ul id="894a8844-6095-4dd6-831e-1668a4251d93" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>JSX</strong></mark><strong> là gì ?</strong></summary><ul id="896efd1a-7327-4daf-8045-9cbb540b2b98" class="bulleted-list"><li style="list-style-type:disc">JSX là viết tắt của JavaScript XML. </li></ul><ul id="dac7d75c-0f25-4ea4-8a0d-43d2ab28a72a" class="bulleted-list"><li style="list-style-type:disc">Nó cho phép ta viết HTML trong JS và đặt nó vào DOM mà không cần dùng <code>appendChild()</code> hay <code>createElement()</code>.</li></ul></details></li></ul><ul id="24f7152e-3ab0-4241-8d2d-b94b5e358bad" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Keys</strong></mark><strong> trong react dùng để làm gì </strong></summary><ul id="9f1ba77a-fb01-4494-8ac1-1725b0c6f1f0" class="bulleted-list"><li style="list-style-type:disc">Key là một thuộc tính đặc biệt trong element được dùng khi render ra danh sách các phần tử</li></ul><ul id="270f0b1b-d85a-4af4-be61-275a8ddcffa8" class="bulleted-list"><li style="list-style-type:disc">Key giúp chúng ta định danh các phần tử trong 1 danh sách, mỗi phần tử là unique trong danh sách</li></ul><ul id="d4827286-58d4-4826-bbc0-87f1c2ea951c" class="bulleted-list"><li style="list-style-type:disc">Nếu không dùng key thì react nó sẽ không hiểu được thứ tự của từng phần từ trong danh sách.</li></ul></details></li></ul><ul id="72e162fc-9e27-42de-bb57-26af53180a81" class="toggle"><li><details open=""><summary><strong>Sự khác nhau giữa class component và function component?</strong></summary><ul id="d0bf106d-d9b5-45d1-842d-7f6cba85961d" class="bulleted-list"><li style="list-style-type:disc">Trước đây, các function component được gọi là stateless component và ít dùng trong react.</li></ul><ul id="fccd7637-84a1-47a7-b2e5-4da07b3c54f8" class="bulleted-list"><li style="list-style-type:disc">Sau khi hooks ra đời ở những phiên bản sau thì việc sử dụng function component ngày càng nhiều</li></ul><ul id="4017435e-c83e-4e1a-b8a0-f7a626671ad0" class="bulleted-list"><li style="list-style-type:disc">Dù function component đang là trend hiện tại, nhưng class component vẫn còn rất quan trọng.</li></ul><ul id="69dbe07d-f02c-43d5-bbd4-e961da9fbc36" class="bulleted-list"><li style="list-style-type:disc">Một số điểm khác biệt đến từ<ul id="55727a07-71d6-4bbe-80b6-7c54146860a2" class="bulleted-list"><li style="list-style-type:circle">Cách khai báo: function thay vì class</li></ul><ul id="743ee63d-921d-434a-8c0b-508f4db3ab8e" class="bulleted-list"><li style="list-style-type:circle">Cách xử lý props, state </li></ul><ul id="f30e431d-3e77-4788-a170-dac50b4a77cc" class="bulleted-list"><li style="list-style-type:circle">Cú pháp</li></ul></li></ul></details></li></ul><ul id="010a0ca4-8cd6-465f-a1ab-d7ff01f00d36" class="toggle"><li><details open=""><summary><strong>React hook là gì và tại sao cần dùng nó?</strong></summary><ul id="505bb67c-3f25-420e-99ab-4dbb65514296" class="bulleted-list"><li style="list-style-type:disc">RH là một tính năng mới của react được giới thiệu ở phiên bản 16. </li></ul><ul id="053a7245-42ad-464c-997d-eba0ca7308ce" class="bulleted-list"><li style="list-style-type:disc">Giúp chúng ta viết component bằng function thay vì sử dụng class như các phiên bản trước.</li></ul><ul id="e0e2fe22-14c9-4431-83c8-3b0e94065f0d" class="bulleted-list"><li style="list-style-type:disc">Nó giúp chúng ta viết code linh hoạt và ngắn gọn hơn</li></ul><ul id="1d91308a-a65b-4436-98c8-1644262e5eb4" class="bulleted-list"><li style="list-style-type:disc">Nó không thay thế hoàn toàn class, nó chỉ là cách viết component mới, những tính năng của class đều có trên hooks tuy nhiên cú pháp khác nhau mà thôi.</li></ul></details></li></ul><ul id="2e0095f9-028f-4060-a9a4-cb7f85372203" class="toggle"><li><details open=""><summary><strong>Tại sao dùng hooks thay vì class ?</strong></summary><ul id="c2333e78-434b-4d4c-ac73-757b16bdc9a6" class="bulleted-list"><li style="list-style-type:disc">Trước đây, các function component được gọi là stateless component. </li></ul><ul id="b1668129-fbb6-4a30-84ff-56fcbe234332" class="bulleted-list"><li style="list-style-type:disc">Chỉ các class component mới được sử dụng cho các phương thức quản lý trạng thái và vòng đời. Nhưng vì class component quá nặng nếu như chỉ cần thay đổi một vài state hay phương thức trong lifecycle. </li></ul><ul id="dc3b7231-4532-48bc-8c3b-30fb3db3fa92" class="bulleted-list"><li style="list-style-type:disc">Điều đó dẫn đến sự ra đời của React Hooks.</li></ul></details></li></ul><ul id="fc8257f4-ea4c-4f84-876a-a5d57eac0699" class="toggle"><li><details open=""><summary><strong>Hiệu suất của hooks so với class ?</strong></summary><ul id="be9d4a95-a89a-4966-a0c7-c7c0df081f90" class="bulleted-list"><li style="list-style-type:disc">React Hooks sẽ tránh được rất nhiều chi phí như tạo thực thể, liên kết các sự kiện, .., có trong các lớp.</li></ul><ul id="29d26d9c-9ed0-495d-9c63-19de58ce2bb2" class="bulleted-list"><li style="list-style-type:disc">Các hook trong React sẽ dẫn đến các cây component nhỏ hơn vì chúng sẽ tránh được việc lồng nhau tồn tại trong HOC và sẽ render props dẫn đến việc React phải thực hiện ít công việc hơn</li></ul></details></li></ul><ul id="aade8608-1bb1-4d79-8440-f083494b4092" class="toggle"><li><details open=""><summary><strong>Các quy tắc sử dụng hooks?</strong></summary><ul id="1987ff37-c333-4dec-9193-cce7d28cacfe" class="bulleted-list"><li style="list-style-type:disc">Chỉ có thể gọi hooks trong function component (không thể dùng trong class).</li></ul><ul id="19e353d6-105f-470a-a874-c6bcb4f2a14e" class="bulleted-list"><li style="list-style-type:disc">Chỉ được gọi hooks ở top level, không được gọi trong 1 loop, condition hay trong 1 nested function </li></ul></details></li></ul><ul id="b8066c3e-d2bf-4a4e-bba1-f0b2a3b42816" class="toggle"><li><details open=""><summary><strong>Giới thiệu một số </strong><mark class="highlight-red"><strong>hooks</strong></mark><strong> cơ bản của react</strong></summary><p id="313bbdf1-e2d2-41bf-842d-049fe3202559" class="">Trong react hooks nó sẽ gồm 2 loại:</p><ul id="eaf36dbd-c44d-4891-bc4b-549b363a627a" class="bulleted-list"><li style="list-style-type:disc"><strong>Hooks được cung cấp sẵn từ react: </strong><ul id="f9628fa0-c147-4841-9bfd-0219a9526b97" class="bulleted-list"><li style="list-style-type:circle"><a href="https://www.notion.so/useState-b74ce41625144ded8c3c4085f204aa80"><strong>useState()</strong></a>: dùng để thiết lập và chỉnh sửa state trong component</li></ul><ul id="3aaa7619-0bed-4b9c-9246-c714533f9c77" class="bulleted-list"><li style="list-style-type:circle"><a href="https://www.notion.so/useEffect-b4496e52cc9c41f2bd22cf995f07294c"><strong>useEffect()</strong></a>: dùng để thực hiện những side effects trên function component</li></ul><ul id="3e8ce7a2-0339-41fb-86ee-292926c968c7" class="bulleted-list"><li style="list-style-type:circle"><a href="https://www.notion.so/useContext-f1a3ec097efc4b2590bc3c9092e528df"><strong>useContext()</strong></a>: dùng để tạo dữ liệu chung có thể truy cập trong hệ thống phân cấp component mà không cần truyền dữ liệu từ trên xuống dưới.</li></ul><ul id="a65dafbb-adf1-4562-a85c-4afe88e79ff9" class="bulleted-list"><li style="list-style-type:circle"><strong><a href="https://www.notion.so/useReducer-4897121664e34026a6ef97f9d33a5fd5">useReducer()</a></strong>: dùng khi các logic state của component trở nên phức tạp thì dùng nó sẽ giúp quản lý trở nên dễ dàng hơn. Nó có thể được xem là phiên bản nâng cấp của useState()</li></ul><ul id="d420b9e3-674a-48b9-9194-0cb49b4a5247" class="bulleted-list"><li style="list-style-type:circle"> <a href="https://www.notion.so/useMemo-useCallback-cb68b5dcaf12488b99a321f9d25cdd1b">useMemo()</a>: được sử dụng để tính toán lại giá trị đã ghi nhớ khi có sự thay đổi trong một trong các dependencies, giúp tránh các tính toán tốn kém trên mỗi lần render.</li></ul><ul id="dcef6ae6-1eb2-446d-8add-b5a986cd3593" class="bulleted-list"><li style="list-style-type:circle"><a href="https://www.notion.so/useMemo-useCallback-110185c6de454248866c29eb8a220bfd">useCallback()</a>: giúp tránh một số trường hợp useEffect từ các component con thực thi lại khi nhận callback là một dependencies từ phía component cha. Nó mất 1 vùng nhớ nhất định để ghi nhớ được function mà chúng ta bọc ở trong useCallback. </li></ul><ul id="89bcdb5f-3fd1-43e7-b8ae-ba166b11774d" class="bulleted-list"><li style="list-style-type:circle"><a href="https://www.notion.so/useRef-c5f3ef2b2792478b9c743c74d9078e52"><strong>useRef():</strong></a> nó sẽ cho phép tạo một tham chiếu đến phần tử DOM trực tiếp trong function component. Ngoài ra nó còn là 1 function trả về object với thuộc tính current được khởi tạo thông qua tham số truyền vào.<em> </em>Object được trả về này có thể mutable và sẽ tồn tại xuyên suốt vòng đời của component.</li></ul><ul id="455bda8c-9d62-4457-a8ef-49b71a3540fc" class="bulleted-list"><li style="list-style-type:circle"><strong>useLayoutEffect()</strong>: dùng cho đọc bố cục từ DOM và re-render bất đồng bộ</li></ul></li></ul><ul id="a34f4a9d-d0c0-4270-a0de-2deb75cca3ec" class="bulleted-list"><li style="list-style-type:disc"><strong>Custom hooks</strong>: là một hook đặc biệt do mình tự định nghĩa ra, giúp ta tách biệt logic ra khỏi UI và có thể chia sẻ logic giữa các component.<ul id="eb225adc-17d5-4539-84a6-8806f7d4b1bd" class="bulleted-list"><li style="list-style-type:circle">Trong custom hook ta có thể sử dụng lại các hook có sẵn hoặc kết hợp với những custom hook khác.</li></ul><ul id="6c63ef75-f2bd-43cf-8d83-90dae0fec25a" class="bulleted-list"><li style="list-style-type:circle">Đặt tên custom hook với prefix là use.</li></ul><ul id="f9322120-d061-4335-a753-bfc2700c9274" class="bulleted-list"><li style="list-style-type:circle">Custom hooks return data thay vì JSX như component.</li></ul><ul id="6c788a88-e54c-4c39-92a3-e0db34d7b095" class="bulleted-list"><li style="list-style-type:circle">Khi nào cần dùng:<ul id="ba3ef7bb-c1d1-4dfd-b4a7-65c64fcae346" class="bulleted-list"><li style="list-style-type:square">Khi một đoạn code (logic) được tái sử dụng nhiều nơi (dễ thấy khi bạn copy cả 1 đoạn code mà không cần sửa gì, trừ tham số truyền vào. Tách như cách mà bạn tách một function).</li></ul><ul id="1ecdd27b-d4b1-49ac-9e00-0f26462dfde0" class="bulleted-list"><li style="list-style-type:square">Khi logic quá dài và phức tạp. Bạn muốn viết nó ở 1 file khác, để component của bạn ngắn hơn và dễ đọc hơn vì không cần quan tâm đến logic của hook đó nữa.</li></ul></li></ul><ul id="6cb3b5fa-7bd0-4b35-b805-52f706ffdbca" class="bulleted-list"><li style="list-style-type:circle">Một số custom hooks như: useAuthentication, useAuthorization, useNotification, useScroll, useFetch, …</li></ul></li></ul></details></li></ul><ul id="1a238836-2660-4122-995c-08d78e08de86" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>useCallback khác gì useMemo ?</strong></mark></summary><ul id="3ffde7aa-0ef6-40ff-94d3-ada55c1245b2" class="bulleted-list"><li style="list-style-type:disc">useCallback: ghi nhớ 1 function, thường được sử dụng để tránh việc function của component cha gây ra tình trạng re-render của 1 component con</li></ul><ul id="d0ad45a8-cac1-49d5-9982-b4c98b3eae49" class="bulleted-list"><li style="list-style-type:disc">useMemo: ghi nhớ 1 giá trị, thường được sử dụng để tránh việc thực hiện lại các tính toán phức tạp khi dữ liệu đầu vào không hề thay đổi</li></ul></details></li></ul><ul id="c2eda765-81eb-485a-9614-23b4fbe2feae" class="toggle"><li><details open=""><summary><strong><strong>Trường hợp sử dụng </strong></strong><mark class="highlight-red"><strong><strong>useEffect</strong></strong></mark><strong><strong> và </strong></strong><mark class="highlight-red"><strong><strong>useLayoutEffect</strong></strong></mark><strong><strong> như thế nào?</strong></strong></summary><ul id="220a29db-50d4-4b3c-a345-3365cfba41ca" class="bulleted-list"><li style="list-style-type:disc">Sự khác nhau giữa <strong>useEffect</strong> và <strong>useLayoutEffect</strong> là thời điểm chúng được gọi. Để hiểu được khi nào chúng được gọi, chúng ta theo dõi các render của DOM. </li></ul><ul id="1de831a9-ea3d-446e-a3dc-95519282b2ce" class="bulleted-list"><li style="list-style-type:disc">Giả sử chúng ta triển khai một hook <strong><mark class="highlight-red">useEffect</mark></strong> sau:<ul id="f43a6d6c-f89c-4a5d-a371-00a225941d8d" class="bulleted-list"><li style="list-style-type:circle">User tương tác với App. VD: Click vào một button</li></ul><ul id="da650c22-31e6-41de-b0cf-bf52ec7db506" class="bulleted-list"><li style="list-style-type:circle"><code>State</code> của component sẽ thay đổi</li></ul><ul id="2e0be321-bfbb-4032-ae29-c812293b51d8" class="bulleted-list"><li style="list-style-type:circle">DOM sẽ thay đổi</li></ul><ul id="ad218956-0472-4238-b8f8-0b931de01699" class="bulleted-list"><li style="list-style-type:circle">UI được thay đổi trên màn hình</li></ul><ul id="f6989e19-4576-4ba4-8757-05e616a2b164" class="bulleted-list"><li style="list-style-type:circle">Hàm <code>cleanup</code> sẽ được gọi để <code>clean</code> những <code>effect</code> đã render trước đó nếu đối số thứ 2 của <code>useEffect</code> thay đổi.</li></ul><ul id="e5f45af2-822d-47e5-aec0-472178d5f104" class="bulleted-list"><li style="list-style-type:circle"><code>useEffect</code> hook sẽ được gọi</li></ul></li></ul><ul id="51dfc53c-816f-446a-939e-e2c22a5ec4bc" class="bulleted-list"><li style="list-style-type:disc">Đối với <mark class="highlight-red"><strong><strong>useLayoutEffect: </strong></strong></mark><ul id="d6cfbaa6-9c66-47df-a30a-e3cc8a469d7c" class="bulleted-list"><li style="list-style-type:circle">User tương tác với App. VD: Click vào một button</li></ul><ul id="b4a4591d-de7c-4ef2-a808-9ae745a3b372" class="bulleted-list"><li style="list-style-type:circle"><code>State</code> của component sẽ thay đổi</li></ul><ul id="3635ee6b-42bc-4812-adf5-d4be0d1c672e" class="bulleted-list"><li style="list-style-type:circle">DOM sẽ thay đổi</li></ul><ul id="01c0154e-2570-4c42-b319-d037f0aee418" class="bulleted-list"><li style="list-style-type:circle">Hàm <code>cleanup</code> sẽ được gọi để <code>clean</code> những <code>effect</code> đã render trước đó nếu đối số thứ 2 của <code>useEffect</code> thay đổi.</li></ul><ul id="7dbf3ab9-5494-4f9c-822a-7d50d3d441b0" class="bulleted-list"><li style="list-style-type:circle"><code>useLayoutEffect</code> hook sẽ được gọi</li></ul><ul id="f12abaf9-00d6-488c-a7b9-3757e3acb668" class="bulleted-list"><li style="list-style-type:circle">UI được thay đổi trên màn hình</li></ul></li></ul></details></li></ul><ul id="654b9efd-129f-4790-97bd-9ddacf5fd077" class="toggle"><li><details open=""><summary><strong>Tại sao </strong><mark class="highlight-red"><strong>setState</strong></mark><strong> không trả về </strong><mark class="highlight-red"><strong>async</strong></mark></summary><ul id="393db765-97d9-4308-b209-20a535fc2aca" class="bulleted-list"><li style="list-style-type:disc"><strong>setState</strong>: KHÔNG TRẢ VỀ ASYNC mà nó trả về 1 dispatch function. Vì:<ul id="17000547-4349-49b1-a0ef-1832c12240e7" class="bulleted-list"><li style="list-style-type:circle">Khi gọi useState, kết quả trả về là 1 mảng gồm: 1 giá trị  + 1 dispatch function</li></ul><ul id="54dd40c4-bad6-4a40-9522-b9dc60884c47" class="bulleted-list"><li style="list-style-type:circle"><strong>dispatch function</strong>: nhận vào 1 giá trị và trả về void (lưu ý, là trả về <code>void</code>, không phải <code>promise</code>) nên <code>setState</code> không phải <code>async</code></li></ul></li></ul><ul id="aa19a80c-3284-427c-bbcb-cd6d1eb8aab0" class="bulleted-list"><li style="list-style-type:disc"><strong>Nếu không phải async thì tại sao nó không thể update giá trị ngay?</strong><ul id="e8a03350-c510-4b16-9a02-f415b539153b" class="bulleted-list"><li style="list-style-type:circle">Theo như reactjs có nói: Sau khi giá trị được truyền vào, thì nó sẽ đi vào 1 hàng đợi, và chờ được xử lý</li></ul><ul id="561e5322-1670-4179-badd-1b4536b9c7d5" class="bulleted-list"><li style="list-style-type:circle">Đến khi component <strong>re-render</strong> thì giá trị mới sẽ được cập nhật</li></ul></li></ul></details></li></ul><ul id="868d81b2-b609-45a4-a31f-7eae28456e2b" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong><strong>Redux, Context API, Hooks có thực sự giống nhau ?</strong></strong></mark></summary><p id="32857993-a14b-4f2e-ace6-bd08bba9dfa0" class=""><mark class="highlight-red">Thực sự 3 thứ này là khác hoàn toàn, chúng có thể bổ trợ cho nhau nhưng về bản chất thì khác.</mark></p><ul id="e3a360e2-6804-4943-abba-c0b664afe57b" class="bulleted-list"><li style="list-style-type:disc">Redux là thư viện để quản lý state và chia sẻ state giữa các component</li></ul><ul id="6c6c7bd7-17dc-4f91-8f16-53a0e5245686" class="bulleted-list"><li style="list-style-type:disc">Bản thân redux cũng có dựa trên context API</li></ul><ul id="371ce18e-8a0c-4f38-88c4-bc4bef63c035" class="bulleted-list"><li style="list-style-type:disc">Về mặt nào đó thì Context API cũng có thể làm phần việc của redux nhưng không phải là tất cả, bởi phải xử lý nhiều mới tối ưu được như thằng redux nếu dùng Context API thô</li></ul><ul id="984b5577-cdbc-4fae-bd51-ab56fedf555c" class="bulleted-list"><li style="list-style-type:disc">Còn đối với hooks thì đó là cách implement mới của react giúp việc functional component thuận tiện hơn.</li></ul><ul id="a9417af7-25ab-49bc-bc47-56ae52931694" class="bulleted-list"><li style="list-style-type:disc">Cơ bản thì vẫn có những hook để xử lý local state như useReducer, useState, useRef.</li></ul><ul id="537549c4-e38f-41da-8922-8e5c929c61b0" class="bulleted-list"><li style="list-style-type:disc">Ngoài ra còn có những hook để xử lý context như useContext. Vậy nếu muốn dùng context bạn vẫn phải qua Context API và hook chỉ là phương tiện hỗ trợ cho dễ dàng hơn thôi</li></ul></details></li></ul><ul id="ca5ff613-6f34-45a7-a080-c97043576ea9" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Context </strong></mark><strong>trong React</strong></summary><ul id="570fde53-dac0-4433-a701-5539dc6ba661" class="bulleted-list"><li style="list-style-type:disc"><a href="https://www.notion.so/useContext-f1a3ec097efc4b2590bc3c9092e528df">Context</a> cung cấp phương pháp truyền data xuyên suốt component tree mà không cần phải truyền props một cách thủ công qua từng level. <a href="https://vi.reactjs.org/docs/context.html">link</a></li></ul><ul id="e5fa0feb-513b-4281-a4f8-541075823970" class="bulleted-list"><li style="list-style-type:disc">Khi nào nên dùng:<ul id="75a6c067-9817-4cfd-b687-66bba1b26731" class="bulleted-list"><li style="list-style-type:circle">Context được thiết kế để chia sẽ data khi chúng được xem là “global data” của toàn bộ ứng dụng React, chẳng hạn như thông tin về user hiện tại đang đăng nhập, theme, hoặc ngôn ngữ mà người dùng đã chọn</li></ul><ul id="877dc3fd-508a-4076-9faa-ee30b5bc5798" class="bulleted-list"><li style="list-style-type:circle">Sử dụng context, chúng ta có thể tránh được việc truyền props qua các elements trung gian</li></ul></li></ul></details></li></ul><ul id="f0696bce-3402-4e29-bda4-5c2dcb1ce0a4" class="toggle"><li><details open=""><summary><strong><strong>React hook có làm việc với static typing?</strong></strong></summary><ul id="f0f4c5c4-c899-4386-928a-43f08c520a5f" class="bulleted-list"><li style="list-style-type:disc">Static typing đề cập đến quá trình kiểm tra code trong suốt thời gian biên dịch để đảm bảo mọi biến đề sẽ được nhập. <strong></strong></li></ul><ul id="eb8fa33a-4ed7-44b8-b809-3f4403d32ac8" class="bulleted-list"><li style="list-style-type:disc">React Hook là hàm được thiết kế để đảm bảo mọi thuộc tính sẽ được nhập tĩnh. Để thực thi nhập tĩnh chặt chẽ hơn trong code, ta có thể sử dụng API React với các Hook tùy chỉnh.</li></ul></details></li></ul><ul id="0caa0a0d-09ca-4fb6-8478-ccc1d0cd9bb7" class="toggle"><li><details open=""><summary><strong>Làm thế nào để giữ được </strong><mark class="highlight-red"><strong>state</strong></mark><strong> trước đó với </strong><mark class="highlight-red"><strong>hooks</strong></mark><strong> ?</strong></summary><ul id="ba2e0ebf-4ef9-4bfd-83fa-79238823f586" class="bulleted-list"><li style="list-style-type:disc">Nếu dùng state khi thay đổi nó sẽ trigger re-render, còn nếu dùng local variable thì nó sẽ bị reset sau mỗi lần re-render</li></ul><ul id="2f876935-e0df-4347-9020-ade3e4153fdb" class="bulleted-list"><li style="list-style-type:disc">Ta có thể dùng global variable để giữ state trước đó tuy nhiên thì cách này không khuyến khích dùng.</li></ul><p id="cb3bd238-e4fd-4f76-8a5e-e271a5d59bc4" class="">→ Sử dụng <strong>refs</strong>, hoặc <strong>useRef</strong> của hooks<div class="indented"><ul id="41a51e0c-fb71-4fde-a455-2ee985880435" class="bulleted-list"><li style="list-style-type:disc">Khi giá trị của ref thay đổi, nó không trigger re-render</li></ul></div></p></details></li></ul><ul id="957a4d2c-f5b9-4028-a18c-4b1f73e05f56" class="toggle"><li><details open=""><summary><strong>So sánh component và Pure component? Pure componet và React.Memo có giống nhau?</strong></summary><ul id="bed67e89-200a-4bea-9282-54fd19cf72cc" class="bulleted-list"><li style="list-style-type:disc"><code><em>React.Component</em></code><em> cho phép dev override lại </em><code><em>shouldComponentUpdate</em></code><em> hook, mặc định hook này reference compare để quyết định re-render lại hay không.</em></li></ul><ul id="e45f95ae-247a-4112-821a-239204aa1938" class="bulleted-list"><li style="list-style-type:disc"><code><em>React.PureComponent</em></code><em> không cho phép dev override lại </em><code><em>shouldComponentUpdate</em></code><em> hook, nếu bạn cố tình override thì bạn sẽ ăn ngay warning. Hook này shallow compare để quyết định re-render lại hay không.</em></li></ul><ul id="4f8ecdff-2cdb-4053-9bbb-11721249607c" class="bulleted-list"><li style="list-style-type:disc"><strong>PureComponent</strong> giúp chúng ta kiểm tra props và state xem có sự thay đổi về giá trị không để cho phép render lại UI cần thiết. Bản chất PureComponent đã override lại hàm shouldComponentUpdate và kiểm tra giá trị ở props và state để trả về true/false cho việc render UI này.</li></ul><ul id="b4778a0a-059e-402c-84ba-da75be6ccd77" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red"><strong>React.memo(): </strong></mark>là một HOC, chứ không phải là hooks, tương tự như là PureComponent, chỉ render lại component nếu props có sự thay đổi, sử dụng cơ chế shallow comparison.</li></ul><ul id="149ef3fb-a4fc-414c-84a9-749a37248947" class="bulleted-list"><li style="list-style-type:disc">Shallow comparison là chỉ so sánh những giá trị của các thuộc tính ngoài cùng của đối tượng, những thuộc tính lồng nhau và tham chiếu đến đối tượng khác sẽ không so sánh được</li></ul><ul id="b4db1f65-a0d5-42ab-adb2-a90dc052d7dc" class="bulleted-list"><li style="list-style-type:disc">Deep comparison cũng giống như shallow nhưng nó so sánh luôn những giá trị đối tương lồng nhau trong các thuộc tính</li></ul><ul id="3ebf6e01-4699-47d6-886c-bedd0140cae4" class="bulleted-list"><li style="list-style-type:disc">Reference compare thì nó so sánh địa chỉ của đối tượng trong bộ nhớ thay vì so sánh giá trị của đối tượng.</li></ul></details></li></ul><ul id="d327183f-0eab-4074-99df-2f98e7d696d9" class="toggle"><li><details open=""><summary><strong>Các kiểu side effects trong component là gì ?</strong></summary><ul id="72a87616-a4f3-4aec-88cc-38f43cba26f7" class="bulleted-list"><li style="list-style-type:disc">Side effects dùng để: <ul id="9bfd0fb4-d046-480c-a3a6-3a1257d67f71" class="bulleted-list"><li style="list-style-type:circle">Gọi API lấy dữ liệu</li></ul><ul id="84b30bf1-ef2c-48c0-b9b0-820d82c5cd76" class="bulleted-list"><li style="list-style-type:circle">Tương tác với DOM</li></ul><ul id="9a5b943f-6a52-4b11-8cf6-688a1a824aa3" class="bulleted-list"><li style="list-style-type:circle">Subscriptions</li></ul><ul id="8ee7c11a-de48-4f81-b1ae-19f33b88af72" class="bulleted-list"><li style="list-style-type:circle">setTimeOut, setInterval</li></ul></li></ul><ul id="715dda4a-f88c-4a3b-9cec-9b0a7a81f6ce" class="bulleted-list"><li style="list-style-type:disc">Có 2 loại side effects:<ul id="304e62f9-5a79-423f-8815-5601133e2dd6" class="bulleted-list"><li style="list-style-type:circle">Effects <strong><mark class="highlight-yellow_background">không cần clean up</mark></strong>: gọi API, tương tác với DOM</li></ul><ul id="08ce1550-4274-4ba2-908e-aa486d8bbd0b" class="bulleted-list"><li style="list-style-type:circle">Effects <mark class="highlight-yellow_background"><strong>cần clean up</strong></mark>: subscriptions, setTimeOut, setInterval. Để dọn dẹp bộ nhớ khi unmouting tránh sự cố rò rĩ bộ nhớ hoặc những lỗi không rõ nguyên nhân.</li></ul></li></ul></details></li></ul><ul id="5db89573-2f6a-4e3c-9378-ab8e6954b6e3" class="toggle"><li><details open=""><summary><strong><mark class="highlight-red">Prop drilling</mark></strong><strong> trong react là gì ?</strong></summary><ul id="034c8187-8737-4f68-9486-3635ffea70a1" class="bulleted-list"><li style="list-style-type:disc">Đôi khi trong react ta cần phải truyền dữ liệu từ component cao hơn xuống sâu component bên dưới. Để truyền được như vậy ta phải truyền qua rất nhiều component trung gian cho đến khi đến component cần nhận props. Đó là prop drilling. </li></ul><ul id="889f1e01-a756-43f5-b85c-3945cc1a67e8" class="bulleted-list"><li style="list-style-type:disc">Tuy nhiên khi app càng lớn prop drilling làm cho việc truy cập dữ liệu hết sức phức tạp</li></ul></details></li></ul><ul id="8c22dec7-97b9-48ec-990f-1fdc2389f5f4" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Strict mode</strong></mark><strong> trong react là gì ?</strong></summary><ul id="7d5cab0e-b381-4fca-90ef-2078692f7e03" class="bulleted-list"><li style="list-style-type:disc">StrictMode là công cụ được thêm vào ở React v16.3 để highlight các vấn đề tiềm ẩn trong React. Nó thực hiện kiểm tra bổ sung lên ứng dụng.</li></ul><ul id="b7d77ae1-930e-4323-9139-fb2b41db785a" class="bulleted-list"><li style="list-style-type:disc">StrictMode giúp giải quyết các vấn đề sau:<ul id="1d901191-7a6d-443b-8b4f-fa67d7d8d1df" class="bulleted-list"><li style="list-style-type:circle">Khi chúng ta gọi hàm bất đồng bộ tại 1 lifecycle không an toàn. Strictmode sẽ cung cấp cho ta cái cảnh báo về việc sử dụng đó.</li></ul><ul id="96cd59c1-3460-4c28-85bd-40be9d92ac60" class="bulleted-list"><li style="list-style-type:circle">Cảnh báo khi chúng ta sử dụng findDom() để tìm cây của node trong DOM. Vì phương thức này react không còn hỗ trợ cho nên sẽ đưa ra cảnh báo.</li></ul></li></ul><ul id="c8abaf79-2549-4c55-9159-3b52b5d0c422" class="bulleted-list"><li style="list-style-type:disc">Nói chung thì nó giúp chúng ta tránh những lỗi tiểm ẩn có thể xảy ra trong quá trình chạy. </li></ul></details></li></ul><ul id="06ee8979-6531-4774-a495-76266c830f74" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Higher order component</strong></mark><strong> trong react là gì ? (</strong><mark class="highlight-red"><strong>HOC</strong></mark><strong>)</strong></summary><ul id="ca341a5e-d387-43fd-b84a-e921ce038562" class="bulleted-list"><li style="list-style-type:disc"><strong>Higher order function</strong> là một function mà nó nhận vào tham số là function hoặc return về một function. </li></ul><ul id="75855327-df5a-46cd-ada2-df31e19e4d45" class="bulleted-list"><li style="list-style-type:disc"> <strong>Higher order component</strong> là 1 function và nó nhận vào tham số là 1 component nó sẽ return về một component.</li></ul><p id="c27885da-6c95-40b2-a4ea-79e8e27364bd" class="">⇒ Khi sử dụng <strong>HOC</strong> thì có 3 điểm bạn cần lưu ý khi sử dụng là:<div class="indented"><ul id="f52f90e7-35f9-4356-9d37-d8ee9eeb8932" class="bulleted-list"><li style="list-style-type:disc">Không sử dụng <strong>HOC</strong> trong phương thức render()</li></ul><ul id="6130a41f-03b0-406c-b148-980776d97407" class="bulleted-list"><li style="list-style-type:disc">Các phương thức static cần phải được copy lại</li></ul><ul id="2964a9a9-80b7-46bd-b97b-5a23f28dba4d" class="bulleted-list"><li style="list-style-type:disc">Refs không được truyền qua <strong>HOC</strong></li></ul></div></p><p id="aa4ed78c-91bc-413b-93de-95d75da14ba9" class="">⇒ Có thể gặp HOC ở: <div class="indented"><ul id="542d66b9-5930-4bd6-9501-b4464af1f3fa" class="bulleted-list"><li style="list-style-type:disc"><strong>withRouter</strong> của React Route</li></ul><ul id="dfb8c4df-a13e-4d08-9bba-736cf3bdc132" class="bulleted-list"><li style="list-style-type:disc">hàm <strong>connect</strong> của React-redux</li></ul></div></p></details></li></ul><ul id="4f952103-a761-477e-844e-45c3d8b31b86" class="toggle"><li><details open=""><summary><strong>Các cách khác nhau để chỉnh </strong><mark class="highlight-red"><strong>style component </strong></mark><strong>trong react?</strong></summary><ul id="a3d3df53-e0fe-4afa-b43b-42816d648bbf" class="bulleted-list"><li style="list-style-type:disc"><strong>Inline Styling: </strong>ta có thể chỉnh style trực tiếp lên phần tử bằng cách dùng thuộc tính style. Nhớ giá trị của style luôn là đối tượng JavaScript</li></ul><ul id="efec0748-50c0-4ad8-8db8-072b08b1c48e" class="bulleted-list"><li style="list-style-type:disc"><strong>Javascript Object</strong>: ta có thể tạo đối tượng JavaScript và tập mô tả thuộc tính style. Các đối tượng có thể dùng như giá trị của thuộc tính style.</li></ul><ul id="27bd797d-ea07-4593-8537-297e1374e73a" class="bulleted-list"><li style="list-style-type:disc"><strong>CSS Stylesheet:</strong> Ta sẽ tạo một file CSS riêng và viết tất cả style cho component trong file đó. Sau đó import nó vào file React.</li></ul><ul id="ae2abe77-5227-40e1-a7c2-20d4dac736b7" class="bulleted-list"><li style="list-style-type:disc"><strong>CSS Module:</strong> Tương tự như file CSS, nhưng ta sửa thành <code>.module.css</code>, với cách này tên lớp sẽ được mã hoá, đồng thời nó hỗ trợ kiểu viết tương tự <strong>sass</strong>.</li></ul></details></li></ul><ul id="cb145017-56fe-49c2-80ed-e0968c4104ad" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Error boundary</strong></mark><strong> là gì ?</strong></summary><ul id="8baa64af-ee19-43fd-b937-edee1aad816d" class="bulleted-list"><li style="list-style-type:disc">Được giới thiệu ở React v16, error boundary cung cấp một cách để xử lý lỗi xảy ra trong giai đoạn render.</li></ul><ul id="33b72495-4378-4496-80ea-fa267e663c57" class="bulleted-list"><li style="list-style-type:disc">Bất kỳ component nào sử dụng các phương thức lifecycle cũng được xem là một error boundary. Các vị trí mà error boundary có thể được phát hiện:<ul id="22341f7a-7fe9-41e7-a0c8-4a7d8e6966b8" class="bulleted-list"><li style="list-style-type:circle">Giai đoạn render</li></ul><ul id="993f003b-8bf6-4612-be8b-c71dc9675887" class="bulleted-list"><li style="list-style-type:circle">Trong một phương thức lifecycle</li></ul><ul id="7fc6821b-a935-48f8-84a6-063d89996fce" class="bulleted-list"><li style="list-style-type:circle">Trong constructor</li></ul></li></ul><ul id="90463eaa-1505-4d12-915b-76c8f080ff9e" class="bulleted-list"><li style="list-style-type:disc">Khi không dùng error boundary khi có error xảy ra như ở trên ta sẽ thấy một trang trống thay vì lỗi. </li></ul><ul id="ad0aef37-44c4-4fbc-b699-dc0af2c7c24b" class="bulleted-list"><li style="list-style-type:disc">Bất cứ lỗi nào trong phương thức render đều dẫn đến unmounting component. </li></ul><ul id="2afdd419-1350-475a-ad60-dc68e7e2b4df" class="bulleted-list"><li style="list-style-type:disc">Để hiển thị lỗi khi đó, ta sử dụng error boundary. Là một component bọc ngoài các component.</li></ul></details></li></ul><ul id="fe19248c-2e7c-419a-ab97-4fc0907a396d" class="toggle"><li><details open=""><summary><strong>Làm thế nào để ngăn chặn </strong><mark class="highlight-red"><strong>re-render</strong></mark><strong> trong react ?</strong></summary><ul id="b6e967c5-86f2-49fb-b38e-a4183a1d01e8" class="bulleted-list"><li style="list-style-type:disc">Nguyên nhân của việc gây ra re-render là có sự thay đổi của 1 state hoặc props trên component</li></ul><ul id="5dfbbf61-3c5d-4d20-98b5-4d669b898336" class="bulleted-list"><li style="list-style-type:disc">Ta có thể overide lại hook <strong>shouldComponentUpdate() </strong>để ngăn chặn việc re-render</li></ul><ul id="14c619df-465a-4102-a062-cd884051c92c" class="bulleted-list"><li style="list-style-type:disc">Hoặc sử dụng một số kỹ thuật như useMemo, useCallBack, …<strong> </strong></li></ul></details></li></ul><ul id="023dad19-ac09-4456-9191-1546fcc63640" class="toggle"><li><details open=""><summary><strong>Các kỹ thuật tối ưu </strong><mark class="highlight-red"><strong>hiệu suất</strong></mark><strong> (optimize performance) trong react là gì ?</strong></summary><ul id="475bbdb4-4500-4f64-9c13-bdfe8daddbc2" class="bulleted-list"><li style="list-style-type:disc"><strong>useMemo()</strong><ul id="7d776e6f-7c0b-4920-b407-4299ba45c5d4" class="bulleted-list"><li style="list-style-type:circle">Là hook dùng cho caching CPU.</li></ul><ul id="b219efb3-28c8-4ee0-b53e-f504e36dc66b" class="bulleted-list"><li style="list-style-type:circle">Đôi khi trong các ứng dụng web, các hàm đắt (tính toán nhiều, tốn bộ nhớ) được gọi liên túc do re-render đẫn đến tốc độ render chậm, hiệu suất kém.</li></ul><ul id="234ad5f1-069d-4e75-a7a7-fc1fc3d9a099" class="bulleted-list"><li style="list-style-type:circle">useMemo() có thể sử dụng cho cache cám hàm như vậy. Bằng cách dùng useMemo() các hàm đó chỉ được gọi khi cần thiết.</li></ul></li></ul><ul id="b7e02c55-898f-4cf3-8acf-858e173963d7" class="bulleted-list"><li style="list-style-type:disc"><strong>React.PureComponent</strong><ul id="7b5d8f09-e84e-46bb-a93b-d0f8dd718b6f" class="bulleted-list"><li style="list-style-type:circle">Là class component cơ sở để kiểm tra state và props của một component để biết khi nào nó nên được cập nhật.</li></ul><ul id="1b0c7cce-a16d-4efe-ab95-2786cc3c3474" class="bulleted-list"><li style="list-style-type:circle">Thay vì dùng React.Component, ta có sử dụng React.PureComponent để giảm việc re-render không cần thiết.</li></ul></li></ul><ul id="08905247-5f9e-43d2-bba5-1b0b6174d620" class="bulleted-list"><li style="list-style-type:disc"><strong>Duy trì vị trí state</strong><ul id="1a8376f5-6ca9-4b2d-b62b-1d0fcf2bfcf3" class="bulleted-list"><li style="list-style-type:circle">Đây là quá trình chuyển state đến nơi bạn nhất có thể.</li></ul><ul id="bc561cf0-3c09-43c3-9591-4e8a8f794e8e" class="bulleted-list"><li style="list-style-type:circle">Thỉnh thoảng ta có các state không cần thiết nằm trong component cha để gây khó đọc và bảo trì hơn, thậm chí là dẫn đến re-render không cần thiết.</li></ul><ul id="53210ac1-0968-4731-80a5-ef4abafaecb4" class="bulleted-list"><li style="list-style-type:circle">Để tốt hơn, ta chuyển các state vô nghĩa ở component cha sang một component riêng biệt.</li></ul></li></ul><ul id="411f29f8-fdd2-4a7f-baf1-cf8ca60062b6" class="bulleted-list"><li style="list-style-type:disc"><strong>Lazy Loading</strong><ul id="a63d3948-bada-4431-8a3d-2b111f41524d" class="bulleted-list"><li style="list-style-type:circle">Đây là kỹ thuật dùng để giảm thời gian tải của ứng dụng React. Lazy loading giúp tối ưu hiệu suất ứng dụng web bằng cách chỉ tải khi cần thiết.</li></ul></li></ul></details></li></ul><ul id="2d0f6ec9-a61f-4fdd-8ad2-496f4bde337c" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Những phương pháp giúp tối ưu performance?</strong></mark></summary><ul id="207c15e0-3787-4385-baba-da86c5a4b51a" class="bulleted-list"><li style="list-style-type:disc"><strong>Code splitting</strong>: chỉ load những page hoặc component cần thiết lúc render, không nên load hết tất cả lên, vd: khi vào homepage ta chỉ cần load page home và component liên quan đến page đó thôi</li></ul><ul id="23b8b696-fe28-4e4d-baa8-9fc86041ff8b" class="bulleted-list"><li style="list-style-type:disc">Lazy load image: thay vì load hết tất cả img thì ta nên load những img hiển thị trên viewport, khi scroll thì tiếp tục load những hình ảnh còn lại</li></ul><ul id="6ccd946a-5120-45e9-b671-d51cf54ae0c1" class="bulleted-list"><li style="list-style-type:disc">Lazy size image: với mỗi screen device sẽ có những size ảnh khác nhau thay vì chỉ load 1 size ảnh cho all device</li></ul><ul id="bac23f0c-db6b-49da-8471-f15b9e623ad0" class="bulleted-list"><li style="list-style-type:disc">Server side rendering</li></ul><ul id="03378704-aa57-4236-8400-3541a44d2921" class="bulleted-list"><li style="list-style-type:disc">Sử dụng CDN</li></ul><ul id="ecccdd36-4939-47f5-808b-d2c06fcfe3f0" class="bulleted-list"><li style="list-style-type:disc">Tối ưu CSS</li></ul><ul id="7a4dfbe5-9642-43fb-b262-3de949961a8d" class="bulleted-list"><li style="list-style-type:disc">Minified HTML, CSS, JS with webpack</li></ul><ul id="8e0eb0bb-bc33-4d41-b508-68772d068941" class="bulleted-list"><li style="list-style-type:disc">Tránh việc re-render nhiều lần trong app</li></ul><ul id="e8d80963-659f-4bb7-9ab8-51405b999c5e" class="bulleted-list"><li style="list-style-type:disc">Thêm loading hoặc skeleton để tăng trải nghiệm người dùng</li></ul></details></li></ul><ul id="fe288c44-2d01-4022-8849-ad1ef7d766ca" class="toggle"><li><details open=""><summary><strong>React </strong><mark class="highlight-red"><strong>Router</strong></mark><strong> là gì ?</strong></summary><ul id="c3ddef83-b741-4c33-9c55-e7a2d915bc1b" class="bulleted-list"><li style="list-style-type:disc">Là một thư viện dùng để routing trong react. Cho phép điều hướng các trang trong app mà không cần làm mới  (reload) lại toàn bộ trang. </li></ul><ul id="0b380326-c927-447f-b598-f3e2ba3d5502" class="bulleted-list"><li style="list-style-type:disc">Nó cho phép ta thay đổi URL của trình duyệt nhưng vẫn giữ UI đồng bộ với URL </li></ul></details></li></ul><ul id="2a79b521-8832-488f-84b9-5b2560c76cff" class="toggle"><li><details open=""><summary><strong>withRouter trong react-router-dom là gì?</strong></summary><ul id="504d3882-155a-422e-baa2-877c0c90491a" class="bulleted-list"><li style="list-style-type:disc"><code>withRouter()</code> là một HOC cho phép truy cập thuộc tính đối tượng <code>history</code> ứng với <code>&lt;Route&gt;</code> gần nhất. Nó sẽ truyền <code>match</code>, <code>location</code> và <code>history</code> như props đến component được bọc bất cứ khi nào nó render.</li></ul></details></li></ul><ul id="e98d37ba-fe7a-43d8-8966-707d698c9e1b" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Link</strong></mark><strong> và </strong><mark class="highlight-red"><strong>NavLink</strong></mark><strong> khác nhau gì ?</strong></summary><ul id="54ffb5ad-7619-4cc4-b1af-18c96e61bd0b" class="bulleted-list"><li style="list-style-type:disc"><code>&lt;Link&gt; </code>dùng cho điều hướng sang các trang khác nhau trong ứng dụng web, tương tự thẻ a</li></ul><ul id="d7a48563-15ff-4251-a46d-e59478e89219" class="bulleted-list"><li style="list-style-type:disc"><code>&lt;NavLink&gt;</code> khá giông link về cách sử dụng nhưng nó hỗ trợ thêm các thuộc tính như <strong>activeClassName </strong>và<strong> activeStyle , </strong>2 thuộc tính này giúp cho khi mà nó trùng khớp thì nó sẽ được active lên và chúng ta có thể style cho nó.</li></ul></details></li></ul><ul id="ada2ad78-1e35-437e-9d9c-69d98d4c60cd" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Nested routing </strong></mark><strong>là gì ? Khi nào cần dùng ?</strong></summary><ul id="9adfae3b-04b3-4da0-8a76-cf30b238b5f5" class="bulleted-list"><li style="list-style-type:disc">Sử dụng <strong>nested</strong> route trong React Router giúp dễ dàng tạo các <strong>nested</strong> route trong trang web của chúng ta, giúp dễ dàng hiển thị và quản lý theo <strong>component</strong>.</li></ul><ul id="e1a30bd4-91f8-4e3e-b11d-1572da1bb753" class="bulleted-list"><li style="list-style-type:disc">Ví dụ: khi cần làm một <strong>sub menu</strong> chúng ta có nhiều menu đa cấp thì ta sử dụng nested route giúp ta phân chia các code thành những component nhỏ bên trong, giúp ta dễ dàng quản lý và phân chia code</li></ul></details></li></ul><ul id="e74da109-fce2-4154-83dd-d2c13124f7a8" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Setup routing</strong></mark><strong> cho mấy trang </strong><mark class="highlight-red"><strong>login</strong></mark><strong> như thế nào ?</strong></summary><ul id="8b70a21c-37ef-4de3-9a7b-9f0898f2624d" class="bulleted-list"><li style="list-style-type:disc">Tạo ra một <strong>custom route extend</strong> từ route thông thường, trong đó ta check xem nếu chưa login thì ta redirect sang trang login, còn login rồi thì thôi</li></ul><ul id="4c42776f-bb43-4dca-9558-94cdaae24f7d" class="bulleted-list"><li style="list-style-type:disc">Hoặc tạo một middleware check, nếu chưa login thì redirect sang trang login</li></ul></details></li></ul><ul id="468316a0-e978-44e5-8dbb-336785b07c34" class="toggle"><li><details open=""><summary><strong>Handle phần </strong><mark class="highlight-red"><strong>authentication</strong></mark><strong> trong app như thế nào ? Cách lưu các token ?</strong></summary><ul id="c2931edd-34f0-48c6-90c6-a0df624ffaf2" class="bulleted-list"><li style="list-style-type:disc"><strong>B1</strong>: Check cookies nếu có JWT payload thì vào các trang member nếu không redirect ra trang login</li></ul><ul id="4200e780-bb54-40dd-9e08-d76feefdf392" class="bulleted-list"><li style="list-style-type:disc"><strong>B2</strong>: Ở trang login khi user hoàn tất nhập username, pass, ta gửi lên server để thực hiện việc login, nếu thành công thì lấy mã token và lưu vào cookie sau đó redirect về trang home</li></ul><ul id="068b4859-9ee0-45fe-9aff-d8c1ccb377f8" class="bulleted-list"><li style="list-style-type:disc"><strong>B3</strong>: Nếu trang /login dùng chuẩn xác thực bằng OpenID thông qua một cơ chế OAuth. Theo authorization code grant flow, trang /login sẽ redirect browser về /backend/auth/&lt;provider&gt;. Sau đó nếu flow OAuth xong và hợp lệ (user grant đăng nhập với Facebook), server response sẽ set authentication cookie với JWT bên trong. Sau đó browser sẽ redirect về trang của SPA. SPA sẽ quay lại check như bước 1.</li></ul></details></li></ul><ul id="4a3f9930-df8a-475f-bcba-88c7a7d4bb02" class="toggle"><li><details open=""><summary><strong>Bạn thường dùng thư viện nào để quản lý form ?</strong></summary><ul id="6d5427ec-d5e5-4c98-b5d9-8dc8a4b0ccac" class="bulleted-list"><li style="list-style-type:disc"><strong>Formik</strong></li></ul><ul id="c6ea6170-62a3-43a1-aede-752ffae9b73c" class="bulleted-list"><li style="list-style-type:disc"><strong>Redux-Form </strong></li></ul><ul id="af257a9f-4698-4596-92d0-99119716e0f1" class="bulleted-list"><li style="list-style-type:disc"><strong>React-Hook-Form</strong></li></ul></details></li></ul><ul id="a39b2512-0686-4db4-8af8-a6a028375185" class="toggle"><li><details open=""><summary><strong>Render có điều kiện (</strong><mark class="highlight-red"><strong>condition</strong></mark><strong>) trong react ?</strong></summary><ul id="c0b7f0e3-a7ce-4850-a818-0ddf5534a2c3" class="bulleted-list"><li style="list-style-type:disc">Giúp ta hiển thị kết quả dynamic dựa vào điều kiện state, hay dữ liệu chúng ta truyền vào.</li></ul><ul id="e2affa17-f5d1-4724-9d12-cfe4449eb188" class="bulleted-list"><li style="list-style-type:disc">Một số cách:<ul id="b92dbac1-21ff-4b2f-84c2-940fddd5305a" class="bulleted-list"><li style="list-style-type:circle">Sử dụng if else</li></ul><ul id="5db4a32e-4a2a-4165-af21-cf05c4259d76" class="bulleted-list"><li style="list-style-type:circle">Toán tử 3 ngôi</li></ul><ul id="7700866c-2173-439f-bc3b-c95dcaf97e84" class="bulleted-list"><li style="list-style-type:circle">Sử dụng một biến phần tử</li></ul></li></ul></details></li></ul><ul id="a0b31f78-1d9c-4419-ab1c-495f53aafbd5" class="toggle"><li><details open=""><summary><strong>Cách hiển thị dữ liệu API với axios?</strong></summary><ul id="ad228b33-6444-4a56-bbe9-ae9e4c7a71de" class="bulleted-list"><li style="list-style-type:disc">Axios là một promise dựa trên HTTP để tạo yêu cầu HTTP đến trình duyệt hay web server.</li></ul><ul id="63edbff9-bc51-4950-8458-3e9892d63f6a" class="bulleted-list"><li style="list-style-type:disc"><strong>Tính năng</strong><ul id="71fc4b46-8b2c-4d38-9bd6-66afd89a4043" class="bulleted-list"><li style="list-style-type:circle"><strong>Interceptors</strong>: Truy cập cấu hình yêu cầu hoặc phản hồi (header, dữ liệu, v.v.) khi chúng gửi đến hoặc đi. Các hàm này có thể hoạt động như các cổng để kiểm tra cấu hình hoặc thêm dữ liệu.</li></ul><ul id="4cd92d61-2ef5-4760-8753-63ef39ac2675" class="bulleted-list"><li style="list-style-type:circle"><strong>Instances</strong>: Tạo thực thể có thể tái sử dụng như baseUrl, headers, và cấu hình khác đã thiết lập.</li></ul><ul id="9a3236a2-1d1a-4131-9868-9ffdee8012ee" class="bulleted-list"><li style="list-style-type:circle"><strong>Defaults</strong>: Thiết lập giá trị chung cho header chung (như Authorization) với các yêu cầu. Nó hữu ích khi bạn cần xác thực đến server trên mọi yêu cầu.</li></ul></li></ul></details></li></ul><ul id="bd78004d-b8f0-4279-a0a4-ff464307aebb" class="toggle"><li><details open=""><summary><strong>Caching trong react?</strong></summary><ul id="2c824cbf-ee18-4ddd-aefd-fe6de941ab67" class="bulleted-list"><li style="list-style-type:disc">Ta có thể caching dữ liệu trong React bằng nhiều cách như:<ul id="7fe1f4a5-c3f5-46f7-a74c-017a33086b21" class="bulleted-list"><li style="list-style-type:circle">Local Storage</li></ul><ul id="7b4610aa-e398-44cf-9162-6cc287c027a9" class="bulleted-list"><li style="list-style-type:circle">Redux Store</li></ul><ul id="311b3771-2e1a-4338-9854-f9f6daba285d" class="bulleted-list"><li style="list-style-type:circle">Giữ dữ liệu giữa mounting và unmounting</li></ul></li></ul></details></li></ul><ul id="43ffbd21-de07-4f50-9c79-7e8adbe8f333" class="toggle"><li><details open=""><summary><strong>Có thể dùng đc component mà không </strong><mark class="highlight-red"><strong>extends</strong></mark><strong> không ?</strong></summary><ul id="5807b57e-7c11-4156-a311-e5bc6001a22c" class="bulleted-list"><li style="list-style-type:disc">Có thể được, miễn là không sử dụng <strong>JSX</strong></li></ul><ul id="fc0ada30-65e7-4790-aa09-aa8fe5d9d3bc" class="bulleted-list"><li style="list-style-type:disc">Tuy nhiên sẽ không sử dụng được những lifecycle methods, cũng như các props, state và render </li></ul></details></li></ul><ul id="dc667c96-ff05-4327-851e-1733b04457d2" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>window.reloaded </strong></mark><strong>vs</strong><mark class="highlight-red"><strong> dom.reloaded</strong></mark><strong> khác gì nhau ?</strong></summary><ul id="68f2ba5f-e0c1-47a9-bbd3-9f2c0c63a688" class="bulleted-list"><li style="list-style-type:disc"> <strong>window</strong> là gọi khi cả html, js đc load xong </li></ul><ul id="d3a2c4ed-e050-4a1c-93aa-dfa078771005" class="bulleted-list"><li style="list-style-type:disc">còn <strong>dom</strong> là khi mới chỉ có html chưa có gì</li></ul></details></li></ul><ul id="8968b8a4-2c40-4573-8c3c-c33df6334c14" class="toggle"><li><details open=""><summary><strong>Redux là gì ? Thành phần trong redux ? Cách hoạt động ? Nguyên tắc?</strong></summary><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="010a1954-2d69-4707-9364-7d972c0c6485"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><em>Redux là 1 thư viện giúp chúng ta quản lý các state 1 cách tốt hơn. Thay vì phải truyền state qua từng Component thì Redux sẽ tạo ra 1 store duy nhất dùng để thay đổi dữ liệu.</em></div></figure><ul id="d687ff95-2acb-4f70-a4b1-2921b86252ee" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>Đặt điểm:</strong></span><ul id="9fef0755-c823-4687-8b0c-c87a21d83a8a" class="bulleted-list"><li style="list-style-type:circle">State trong redux là có thể dự đoán được</li></ul><ul id="7c1dae41-a597-44c4-80f1-4b23686599ed" class="bulleted-list"><li style="list-style-type:circle">Redux sử dụng kiến trúc 1 chiều: uni-directional data flow</li></ul><ul id="983b9dc9-a0df-4d7f-8ce5-897a292d2bcd" class="bulleted-list"><li style="list-style-type:circle">Redux state là READ-ONLY. Muốn update phải dispatch một action (js object)</li></ul><ul id="d65f067e-4a21-439a-953b-642b481d5d2a" class="bulleted-list"><li style="list-style-type:circle">Những thay đổi của redux state được thực hiện bởi Pure functions (reducer)</li></ul><ul id="116500c6-cc9c-4b83-b722-1c15d1c359ac" class="bulleted-list"><li style="list-style-type:circle">Redux có thể dùng cho các javascript apps, không chỉ riêng gì ReactJS.</li></ul></li></ul><ul id="0629186c-fa05-40c5-9b3e-3eb8d0a0882a" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>Thành phần: </strong></span><ul id="95449959-95b0-43ed-acc4-c21bfc623f83" class="bulleted-list"><li style="list-style-type:circle"><code>Store</code> gồm có: <ul id="1ea86c85-7007-4e75-b3a7-4d2b1d649e41" class="bulleted-list"><li style="list-style-type:square"><code>State</code>: là dữ liệu hiện tại được lưu trên state</li></ul><ul id="7cd60004-141f-4fb4-bb62-ed31f81a3da2" class="bulleted-list"><li style="list-style-type:square"><code>Reducer</code>: là hàm biến đổi state cũ thành state mới</li></ul><ul id="eebbcd44-9682-4058-b077-69a6533cc2b4" class="bulleted-list"><li style="list-style-type:square">Dispatcher: quản lý <code>middlewares</code> và chuyển dữ liệu xuống reducer.</li></ul></li></ul><ul id="0760318d-260d-4845-8e0f-28fa9661a351" class="bulleted-list"><li style="list-style-type:circle"><code>Action</code>: tạo ra các action dùng để mô tả event do người dùng tạo ra</li></ul><ul id="96efee8b-a386-4486-9a26-a446c30fe04e" class="bulleted-list"><li style="list-style-type:circle"><code>View</code>: hiển thị dữ liệu được cung cấp bởi Store.</li></ul></li></ul><ul id="5fe4278d-285f-4699-83a0-021c0afee26f" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>Nguyên lý hoạt động của Redux: </strong></span><ul id="cfd4ae64-8ec1-4207-ae19-3eb75c798065" class="bulleted-list"><li style="list-style-type:circle"><span style="border-bottom:0.05em solid"><strong>B1</strong></span>: Khi có 1 sự kiện (event) như là GET, POST, UPDATE, DELETE... thì thằng <code>action</code> creators sẽ sinh ra 1 action mô tả những gì đang xảy ra.</li></ul><ul id="976a769d-c114-4e92-95d8-4a4eda08a7bc" class="bulleted-list"><li style="list-style-type:circle"><span style="border-bottom:0.05em solid"><strong>B2</strong></span>: <code>Action</code> sẽ thực hiện điều phối <code>Reducer</code> xử lý event thông qua hàm <code>dispatch(action)</code>.</li></ul><ul id="90677fcc-e490-419e-894a-579ae3756f6b" class="bulleted-list"><li style="list-style-type:circle"><span style="border-bottom:0.05em solid"><strong>B3</strong></span>: <code>Reducer</code> dựa vào những mô tả của <code>Action</code> để biết cần thực hiện thay đổi gì trên <code>State</code> và thực hiện update.</li></ul><ul id="05ac30b2-e805-4736-8f04-a915940bc0cd" class="bulleted-list"><li style="list-style-type:circle"><span style="border-bottom:0.05em solid"><strong>B4</strong></span>: Khi <code>State</code> được update thì các trigger đang theo dõi state đó sẽ nhận được thông tin update và tiến hành render lại phần <code>view</code> để hiển thị ra cho người dùng</li></ul></li></ul><ul id="0ebac665-5ef3-455c-be67-de67c0cba597" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>3 Nguyên tắc trong redux:</strong></span><ul id="83fd5dae-1ccc-48c0-b2ec-e0460cf55fcb" class="bulleted-list"><li style="list-style-type:circle"><strong>Store</strong> luôn là nguồn dữ liệu đúng và tin cậy duy nhất.</li></ul><ul id="c5599a6e-7d16-4b8e-96c8-1f08adb15390" class="bulleted-list"><li style="list-style-type:circle"><strong>State</strong> chỉ được phép đọc, cách duy nhất để thay đổi <strong>State</strong> là phát sinh một Action, và để Reducer thay đổi State.</li></ul><ul id="68fb29d5-7291-4c83-b15e-f50ff7cd3513" class="bulleted-list"><li style="list-style-type:circle">Các function Reducer phải là <strong>Pure function</strong> (với cùng 1 đầu vào chỉ cho ra 1 đầu ra duy nhất)</li></ul></li></ul><ul id="d61da348-0d64-4834-bd3a-2143e40a4950" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>Khi nào cần sử dụng Redux:</strong></span><ul id="70fa8cc0-90cb-4cdf-8a7c-89ffe6f62f30" class="bulleted-list"><li style="list-style-type:circle">Dữ liệu được sử dụng ở nhiều nơi</li></ul><ul id="38e5b039-1838-4804-98f0-04278e0e0ce1" class="bulleted-list"><li style="list-style-type:circle">Có hỗ trợ chức năng <code>undo</code>/<code>redo</code></li></ul><ul id="2bfed968-eda5-4860-9bfb-e7ce0f6a018a" class="bulleted-list"><li style="list-style-type:circle">Cần <code>cache</code> dữ liệu để tái sử dụng cho những lần sau.</li></ul></li></ul></details></li></ul><ul id="f327d350-4483-4785-aca9-e04e126830fa" class="toggle"><li><details open=""><summary><strong>Một số middleware trong redux ?</strong></summary><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="9c65337f-e8a3-4d70-9694-2ab0534fe623"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"> <code><em>middleware</em></code><em> là một lớp nằm giữa </em><code><em>Reducers</em></code><em> và </em><code><em>Dispatch Action</em></code><em>, nó sẽ modify và được gọi trước khi action được dispatch. Thường được dùng trong việc logging, reporting, async api, routing, ...</em></div></figure><ul id="c3c7197f-a53b-4413-85ca-59a9a31dec82" class="bulleted-list"><li style="list-style-type:disc"><strong><strong>Logging, Reporting, Redux-saga, Redux-thunk, redux-persist</strong></strong></li></ul></details></li></ul><ul id="9544796f-38d2-45e1-970a-98952e71c6f4" class="toggle"><li><details open=""><summary><strong>Tại sao phải sử dụng middleware như redux-saga hay redux-thunk?</strong></summary><p id="a40e8d7e-7a4b-4715-9b01-7d4e23f6e6f7" class="">Khi sử dụng Redux ta gặp một số ràng buộc như: </p><ul id="fd236ea7-49d2-4eee-be57-1857e1a6a309" class="bulleted-list"><li style="list-style-type:disc">Các xử lý trong <code>Reducers</code> phải là các hàm đồng bộ và pure, trả về state mới</li></ul><ul id="cd0ee930-574e-4ba7-a986-5fc29c9780fa" class="bulleted-list"><li style="list-style-type:disc"><code>Reducers</code> sẽ không được sử dụng các hàm <code>async</code> vì không được thay đổi <code>global state</code></li></ul><p id="c5969d69-9f86-4e1b-9383-30a5f08e3027" class="">⇒ Để giải quyết các side effects cần phải thực hiện ở <code>middleware</code></p></details></li></ul><ul id="383ee32e-190a-4dde-97b4-94bc9a4836f8" class="toggle"><li><details open=""><summary><strong>Redux saga là gì?</strong></summary><p id="d54e9e87-d11e-4f9e-95ba-84248cab145d" class=""><code>Redux-Saga</code> là một thư viện redux middleware, giúp quản lý những side effect trong ứng dụng redux trở nên đơn giản hơn. Bằng việc sử dụng tối đa tính năng Generators (function*) của ES6, nó cho phép ta viết async code nhìn giống như là synchronous.</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="da536978-3c81-402b-8d76-9e5ff07f1138"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><em> </em><code><em>Generator function</em></code><em><strong> </strong></em><em>là function có khả năng hoãn lại quá trình thực thi mà vẫn giữ nguyên được context. ( Nói một cách đơn giản thì generator function là 1 function có khả năng tạm ngưng trước khi hàm kết thúc và có thể tiếp tục chạy tại một thời điểm khác, khác với pure function khi được gọi sẽ thực thi hết các câu lệnh trong hàm)</em></div></figure></details></li></ul><ul id="628f0a2a-f970-4d67-82fc-e129fb1f3eb9" class="toggle"><li><details open=""><summary><strong>Một số </strong><mark class="highlight-red"><strong>helper</strong></mark><strong> trong redux-sage ?</strong></summary><ul id="6c2ddf5c-5759-4f9c-920c-cda73a51d3bc" class="bulleted-list"><li style="list-style-type:disc"><code>takeEvery()</code> : thực thi và trả lại kết quả của mọi actions được gọi.</li></ul><ul id="dd5247f6-5786-4462-a744-ada12580f032" class="bulleted-list"><li style="list-style-type:disc"><code>takeLastest()</code> : có nghĩa là nếu chúng ta thực hiện một loạt các actions, nó sẽ chỉ thực thi và trả lại kết quả của của actions cuối cùng.</li></ul><ul id="5a33feeb-7bae-4df7-8f46-eddbab3fe887" class="bulleted-list"><li style="list-style-type:disc"><code>take()</code> : tạm dừng cho đến khi nhận được action</li></ul><ul id="ad4e0293-1b3d-400b-87c2-7992c7990233" class="bulleted-list"><li style="list-style-type:disc"><code>put()</code> : dispatch một action.</li></ul><ul id="573a8d9c-f78b-4c1a-b15b-d7ca283cb043" class="bulleted-list"><li style="list-style-type:disc"><code>call()</code>: gọi function. Nếu nó return về một promise, tạm dừng saga cho đến khi promise được giải quyết.</li></ul><ul id="ef5f2566-051b-4e91-bc63-3208282aa0a5" class="bulleted-list"><li style="list-style-type:disc"><code>race()</code> : chạy nhiều effect đồng thời, sau đó hủy tất cả nếu một trong số đó kết thúc</li></ul></details></li></ul><ul id="e5a1259c-66e9-433e-abcd-b58dc63903f1" class="toggle"><li><details open=""><summary><strong>Redux thunk là gì?</strong></summary><ul id="d15f8e23-700e-445d-aca4-b50acd6b1990" class="bulleted-list"><li style="list-style-type:disc">Redux Thunk là một Middleware cho phép bạn viết các Action trả về một function thay vì một plain javascript object bằng cách trì hoãn việc đưa action đến reducer.</li></ul><ul id="6b74f506-01e1-412e-bd23-e1920f571c6b" class="bulleted-list"><li style="list-style-type:disc">Redux Thunk được sử dụng để xử lý các logic bất đồng bộ phức tạp cần truy cập đến Store hoặc đơn giản là việc lấy dữ liệu như từ server</li></ul></details></li></ul><ul id="6ea7c650-ee4d-45a8-89f0-edfef367d02d" class="toggle"><li><details open=""><summary><strong>Tại sao lại cần dùng redux toolkit ?</strong></summary><p id="5432e968-1889-42f4-9759-9275be6c66ea" class=""><a href="https://www.notion.so/Redux-toolkit-232b0dd9706a419181540db11c3a0e4d">Redux tool kit </a>là một thư viện giúp chúng ta viết redux tốt hơn, dễ hơn và đơn giản hơn (tiêu chuẩn để viết redux).</p><p id="dac6c743-564a-4e97-935b-104ec539f53c" class="">Ba vấn đề làm nền tảng để RTK ra đời: </p><ul id="3a0857a3-bbee-4e77-8028-32a737686233" class="bulleted-list"><li style="list-style-type:disc">Việc Configure một store trong redux rất phức tạp.</li></ul><ul id="6e74a161-21cf-40a0-97dc-d8d26fed8111" class="bulleted-list"><li style="list-style-type:disc">Phải cài thêm nhiều package để làm việc với redux tốt hơn.</li></ul><ul id="cd9943de-839f-493f-83b3-06a442cfa314" class="bulleted-list"><li style="list-style-type:disc">Redux yêu cầu quá nhiều boilerplate code</li></ul></details></li></ul><ul id="08cc901e-bf53-48b6-ad97-41ac16465b28" class="toggle"><li><details open=""><summary><strong>Ngoài redux ra còn có thư viện nào hỗ trợ quản lý state?</strong></summary><ul id="d51223ed-99e4-453f-a543-0b62b5e0391b" class="bulleted-list"><li style="list-style-type:disc">CÓ </li></ul><ul id="c3530e10-3c14-4c7e-87f9-b2ed5b62574d" class="bulleted-list"><li style="list-style-type:disc">Như: mobx, zustand, Context API của react, recoil </li></ul></details></li></ul><ul id="98ee38db-fb45-41db-a9e1-d19859d81552" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Làm thế nào để tạo menu đa cấp bằng đệ quy trong react ?</strong></mark></summary></details></li></ul><ul id="a2b3dadd-7d3c-4a28-b2ee-40a4cee61221" class="toggle"><li><details open=""><summary><strong>Tree shaking là gì ?</strong></summary><ul id="31393184-cfc6-4500-9b2b-2886d35866a1" class="bulleted-list"><li style="list-style-type:disc">“Tree shaking&quot; là một tối ưu hóa hiệu suất bắt buộc phải có khi đóng gói JavaScript. </li></ul><ul id="3422f63d-57f4-4438-a7f3-3c75b7554654" class="bulleted-list"><li style="list-style-type:disc">Nói một cách đơn giản, Tree shaking có nghĩa là xóa code mà không sử dụng đến, hay gọi là code thừa.</li></ul></details></li></ul><ul id="a93ca843-dfca-4779-8750-30b83636260c" class="toggle"><li><details open=""><summary><strong>Webpack là gì ?</strong></summary><ul id="2126b083-b2f1-4e64-934c-a2312d4d747f" class="bulleted-list"><li style="list-style-type:disc">Webpack được biết đến là một công cụ phần mềm được sử dụng để quản lý các module JavaScript. Nó sẽ đóng gói tất cả các mã nguồn của chương trình cũng như CSS, font, image,... khi nó hoạt động. Assets chính là tên để gọi những thứ được đóng gói này và chúng sẽ được Webpack đóng gói thành 1 file hoặc một vài file.</li></ul><ul id="83e6b9aa-26f2-42e6-9f0b-930485d0f909" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>Tác dụng:</strong></span> mặc dù đóng gói rất nhiều dữ liệu nhưng chúng được đóng gói một cách rất cẩn thận, bài bản và ngăn nắp, nó được sắp xếp với cấu trúc tương tự như viết mã code. Những dữ liệu này được lập trình sẵn xem cái nào chạy trước, cái nào chạy sau và phần nào sẽ phụ thuộc vào nhau.</li></ul></details></li></ul><p id="80d03a7f-a21a-4e31-9329-e619459f5e5a" class="">
</p><hr id="5f13573f-20fa-4cc8-963d-4028a76b1f76"/><p id="16931eea-b1cf-470c-9326-bbd7723ac713" class="">
</p><h2 id="f994362c-2d41-43f3-b986-702e79cc86aa" class=""><mark class="highlight-red"><strong>WEB GENERAL</strong></mark></h2><hr id="c0532dda-2f45-4188-8da8-01b431e915d9"/><ul id="761264ad-6877-4056-9fe6-07866d1250a6" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Babel</strong></mark></summary><ul id="6faafd3b-fe99-40d4-94db-5a1d2c3b5e34" class="bulleted-list"><li style="list-style-type:disc">Babel là một trình biên dịch Javascript (source code =&gt;output code), được dùng với mục đích chuyển đổi mã lệnh JavaScript được viết dựa trên tiêu chuẩn ECMAScript phiên bản mới (Như ES6, ES7,...) về phiên bản cũ hơn.</li></ul><ul id="379a08bc-87f0-461e-97b0-d59ff765c4db" class="bulleted-list"><li style="list-style-type:disc">Babel chạy trong 3 giai đoạn: parsing, transforming, and printing (Phân tích, chuyển đổi và in).</li></ul><ul id="c6b1ed2d-cd2f-4a7e-aad4-64b3b439b802" class="bulleted-list"><li style="list-style-type:disc"><strong>Tại sao lại cần sử dụng Babel?</strong><ul id="9e41ea77-1294-4a72-b8c1-413689f4386e" class="bulleted-list"><li style="list-style-type:circle">Ngôn ngữ JavaScript chủ yếu được chạy trên browser, còn browser thì có nhiều loại khác nhau như Chrome, Firefox, Internet Explore, Safari… tất cả đều có những quy định riêng để viết JavaScript. Nên khi code JavaScript của bạn có chạy ngon lành trên Chrome, thì chưa chắc có thể chạy được trên Internet Explore, Safari,...</li></ul><ul id="1a502e71-c75f-400d-bb73-170fa4e3204e" class="bulleted-list"><li style="list-style-type:circle">Phiên bản phổ biến của ECMASCript đang được nhiều trình duyệt hỗ trợ hiên nay là ES5. Phiên bản kế tiếp ES6 mặc dù đã được chính thức ra đời tuy nhiên lại mới chỉ được một số trình duyệt hỗ trợ và không hoàn toàn đầy đủ.</li></ul><ul id="132edc11-ecb8-42f9-83c0-eaba17ea06bb" class="bulleted-list"><li style="list-style-type:circle">Dễ hiểu, Babel là công cụ giúp ta viết code trên phiên bản <strong>ECMASCript mới</strong>, nhưng lại compiler ra phiên bản <strong>ECMASCript cũ </strong>để<strong> tất cả browser có thể đều chạy được.</strong></li></ul></li></ul></details></li></ul><ul id="b08d3494-1ea6-42ce-bf4a-dcd8efeabf4b" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>Build system (webpack, vite)</strong></mark></summary><ul id="0c5a7ed0-c513-4711-a6d3-3d3466a90b2c" class="bulleted-list"><li style="list-style-type:disc"><strong>Webpack</strong> là công cụ giúp bạn compile các module Javascript. Nó hay được gọi là “module bundler”.<ul id="631c5f55-42f5-482a-a964-84f3e0ba9e5b" class="bulleted-list"><li style="list-style-type:circle">Webpack là công cụ giúp gói gọn toàn bộ file js, jsx, img, css(bao gồm cả scss,sass,..)</li></ul><ul id="1d220970-3408-4c19-afa1-fcbfe2d6ec83" class="bulleted-list"><li style="list-style-type:circle">Việc gói gọn không phải là lộn xộn hết cả lên mà nó được gói theo cấu trúc project, từ phần module này sang phần kia.</li></ul><ul id="68c2e226-f6a5-40cd-acb0-21d5ff0123b0" class="bulleted-list"><li style="list-style-type:circle">Ngoài ra webpack còn rất nhiều chức năng hữu dụng khác nữa, như optimize hay tuỳ chọn chạy trên môi trường khác nhau(dev hoặc production),…</li></ul><ul id="f95acac1-6f5c-4538-b7ab-980a3f6cd482" class="bulleted-list"><li style="list-style-type:circle">Webpack nhận vào các module cùng với các dependencies và generate ra các static assets tương ứng.</li></ul><ul id="3e85bbbf-cfb4-457d-a222-1852ed13973b" class="bulleted-list"><li style="list-style-type:circle">Việc sử dụng Webpack sẽ giúp project của chúng ta được optimize hơn rất nhiều.</li></ul><ul id="e623430a-fd55-43c7-a907-69f1f9b08f7a" class="bulleted-list"><li style="list-style-type:circle">Triết lí cốt lõi:<ul id="3ca1ec67-9232-471e-9515-08e2c7e17639" class="bulleted-list"><li style="list-style-type:square"><strong>Mọi thứ đều là module</strong>: khi làm việc với js, chúng ta thường tạo module ứng với 1 hoặc nhiều file js gộp lại. Thì đối với webpack thì những file như (CSS, Images, HTML) đều có thể trở thành module. Nó không khác gì khi chúng ta sử dụng file js cả. Cũng có những câu lệnh import module như <strong>require(“myJSfile.js”) </strong>or <strong>require(“myCSSfile.css”). </strong>Với tính cách module thì chúng ta có thể sử dụng nó ở bất kì ở đâu và có thể re-use khi cho ta muốn.</li></ul><ul id="e9395dfa-e50b-43a4-9453-a2f61b944935" class="bulleted-list"><li style="list-style-type:square"><strong>Load only what you need and when you need</strong>: Thông thường khi làm việc với js, chúng ta sử dụng rất nhiều module khác nhau. Với wepback sẽ gộp tất các cái module đó thành một file <strong>&quot;bundle.js&quot;. T</strong>rong các ứng dụng thực tế file &quot;bundle.js&quot; có dung lượng lên đến <strong>&quot;10MB-15MB&quot;</strong>, đều này không tốt khi sử dụng cho website. Khi client request sẽ load rất lâu dẫn đến trải nghiệm người dùng đối với ứng dụng không tốt. Webpack hiểu ra điều đó nên webpack có vài tính năng chia nhỏ file &quot;bundle&quot; thì nhiều file khác nhau ứng với từng mục đích khác nhau. Việc chia nhỏ vậy, sẽ giúp chúng ta cần load những gì và khi nào cần sử dụng nó.</li></ul></li></ul><ul id="543bac17-ab03-48d0-a64a-673fde0827f5" class="bulleted-list"><li style="list-style-type:circle">Ưu điểm<ul id="bb4d79fa-fd80-44f8-bc2f-e079c6a3b478" class="bulleted-list"><li style="list-style-type:square">Giúp cho cho project dễ dàng phát triển, quản lý, customize</li></ul><ul id="f71b3013-f55f-4365-aea5-21e974436050" class="bulleted-list"><li style="list-style-type:square">Tăng tốc độ cho project</li></ul><ul id="bc5379ac-d158-4915-8a6e-c84afa052dbb" class="bulleted-list"><li style="list-style-type:square">Phân chia các module và chỉ load khi cần</li></ul><ul id="b96afcab-c799-433f-aa95-98713b29628d" class="bulleted-list"><li style="list-style-type:square">Đóng gói tất cả file nguồn thành một file duy nhất, nhờ vào loader mà có thể biên dịch các loại file khác nhau</li></ul><ul id="f408c22b-1dcd-4e1e-b765-4829d2390216" class="bulleted-list"><li style="list-style-type:square">Biến các tài nguyên tĩnh ( image, css) trở thành 1 module</li></ul><ul id="42b78222-cb54-4954-86ff-70eba244c5e3" class="bulleted-list"><li style="list-style-type:square">Chuyển đổi các mã nguồn : JSX, less, sass, scss thành js, ... ES6 -&gt; ES5 thông qua babel transpiler ...</li></ul></li></ul></li></ul><ul id="c66f3023-7e1b-41f9-9750-f6b06e6e0f3b" class="bulleted-list"><li style="list-style-type:disc"><strong>Vite</strong> là một tool mới ra mắt cùng vue3 được phát triển bởi evan you. Về chức năng thì cũng na ná như vue-cli tuy nhiên có một số điểm khác biệt như: <ul id="d8e86462-4a6c-4ba7-b7ea-837e6e1d33c5" class="bulleted-list"><li style="list-style-type:circle">vite không based trên webpack </li></ul><ul id="b5ca6a2e-dde2-4eed-a99e-f65861fc827c" class="bulleted-list"><li style="list-style-type:circle">DevServer sử dụng native ES modules trên trình duyệt.</li></ul><ul id="05a92dbb-f947-43a5-a906-ba02f3811530" class="bulleted-list"><li style="list-style-type:circle">Vite build sử dụng <a href="https://rollupjs.org/guide/en/">Rollup</a>, thằng này cũng được đánh giá khá nhanh</li></ul><ul id="17420926-9a43-4272-abe3-872ca4b9c72e" class="bulleted-list"><li style="list-style-type:circle">Nhược điểm: kén browser, kén dependencies, còn một số lỗi ở môi trường production, ...</li></ul></li></ul></details></li></ul><ul id="08dacf0f-1411-4803-aaa9-e5007d3c5af4" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>OOP là gì? Các thuộc tính ?</strong></mark></summary><ul id="3b5a5ae0-a341-4234-930c-6084b16651c6" class="bulleted-list"><li style="list-style-type:disc"><strong>OOP</strong> là phương pháp lập trình lấy đối tượng làm nền tảng để xây dựng chương trình (hoặc là phương pháp lập trình dựa trên kiến trúc <strong>lớp </strong>(class) và <strong>đối tượng </strong>(object) )</li></ul><ul id="143a8232-2cf9-41c9-aee8-0e675aecdb3c" class="bulleted-list"><li style="list-style-type:disc">Trong lập trình hướng đối tượng, <strong>đối tượng</strong> được hiểu như là 1 thực thể: người, vật hoặc 1 bảng dữ liệu, . . .</li></ul><ul id="3204073e-6484-4d2e-8b48-2cb0c56be1f0" class="bulleted-list"><li style="list-style-type:disc">Một đối tượng bao gồm 2 thông tin: <strong>thuộc tính</strong> và <strong>phương thức</strong>.<ul id="71961194-758b-4de2-acab-a770e8243bd5" class="bulleted-list"><li style="list-style-type:circle"><strong>Thuộc tính </strong>chính là những thông tin, đặc điểm của đối tượng. Ví dụ: một người sẽ có họ tên, ngày sinh, màu da, kiểu tóc, . . .</li></ul><ul id="816a7674-6e5e-46b8-98d5-cfafe80ed5a3" class="bulleted-list"><li style="list-style-type:circle"><strong>Phương thức </strong>là những thao tác, hành động mà đối tượng đó có thể thực hiện. Ví dụ: một người sẽ có thể thực hiện hành động nói, đi, ăn, uống, .</li></ul></li></ul><ul id="944ef2b6-9b78-4bfd-b516-4d7ede971385" class="bulleted-list"><li style="list-style-type:disc"><strong>Class</strong><ul id="4ea9091f-ef76-4814-bc22-861c8a1424eb" class="bulleted-list"><li style="list-style-type:circle">Các đối tượng có các đặc tính tương tự nhau được gom lại thành 1 <strong>lớp đối tượng</strong>.</li></ul><ul id="e2158a73-3b08-4839-a529-ddeac21a93de" class="bulleted-list"><li style="list-style-type:circle">Bên trong lớp cũng có 2 thành phần chính đó là thuộc tính và phương thức.</li></ul><ul id="a1cf8ff1-30c4-4d0d-a143-5dac844c08b9" class="bulleted-list"><li style="list-style-type:circle">Ngoài ra, lớp còn được dùng để định nghĩa ra kiểu dữ liệu mới.</li></ul></li></ul><ul id="5a91b9c6-6fde-46b1-9857-a93726a39476" class="bulleted-list"><li style="list-style-type:disc"><strong>Lớp </strong>là một khuôn mẫu còn <strong>đối tượng </strong>là một thể hiện cụ thể dựa trên khuôn mẫu đó.</li></ul><ul id="0e812017-ea26-40fc-91fa-0ee459706b77" class="bulleted-list"><li style="list-style-type:disc">4 Tính chất của OOP:<ul id="a167f3fa-0023-4b33-98e0-218e0dff5b0f" class="bulleted-list"><li style="list-style-type:circle"><strong>Tính đóng gói (encapsulation): c</strong>ác dữ liệu và phương thức có liên quan với nhau được đóng gói thành các lớp để tiện cho việc quản lý và sử dụng. Ngoài ra, đóng gói còn để che giấu một số thông tin và chi tiết cài đặt nội bộ để bên ngoài không thể nhìn thấy.</li></ul><ul id="29a16ffe-1bb6-43b7-b662-b5364826daa7" class="bulleted-list"><li style="list-style-type:circle"><strong>Tính trừu tượng (abstraction)</strong> : Khi viết chương trình theo phong cách hướng đối tượng, việc thiết kế các đối tượng ta cần rút tỉa ra những đặc trưng chung của chúng rồi trừu tượng thành các interface và thiết kế xem chúng sẽ tương tác với nhau như thế nào.</li></ul><ul id="a2fa88e4-400d-4d66-a71d-01349eb6b819" class="bulleted-list"><li style="list-style-type:circle"><strong>Tính kế thừa (inheritance): </strong>Lớp cha có thể chia sẽ dữ liệu và phương thức cho các lớp con, các lớp con khỏi phải định nghĩa lại, giúp chương trình ngắn gọn. </li></ul><ul id="b58c95d3-9fc1-4a7d-8d00-d82d2ee024fc" class="bulleted-list"><li style="list-style-type:circle"><strong>Tính đa hình (polymorphism):</strong> Là hiện tượng các đối tượng thuộc các lớp khác nhau có thể hiểu cùng một thông điệp theo các cách khác nhau. </li></ul></li></ul><ul id="69f34dc9-966e-4413-ae20-1900145be66a" class="bulleted-list"><li style="list-style-type:disc"><strong>Lớp trừu tượng</strong> là lớp được khai báo mà không thể tạo ra đối tượng từ lớp đó. Ta sẽ tạo những lớp con kế thừa lớp trừu tượng.<ul id="5d4d25d5-df2f-438a-8e1c-ceb4cfdfc529" class="bulleted-list"><li style="list-style-type:circle">Mục đích lớp trừu tượng là tạo ra lớp chung cho những lớp có liên quan với nhau kế thừa. </li></ul><ul id="a27a5d0d-601d-495b-8b42-35a2ac55030d" class="bulleted-list"><li style="list-style-type:circle">Ví dụ khi xây dựng phần mềm quản lý nhà trường: Những lớp sinh viên, giảng viên, cán bộ,… có những thuộc tính và phương thức chung như tên, năm sinh, quê quán,… thì ta sẽ tạo một lớp con người là lớp trừu tượng và những đặc điểm chung được để trong lớp con người. Khi phát triển chương trình, ta chỉ có thể tạo các đối tượng từ lớp con kế thừa lớp con người; không thể cho tạo đối tượng từ lớp con người được</li></ul></li></ul><ul id="ec273d42-3b6c-48bd-bc21-d877a27611e6" class="bulleted-list"><li style="list-style-type:disc"><strong>Các phương thức trừu tượng</strong> là là chỉ định nghĩa mà không có chương trình bên trong, lớp con kế thừa phải bắt buộc override nó lại để sử dụng. Phương thức trừu tượng có ý nghĩa định nghĩa phương thức bắt buộc phải có trong lớp con kế thừa.</li></ul></details></li></ul><ul id="6b4007be-43d5-4753-99db-2e751284f837" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong><strong>Từ khóa static làm gì?</strong></strong></mark></summary><ul id="57ae46f2-4aac-4361-8fb0-800b4f25959b" class="bulleted-list"><li style="list-style-type:disc">Khi ta khai báo các thuộc tính, phương thức thì nó chỉ được sử dụng khi khởi tạo đối tượng, thông tin cũng thuộc đối tượng đó.</li></ul><ul id="5e7b0d78-c462-4e55-8ecf-659d86514c9c" class="bulleted-list"><li style="list-style-type:disc">Có những lúc, ta cần những thông tin chung cho tất cả các đối tượng. Có nghĩa những thông tin đó lưu ở một vùng nhớ duy nhất. </li></ul><ul id="c16a17f7-fe67-4c54-936f-2ad34b8c03ba" class="bulleted-list"><li style="list-style-type:disc">Từ khóa static sử dụng để quản lý bộ nhớ, khi những thành viên bên trong một lớp có từ khóa <strong>static</strong> thì nó thuộc về lớp, không phải thuộc về riêng một đối tượng nào đó.</li></ul></details></li></ul><ul id="7f88395a-9f9d-491a-bf5d-eba6ec5db927" class="toggle"><li><details open=""><summary><strong><mark class="highlight-red">Nguyên lý solid là gì?</mark></strong></summary><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="69f1cf77-dfbb-470a-8593-a1ad775654af"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong><em>SOLID</em></strong><em> là năm nguyên lý cơ bản trong thiết kế phần mềm hướng đối tượng, giúp code trở nên dễ hiểu, mềm dẻo và dễ bảo trì hơn. Tác giả của SOLID là kỹ sư phần mềm nổi tiếng Robert C. Martin.</em></div></figure><p id="95940d1b-f78c-4b71-9375-cee9ebff45ad" class=""><a href="https://kipalog.com/posts/Tim-hieu-nhanh-SOLID-than-thanh">https://kipalog.com/posts/Tim-hieu-nhanh-SOLID-than-thanh</a></p><ul id="f8fd0cb6-4cb3-4d19-8cc8-6e1b4994ec30" class="bulleted-list"><li style="list-style-type:disc"><strong>S - Single Responsibility Principle (SRP):</strong> <figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1b0544f7-de7e-44e9-8316-1c2e381d3d9f"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><em><strong>A class should have only a single responsibility.</strong></em></div></figure><ul id="1027aa52-d338-4947-8111-413f82e3c0b8" class="bulleted-list"><li style="list-style-type:circle">Ý tưởng của nguyên lý này là giúp chúng ta giảm đi sự phức tạp của class: một class chỉ nên phục vụ một mục đích duy nhất</li></ul></li></ul><ul id="7fdc52a5-cadf-4c16-a790-56b0e7e3a230" class="bulleted-list"><li style="list-style-type:disc"><strong>O - Open Closed Principle (OCP):</strong> <figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1740e247-5c77-42be-9cb2-fe68d8519153"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><em><strong>Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.</strong></em></div></figure><ul id="912aff69-48fd-4242-9ed1-c5f2e093ea05" class="bulleted-list"><li style="list-style-type:circle">Ý tưởng của nguyên lý này là khi triển khai các tính năng mới, thay vì sửa đổi code đã tồn tại, chúng ta nên mở rộng/kế thừa.</li></ul></li></ul><ul id="d1ecbb64-030c-46ee-8cfc-a76fdf790862" class="bulleted-list"><li style="list-style-type:disc"><strong>L - Liskov Substitution Principle(LSP):</strong> <figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="b8e48c04-f5ec-450a-b8da-55652244a167"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><em><strong>Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program.</strong></em></div></figure><ul id="e04143fb-fc3f-45e8-9583-8a12d4ff3293" class="bulleted-list"><li style="list-style-type:circle">Nguyên lý này có thể hiểu là các đối tượng của class cha có thể được thay thế bởi các đối tượng của các class con mà không làm thay đổi tính đúng đắn của chương trình.</li></ul></li></ul><ul id="bd11a91e-58d6-4515-b234-348277f49da3" class="bulleted-list"><li style="list-style-type:disc"><strong>I - Interface Segregation Principle (ISP):</strong> <figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="a4133a70-1e54-4e7e-856f-f4907aa562bf"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><em><strong>Many client-specific interfaces are better than one general-purpose interface.</strong></em></div></figure><ul id="291c4463-9f14-40c0-a1f4-11664872e2de" class="bulleted-list"><li style="list-style-type:circle">Nguyên lý này có thể hiểu là thay vì viết một interface cho một mục đích chung chung, chúng ta nên tách thành nhiều interface nhỏ cho các mục đích riêng. </li></ul><ul id="28139474-f355-4c81-adae-d09c1fc5d694" class="bulleted-list"><li style="list-style-type:circle">Chúng ta không nên bắt buộc client phải implement các method mà client không cần đến.</li></ul></li></ul><ul id="c468a1a1-9476-44d6-8f0b-a8a1c4ad2776" class="bulleted-list"><li style="list-style-type:disc"><strong>D - Dependency Inversion Principle:</strong> <figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="4ddd5eaa-b2b7-4403-9566-b9d33ad1b40b"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><em><strong>Depend on abstractions, not on concretions.</strong></em></div></figure><ul id="832eacc1-2249-457f-b09b-4f981af3a1df" class="bulleted-list"><li style="list-style-type:circle">Ý tưởng của nguyên lý này là các module cấp cao không nên phụ thuộc vào các module cấp thấp, cả hai nên phụ thuộc vào abstraction.</li></ul></li></ul></details></li></ul><p id="09891557-9d08-4d4b-8d3c-e175041b3d6a" class="">
</p><p id="f14e29b4-e012-46f2-ab81-b47770000911" class="">
</p><hr id="b40cc819-28c8-4036-bddb-0b20bba6498e"/><p id="41477f46-9b46-4c69-835c-3171ae108cde" class="">
</p><h2 id="1f051bce-04b6-4435-a9e6-6d474deb1201" class=""><mark class="highlight-red">Microservice - Micro-frontend</mark></h2><hr id="d0223c1d-be60-41c1-954f-ca4230489ab5"/><ul id="dfc9fad5-8ab7-40ea-9fd9-d2ed826d5a4b" class="toggle"><li><details open=""><summary><strong>Sự khác nhau giữa </strong><mark class="highlight-red"><strong>monolithic</strong></mark><strong> và </strong><mark class="highlight-red"><strong>microservice</strong></mark></summary><ul id="d00237b9-01ec-4cef-a59c-788b7585312a" class="bulleted-list"><li style="list-style-type:disc"><strong>Monolithic</strong> là kiến trúc cũ trước đây thường sử dụng, nó là kiến trúc dạng nguyên khối, nghĩa là mọi tính năng đều sẽ nằm trong 1 project<ul id="f49f3de6-fd01-4869-acc3-040e35ddeb92" class="toggle"><li><details open=""><summary><span style="border-bottom:0.05em solid"><strong>Ưu điểm: </strong></span></summary><ul id="e459f60b-9059-4377-bcf2-c6fd79076a0f" class="bulleted-list"><li style="list-style-type:disc">Dễ phát triển vì các stack công nghệ thống nhất với nhau</li></ul><ul id="4a6dfd2b-71bd-479f-9543-42b513a6730f" class="bulleted-list"><li style="list-style-type:disc">Testing, deploy cũng tương đối đơn giản</li></ul><ul id="5edeb985-337b-4352-823b-364de06eb0e6" class="bulleted-list"><li style="list-style-type:disc">Dễ scale vì có thể tạo nhiều instance cho load balancer</li></ul><ul id="1380a9b9-731a-4cde-a871-03ce72a1ef6d" class="bulleted-list"><li style="list-style-type:disc">Về mặt cơ sở hạ tầng (infrastructure) đơn giản. Chỉ cần 1 container cũng có thể chạy ứng dụng</li></ul><ul id="ddabd5bb-e049-46b9-9dcc-3d3169eb8843" class="bulleted-list"><li style="list-style-type:disc">Team size nhỏ</li></ul></details></li></ul><ul id="eb2c65b7-0615-4f9e-98f7-23851e58f5a8" class="toggle"><li><details open=""><summary><span style="border-bottom:0.05em solid"><strong>Nhược điểm:</strong></span></summary><ul id="22af6965-828c-438b-9c21-8b9f134479e2" class="bulleted-list"><li style="list-style-type:disc">Các component nó liên kết chặt chẽ với nhau nên khi có 1 thay đổi trong 1 component nào đó cũng có thể ảnh hưởng tới component khác</li></ul><ul id="f9d8aa34-9da5-4ad2-9bc2-9c3d8692712c" class="bulleted-list"><li style="list-style-type:disc">Khi project trở nên lớn dần. Các tính năng mới sẽ mất nhiều thời gian để phát triển cũng như maintain những tính năng hiện có cũng sẽ gặp nhiều khó khăn</li></ul><ul id="b8de7b20-eca6-4b24-997d-54e5da678595" class="bulleted-list"><li style="list-style-type:disc">Áp dụng công nghệ mới sẽ rất khó khăn vì toàn bộ ứng dụng phải thay đổi.</li></ul><ul id="7881cdbf-7997-45b5-98c5-28597f40772f" class="bulleted-list"><li style="list-style-type:disc">Không hề dễ để hiểu project do các module liên quan chặt chẽ lẫn nhau. Một issue nhỏ cũng có thể làm chết toàn bộ ứng dụng.</li></ul><ul id="1a06fa5d-3574-4cf6-962e-3b96210b3c6c" class="bulleted-list"><li style="list-style-type:disc">Có thời gian khởi động lâu và tốn tài nguyên CPU cũng như bộ nhớ.</li></ul><ul id="4620a771-5305-43c4-b03f-820233854ee5" class="bulleted-list"><li style="list-style-type:disc">Các team tham gia vào dự án phải phụ thuộc lẫn nhau và tất khó để mở rộng quy mô team.</li></ul></details></li></ul></li></ul><ul id="d52b78c6-1683-41e4-a378-c15240a24282" class="bulleted-list"><li style="list-style-type:disc"><strong>Microservice </strong>là kiến trúc mới, chia dự án thành nhiều service nhỏ. Mỗi service sẽ độc lập với nhau. Có thể có kiến trúc khác nhau, hoặc sử dụng công nghệ khác nhau, hoặc dùng cả database khác nhau. Chúng giao tiếp với nhau thông qua môi trường mạng như restful API hoặc message queue<ul id="6a7989db-cdcc-45b9-8eaf-bfb463a3ca81" class="toggle"><li><details open=""><summary><span style="border-bottom:0.05em solid"><strong>Ưu điểm: </strong></span></summary><ul id="e3215a9e-fa62-4970-b039-7de88143e86c" class="bulleted-list"><li style="list-style-type:disc">Các component có kết nối lỏng lẻo dẫn đến dễ cách ly, dễ test và khởi động nhanh.</li></ul><ul id="99efaae4-9ac6-4024-8ea8-230b3e3ad1a3" class="bulleted-list"><li style="list-style-type:disc">Vòng đời phát triển nhanh hơn. Tính năng mới được phát triển nhanh hơn và tính năng cũ được cấu trúc lại dễ hơn.</li></ul><ul id="4e4bb5d3-c320-40d0-92e5-0ca66753526e" class="bulleted-list"><li style="list-style-type:disc">Các service có thể deploy độc lập nên ứng dụng dễ đọc, dễ tạo các bản vá hơn.</li></ul><ul id="91b9809d-3a0d-4d5c-9281-3a2629f7c901" class="bulleted-list"><li style="list-style-type:disc">Những issue, ví dụ liên quan đến memory leak một trong các service, bị cô lập và có thể không làm sập ứng dụng.</li></ul><ul id="24d8b51c-d4f2-4fd3-a50a-ec67bb76d5c9" class="bulleted-list"><li style="list-style-type:disc">Việc áp dụng các công nghệ mới dễ hơn. Các component có thể được nâng cấp độc lập với nhau.</li></ul><ul id="f79dabe6-0121-463a-8ea2-00dba3f3379b" class="bulleted-list"><li style="list-style-type:disc">Các mô hình scale phức tạp và hiệu quả hơn có thể được thiết lập. Các service quan trọng có thể scale hiệu quả hơn. Các component riêng sẽ khởi động nhanh hơn và cải thiện thời gian khởi động của cả hệ thống.</li></ul><ul id="7da57269-a423-4022-9e44-68b7b27a28dc" class="bulleted-list"><li style="list-style-type:disc">Các team tham gia sẽ ít phụ thuộc lẫn nhau. Kiến trúc này rất thích hợp cho các đội Agile.</li></ul></details></li></ul><ul id="5d9ee9b1-5821-48e5-8768-2a166f245a03" class="toggle"><li><details open=""><summary><span style="border-bottom:0.05em solid"><strong>Nhược điểm:</strong></span></summary><ul id="a8f8f2e0-3cf6-4c48-ba5c-7e690e07c0c2" class="bulleted-list"><li style="list-style-type:disc">Phức tạp hơn về mặt tổng thể vì các component khác nhau có các stack công nghệ khác nhau nên buộc team phải tập trung đầu tư thời gian để theo kịp công nghệ.</li></ul><ul id="59a60496-f52c-4baf-9d31-85735331adaf" class="bulleted-list"><li style="list-style-type:disc">Khó thực hiện test end-to-end và integration test vì có nhiều stack công nghệ khác nhau.</li></ul><ul id="65fa32bb-e036-4605-a1aa-f50cdb82b3ca" class="bulleted-list"><li style="list-style-type:disc">Deploy toàn bộ ứng dụng phức tạp hơn vì có nhiều container và nền tảng ảo hóa liên quan.</li></ul><ul id="844de249-68a0-4487-a766-160c99cd4dc2" class="bulleted-list"><li style="list-style-type:disc">Ứng dụng được scale hiệu quả hơn nhưng thiết lập nâng cấp sẽ phức tạp hơn vì nó sẽ yêu cầu nâng cao nhiều tính năng như truy tìm dịch vụ (service discovery), định tuyến DNS,…</li></ul><ul id="160b3380-1d6a-4c06-906e-d304e26584f1" class="bulleted-list"><li style="list-style-type:disc">Yêu cầu một team-size lớn để maintain ứng dụng vì có nhiều component và công nghệ khác nhau.</li></ul><ul id="44523397-8717-4e3e-8b61-90f2c8b1529d" class="bulleted-list"><li style="list-style-type:disc">Các thành viên trong team chia sẻ các skill khác nhau dựa trên component họ làm nên sẽ tạo ra sự khó khăn khi thay thế và chia sẻ kiến thức.</li></ul><ul id="020158a4-8a3c-40c6-81c8-986f0e85dd8b" class="bulleted-list"><li style="list-style-type:disc">Stack công nghệ phức tạp và khó để học hơn.</li></ul><ul id="32f9a17c-405a-4ada-8b68-4d59d356240a" class="bulleted-list"><li style="list-style-type:disc">Thời gian phát triển ban đầu là chậm nên thời gian để có thể làm marketing lâu hơn.</li></ul><ul id="04f1f7a5-b832-4b85-88e0-a251f7cf36d7" class="bulleted-list"><li style="list-style-type:disc">Yêu cầu cơ sở hạ tầng phức tạp. Thông thường sẽ yêu cầu nhiều container (Docker) và nhiều máy JVM để chạy.</li></ul></details></li></ul><ul id="67139545-3e6a-4a5b-b8d1-fd6d51a505ab" class="bulleted-list"><li style="list-style-type:circle"></li></ul></li></ul></details></li></ul><ul id="48f7e665-d634-4254-92ca-fe794b517ff7" class="toggle"><li><details open=""><summary><strong><strong>Vai trò của Docker trong Microservices?</strong></strong></summary><ul id="c8e96c68-1f33-4216-9c18-40aa4b1b4fab" class="bulleted-list"><li style="list-style-type:disc">Docker thường cung cấp một môi trường container, trong đó bất kỳ ứng dụng nào cũng có thể được host. <strong></strong></li></ul><ul id="11c35ca0-3044-4088-a3ee-4e51ed72f428" class="bulleted-list"><li style="list-style-type:disc">Điều này được thực hiện bằng cách đóng gói chặt chẽ cả ứng dụng và các phụ thuộc cần thiết để hỗ trợ nó. </li></ul><ul id="d0780f3b-1a53-437e-b63c-af8ce7e29971" class="bulleted-list"><li style="list-style-type:disc">Các sản phẩm đóng gói này được gọi là Container và vì Docker đã quen với việc đó nên chúng được gọi là Docker container. </li></ul><ul id="a7255566-5b5a-45c2-baaa-5bc712463fab" class="bulleted-list"><li style="list-style-type:disc">Về bản chất, Docker cho phép bạn chứa các microservice của mình và quản lý các microservices này dễ dàng hơn.</li></ul></details></li></ul><ul id="8b45ad84-8dbf-4d8c-b35a-c012cf838ce7" class="toggle"><li><details open=""><summary><strong><strong>Giải thích về </strong></strong><mark class="highlight-red"><strong><strong>OAuth</strong></strong></mark><strong><strong> và </strong></strong><mark class="highlight-red"><strong><strong>OAuth2</strong></strong></mark><strong><strong>?</strong></strong></summary><ul id="95b1f920-56af-4f69-86e7-86b0f0e6310a" class="bulleted-list"><li style="list-style-type:disc"><strong>OAuth</strong> là một phương thức xác thực giúp một ứng dụng bên thứ 3 có thể được ủy quyền bởi người dùng để truy cập đến tài nguyên người dùng nằm trên một dịch vụ khác. OAuth là từ ghép của O(Open) và Auth tượng trưng cho:<ul id="125bcf62-b080-45a0-9ffd-38f940a8ba56" class="bulleted-list"><li style="list-style-type:circle"><em>Authentication</em>: xác thực người dùng.</li></ul><ul id="02191067-56ed-49c2-acbd-92324d0c9ddb" class="bulleted-list"><li style="list-style-type:circle"><em>Authorization</em>: cấp quyền truy cập đến tài nguyên mà người dùng hiện đang nắm giữ.</li></ul></li></ul><ul id="295895f8-e0a9-41e6-a446-f5339deaa219" class="bulleted-list"><li style="list-style-type:disc"><strong>OAuth2</strong> là bản nâng cấp của <strong>OAuth1.0</strong>, là một giao thức chứng thực cho phép các ứng dụng chia sẻ một phần tài nguyên với nhau mà không cần xác thực qua username và password như cách truyền thống từ đó giúp hạn chế được những phiền toái khi phải nhập username, password ở quá nhiều nơi hoặc đăng ký quá nhiều tài khoản mật khẩu mà chúng ta chẳng thể nào nhớ hết.</li></ul></details></li></ul><ul id="0ec81342-5849-4845-b783-6bd83fc08b03" class="toggle"><li><details open=""><summary><strong><strong>Giải thích cách microservice giao tiếp với các phần khác?</strong></strong></summary><ul id="6e98747b-9a4a-4936-a295-13f5f3f4d51d" class="bulleted-list"><li style="list-style-type:disc">Giao tiếp giữa các microservice có thể thực hiện:<ul id="e5a6c5c3-24a1-4e2b-9b05-f806775e0c77" class="bulleted-list"><li style="list-style-type:circle">HTTP/REST với JSON hoặc giao thức nhị phân cho request/response.</li></ul><ul id="c32e13f8-b063-412e-8a8d-123e5c21bdbf" class="bulleted-list"><li style="list-style-type:circle">Websocket cho streaming</li></ul><ul id="07549d0d-5974-461e-a1c9-452cc5fe3c47" class="bulleted-list"><li style="list-style-type:circle">Một broker hoặc server dùng cho các thuật toán routing.</li></ul></li></ul><p id="722f4cbd-e5d4-4bc1-9fe7-5993f6b53cb7" class="">→ RabbitMQ, Kafka,... có thể dùng như một message broker, mỗi cái được xây dựng để xử lý message cụ thể.</p></details></li></ul><ul id="8053ce80-474e-4aae-baa8-5d4b4c8aa6fb" class="toggle"><li><details open=""><summary><strong><strong>Các thành phần chính trong Microservices?</strong></strong></summary><ul id="baf1d69b-2172-45c5-b6a4-8fd0de6c3b22" class="bulleted-list"><li style="list-style-type:disc">Containers, Clustering, và Orchestration.</li></ul><ul id="9eb58838-02a3-46b8-ac3d-d41bf2389b44" class="bulleted-list"><li style="list-style-type:disc">IaC [Infrastructure as Code Conception]</li></ul><ul id="05525495-34fe-4bd8-8dc8-e2c0b1cc707b" class="bulleted-list"><li style="list-style-type:disc">Cloud Infrastructure</li></ul><ul id="bec08ba6-7792-4981-ada8-5b0224621140" class="bulleted-list"><li style="list-style-type:disc">API Gateway</li></ul><ul id="d30e5e29-88dd-45eb-9ca1-f6ac3b2f1c66" class="bulleted-list"><li style="list-style-type:disc">Enterprise Service Bus</li></ul><ul id="7cbf9a75-0284-427f-8319-4ce4235302cf" class="bulleted-list"><li style="list-style-type:disc">Service Delivery</li></ul></details></li></ul><ul id="236bd089-c12c-47f2-8cef-cd87fa4bac4d" class="toggle"><li><details open=""><summary><strong>Micro frontend là gì?</strong></summary><ul id="7a5b2de4-1949-4474-aaa7-1a29f5eda21d" class="bulleted-list"><li style="list-style-type:disc">Ý tưởng của Micro Frontends cũng giống như microservice ở phía BE đó là sẽ phân tách các ứng dụng này thành các phần kết hợp của các tính năng, mỗi tính năng có thể được phát triển bới một team độc lập.</li></ul><ul id="31d637cc-21d6-463f-812e-6bec3cfb19a3" class="bulleted-list"><li style="list-style-type:disc">Trước đó có các mô hình phát triển phần mềm trước khi có micro fe:<ul id="978d3373-984f-47f6-973d-e2d4a95ba164" class="bulleted-list"><li style="list-style-type:circle"><strong>Monolithic</strong>: một team phát triển toàn bộ các thành phần của sản phẩm từ Database, Backend, Frontend</li></ul><ul id="0387e8b5-2091-41f8-911a-3adff825a073" class="bulleted-list"><li style="list-style-type:circle"><strong>Front &amp; Back: </strong>chia team phát triển thành 2 team FE và BE</li></ul><ul id="038d8b4b-eab6-4177-9dd9-ac63ed870ed2" class="bulleted-list"><li style="list-style-type:circle"><strong>Microservices:</strong> chúng ta chia nhỏ các chức năng thành các dịch vụ riêng để thuận tiện cho quá trình phát triển. Tuy nhiên việc phần chia các dịch vụ này chỉ ở phần backend cho nên phía frontend vẫn phải phát triển chung các chức năng với nhau ở một bộ source code.</li></ul><p id="21b2e3b1-c218-4062-bb64-9a690dac3d02" class="">→<strong>Mô hình Micro frontends</strong>: mỗi team sẽ phát triển các sản phẩm độc lập (từ Database, Backend đến Frontend). Sau đó tích hợp các sản phẩm độc lập này lại với nhau thành một sản phẩm chung.</p></li></ul></details></li></ul><ul id="25843c68-6ec3-426f-83bf-fd1bc0125d10" class="toggle"><li><details open=""><summary><strong>Khi nào nên dùng Micro FE?</strong></summary><ul id="05c02b89-9146-4c30-978a-c430314927c7" class="bulleted-list"><li style="list-style-type:disc">Một sản phẩm có nhiều module chức năng và bạn muốn nhiều team có thể phát triển cùng lúc</li></ul><ul id="ab39310b-796c-44ee-bb32-1efb8fd6b44e" class="bulleted-list"><li style="list-style-type:disc">Có thể bạn sẽ muốn phát triển một progressive hoặc responsive web application nhưng bạn gặp khó khăn trong việc tích hợp vào source code hiện tại của mình</li></ul><ul id="e2be668a-e54f-4313-9329-fa140d9ff2a4" class="bulleted-list"><li style="list-style-type:disc">Có thể bạn muốn sử dụng một thư viện mới để tăng tốc quá trình phát triển sản phẩm của mình (vd: trước đó sử dụng Angularjs (1.x) để phát triển và hiện tại muốn sử dụng ReactJS để phát triển)</li></ul><ul id="35cd0804-ecdc-47c7-90cb-cf10936addf5" class="bulleted-list"><li style="list-style-type:disc">Bạn muốn sử dụng một thư viện mới để hỗ trợ cho các chức năng sản phẩm, như sử dụng Webpack 5.x nhưng project hiện tại đang sử dụng Webpack 3.x và khó có thể nâng cấp lên Webpack 5.x được vì có khá nhiều dependence bị ảnh hưởng.</li></ul><ul id="01673710-be54-4c5f-a6e1-cc9478c4dace" class="bulleted-list"><li style="list-style-type:disc">Có thể bạn muốn tăng tốc quá trình phát triển sản phẩm bằng cách nhiều team khác nhau tham gia vào phát triển một sản phẩm cùng lúc bằng việc tách ra nhiều module và phát triển độc lập.</li></ul></details></li></ul><ul id="d9e60ca4-101b-428f-8aa2-1baf7a03f8ab" class="toggle"><li><details open=""><summary><strong>Một số ưu điểm và nhược điểm của Micro Frontends là gì ?</strong></summary><ul id="d8a25ddc-ebe7-4f42-9e48-7e2c50c76285" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>Ưu điểm:</strong></span><ul id="c80d5aa3-084b-4fe5-a776-d226504106e7" class="bulleted-list"><li style="list-style-type:circle">Tách biệt các module chức năng thành nhiều phần source code riêng biệt. Từ đó giảm các dependencies ở mỗi project, lượng code sẽ ít hơn, giúp cho quá trình build deploy nhanh hơn và các file js bundle cũng sẽ nhẹ hơn</li></ul><ul id="f84a77fd-879e-4421-b514-1a18e48c7e40" class="bulleted-list"><li style="list-style-type:circle">Có khả năng mở rộng một cách dễ dàng bằng cách nhiều team cùng tham gia.</li></ul><ul id="278a2903-b708-4a34-a1f7-c0f075c22963" class="bulleted-list"><li style="list-style-type:circle">Có thể sử dụng các thư viện, framework khác nhau (React, Angular) để phát triển các module khác nhau của một dự án.</li></ul><ul id="82bc6146-0edf-4eaf-9844-d81c274b6307" class="bulleted-list"><li style="list-style-type:circle">Có khả năng cập nhật, nâng cấp thư viện hoặc phát triển lại một phần nào đó của dự án.</li></ul><ul id="bbfff07a-96eb-47e8-b318-12b0c04b0b0c" class="bulleted-list"><li style="list-style-type:circle">Dễ dàng kiểm thử (testing) các chức năng một cách độc lập.</li></ul></li></ul><ul id="b33ae258-3d33-4801-b21a-89edf7f5662c" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>Nhược điểm: </strong></span><ul id="5a72c7dd-bfa0-418c-9f23-d964d6ce263d" class="bulleted-list"><li style="list-style-type:circle">Chia nhỏ các dự án sẽ dẫn tới trùng lập các dependencies hoặc source code</li></ul><ul id="25569af2-4610-430c-941a-7906e3e0d889" class="bulleted-list"><li style="list-style-type:circle">Nhiều team phát triển nên khó trong việc quản lý source code nếu không có quy định chung rõ ràng từ ban đầu.</li></ul></li></ul></details></li></ul><ul id="86f01c7f-8a1e-4311-9fb5-b64de449fe8a" class="toggle"><li><details open=""><summary><strong>Một số phương pháp triển khai Micro Frontends</strong></summary><p id="56128e64-4920-486e-bbfc-19a095e57094" class=""><a href="https://micro-frontends.tuando.net/">https://micro-frontends.tuando.net/</a></p><ul id="d44c7c88-62df-45da-9c9e-a60fbed937e2" class="toggle"><li><details open=""><summary><strong><strong>Build-time integration</strong></strong></summary><ul id="338e138f-f97a-42d3-8983-5042a3b0a35b" class="bulleted-list"><li style="list-style-type:disc">là việc coi các ứng dụng như một package và ứng dụng chính sẽ thêm các ứng dụng con như một thư viện như sau:</li></ul><pre id="57d4508b-9e18-46c9-8d6a-215e41fee264" class="code"><code>{
  &quot;name&quot;: &quot;@micro-frontends/container&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;Micro frontends demo&quot;,
  &quot;dependencies&quot;: {
    &quot;@micro-frontends/products&quot;: &quot;^1.2.3&quot;,
    &quot;@micro-frontends/checkout&quot;: &quot;^4.5.6&quot;,
    &quot;@micro-frontends/user-profile&quot;: &quot;^7.8.9&quot;
  }
}</code></pre><ul id="f407aa86-d564-41cb-a33e-7b38d970ecd8" class="bulleted-list"><li style="list-style-type:disc">Cách tiếp cận này có một số hạn chế như:<ul id="e6560b30-3ac6-4fd4-ae8b-ed55d496b787" class="bulleted-list"><li style="list-style-type:circle">Chúng ta sẽ phải re-compile (bundle) các ứng dụng chính và release lại mỗi khi các ứng dụng con có thay đổi (release version mới từ 0.0.1 ⇒ 0.02)</li></ul><ul id="c3dc7ab2-109b-4b28-9cdd-ed2dbf4bbaed" class="bulleted-list"><li style="list-style-type:circle">Không có sự đồng bộ chức năng giữa các ứng dụng chính nếu chúng ta bỏ xót quá trình đồng bộ version của ứng dụng con (Cũng có thể là một điểm lợi nếu chúng ta không muốn nâng cấp chức năng ở một trang nào đó)</li></ul><ul id="29c06d75-43b9-4b76-865f-6ff4ca372a43" class="bulleted-list"><li style="list-style-type:circle">Phụ thuộc các dependencies với nhau<ul id="06ec3c58-ee77-497b-8734-db731cf382a2" class="bulleted-list"><li style="list-style-type:square">Nếu project <code>@micro-frontends/container</code> sử dụng React và <code>@micro-frontends/products</code> cũng sử dụng React thì sẽ bị trùng lập thư viện và tăng dung lượng khi tải trang web</li></ul><ul id="195f826c-c12f-4e71-92ff-38c66880d86b" class="bulleted-list"><li style="list-style-type:square">Nếu project <code>@micro-frontends/container</code> sử dụng React và <code>@micro-frontends/products</code> sử dụng chung React với project chính thì sẽ bị phụ thuộc vào version của project chính.</li></ul></li></ul></li></ul></details></li></ul><ul id="9d2f662a-cd49-4926-a57c-5b3f2a5b917b" class="toggle"><li><details open=""><summary><strong><strong>Run-time integration via iframes</strong></strong></summary><pre id="fc2a4db8-9166-44a9-ac99-b15ec5f889cf" class="code"><code>&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Micro frontends&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Welcome to Micro frontends&lt;/h1&gt;

    &lt;iframe id=&quot;micro-frontend-container&quot;&gt;&lt;/iframe&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
      const microFrontendsByRoute = {
        &#x27;/&#x27;: &#x27;https://micro-frontends.tuando.net/demo/react-example&#x27;,
        &#x27;/products&#x27;: &#x27;https://micro-frontends.tuando.net/demo/react-example/products&#x27;
      };

      const iframe = document.getElementById(&#x27;micro-frontend-container&#x27;);
      iframe.src = microFrontendsByRoute[window.location.pathname];
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><ul id="d2bdac2f-0cf0-4df7-8d16-c2ba75eff289" class="bulleted-list"><li style="list-style-type:disc">Mỗi lần thay đổi url từ <code>/</code> sang <code>/products</code> phần nội dụng của trang sẽ được tải lại bởi một nội dung từ domain khác, trong ví dụ là <code>/demo/react-example/products</code></li></ul><ul id="eec1eed8-50fb-4c03-8ec7-44b69dc2dbae" class="bulleted-list"><li style="list-style-type:disc">Ưu điểm:<ul id="dcb06be6-7868-49db-ace3-0f4ce2b5b23d" class="bulleted-list"><li style="list-style-type:circle">Không bị ảnh hưởng bởi styles (CSS) giữa các trang chính và trang trong iframe</li></ul></li></ul><ul id="496fcf20-847a-44ea-a7ba-a9b14322b692" class="bulleted-list"><li style="list-style-type:disc">Hạn chế:<ul id="aac56db9-8a70-477f-9842-bbbbf9656a75" class="bulleted-list"><li style="list-style-type:circle">Phải tải lại toàn bộ trang khi thay đổi đường dẫn</li></ul><ul id="0443887c-bf5e-4e1b-a8b8-ed5c8a7e1077" class="bulleted-list"><li style="list-style-type:circle">Khó khăn trong việc giao tiếp giữa các chức năng</li></ul></li></ul></details></li></ul><ul id="d259c34f-5809-41da-b5cf-7f18e48a65e6" class="toggle"><li><details open=""><summary><strong><strong>Run-time integration via JavaScript</strong></strong></summary><ul id="79785c9a-b88b-4c35-ab08-46fe29b2a693" class="bulleted-list"><li style="list-style-type:disc">Các tiếp cận này là việc chúng ta khai báo các global function hỗ trợ render các chức năng ở dự án con. Sau đó ở dự án chính ta sẽ gắn các script bundle file của các dự án con, tiếp theo cần hiện thị chức năng nào thì chỉ việc gọi chức năng đó thôi.</li></ul><pre id="384bcc30-4f83-4eae-ad92-07ff426e17bf" class="code"><code>import React from &quot;react&quot;;
import ReactDOM from &quot;react-dom&quot;;
import App from &quot;./App&quot;;

window.renderProducts = (containerId, history) =&gt; {
    ReactDOM.render(
        &lt;App history={history} /&gt;,
        document.getElementById(containerId),
    );
};</code></pre><p id="0be35e64-e9c2-4afa-92c7-01754ead5772" class="">
</p></details></li></ul><ul id="af56286a-cb38-449f-adc8-a9aa2a3a34fc" class="toggle"><li><details open=""><summary><strong><strong>Run-time integration via Web Components</strong></strong></summary><ul id="a8748c01-294b-4ea8-a67d-1bfa090d608f" class="bulleted-list"><li style="list-style-type:disc">Cách tiếp cận này cho phép chúng ta khai báo một HTML Custom Element, ví dụ như ta khai báo một HTML Custom Element <code>&lt;web-components-products&gt;&lt;/web-components-products&gt;</code> thì chỗ nào muốn sử dụng ta chỉ cần chèn đoạn mã <code>&lt;web-components-products&gt;&lt;/web-components-products&gt;</code> là có thể sử dụng được rồi.</li></ul><ul id="5d133751-6059-4180-962e-7696f4f4b56f" class="bulleted-list"><li style="list-style-type:disc">Ưu điểm:<ul id="042d31b6-c124-46cc-8197-9e403be30579" class="bulleted-list"><li style="list-style-type:circle">Không bị phụ thuộc dependencies giữa các dự án với nhau (ví dụ: khác version React giữa các dự án)</li></ul><ul id="51e6a9e4-b404-426f-9acf-a457c1ca1e92" class="bulleted-list"><li style="list-style-type:circle">Vì cho phép tạo một HTML Custom Element nên ta có thể gắn thẻ HTML Custom này vào bất cứ đoạn mã HTML nào, không quan trọng dự án đó đang sử dụng frontend framework nào</li></ul><ul id="ab808691-97ee-4e3e-845d-116212d6212b" class="bulleted-list"><li style="list-style-type:circle">Hỗ trợ Shadow DOM: cho phép style css độc lập, không ảnh hưởng css giữa các dự án với nhau</li></ul><ul id="6b693dd2-283c-4c86-85f0-25a9f8d83ece" class="bulleted-list"><li style="list-style-type:circle">Có thể phát triển theo hướng package (publish lên một registry) mà không cần phải có domain host cho dự án vì vậy đơn giản trong việc quản lý các version release.</li></ul></li></ul><ul id="064f3039-8b7c-4e44-8f27-1d1bf4487698" class="bulleted-list"><li style="list-style-type:disc">Hạn chế:<ul id="615aa856-9e91-4cc6-8252-32f2a0db26fd" class="bulleted-list"><li style="list-style-type:circle">Không thể chia sẻ tài nguyên giữa các dự án với nhau (ví dụ: sử dụng chung thư viện React)</li></ul></li></ul></details></li></ul><ul id="1f39a2a5-db51-4208-8836-09a0bb701789" class="toggle"><li><details open=""><summary><strong><strong>Module Federation Webpack 5</strong></strong></summary><ul id="cd5d66ca-7d5a-459a-abd7-103187444fcb" class="bulleted-list"><li style="list-style-type:disc">Module Federation là một tính năng mới của Webpack 5. Nó cho phép chúng ta cấu hình để một ứng dụng có thể dynamic load code từ một ứng dụng khác.</li></ul><ul id="2107c554-cb43-47bf-8e9f-384d8af2b7ea" class="bulleted-list"><li style="list-style-type:disc">Hiểu đơn giản là chúng ta có 2 ứng dụng được phát triển độc lập A và B, ứng dụng B là một phần nhỏ chức năng của ứng dụng A. Module Federation sẽ cho phép ta nhúng ứng dụng B và ứng dụng A và chia sẻ tài nguyên giữa chúng.</li></ul><ul id="781d376b-8d89-4a1d-8f92-fcf3ceb61bcd" class="bulleted-list"><li style="list-style-type:disc">Ưu điểm:<ul id="ecd1c9d1-74cd-4347-b270-fd650c2740b6" class="bulleted-list"><li style="list-style-type:circle">Có thể chia sẻ tài nguyên giữa các dự án. Ví dụ dự án A sử dụng React 16.x và dự án B cũng sử dụng React 16.x thì khi tải module B sẽ không cần phải tải thêm React một lần nữa, nếu 2 version khác nhau thì nó sẽ tự động tải thêm version React còn thiếu.</li></ul><ul id="70db1b01-97eb-4dec-ba05-76a40a92350b" class="bulleted-list"><li style="list-style-type:circle">Giao tiếp giữa các dự án một cách đơn giản, có thể sử dụng chung một Redux store giữa các dự án với nhau</li></ul></li></ul><ul id="3ec4a8ce-9cea-4ed4-a46a-80de1e29db2b" class="bulleted-list"><li style="list-style-type:disc">Hạn chế:<ul id="407c44e6-ecda-4d07-bd7b-bbf9ba4c5927" class="bulleted-list"><li style="list-style-type:circle">Các dự án phải sử dụng Module Federation của Webpack 5.x</li></ul><ul id="8481828b-27db-4630-a28b-b78a8fbb49dc" class="bulleted-list"><li style="list-style-type:circle">Buộc phải các dự án phải có các static domain để tải các bundle file tương ứng. Vì các chức năng Module Federation chỉ hỗ trợ cấu hình tải các file từ một remote url</li></ul></li></ul></details></li></ul></details></li></ul><p id="39448fd7-6288-4cb8-9a76-b3bdb31281bc" class="">
</p><p id="0707d84e-b123-4e70-b4c3-cca77a792e4e" class="">
</p><h3 id="498a9872-6002-4f76-9c50-8ee46713e0ac" class=""><mark class="highlight-red">GIT</mark></h3><hr id="d3980961-958d-4912-95d7-fce5c6a8c4ef"/><ul id="d59c47aa-e577-4063-a6b4-b9b693d93d8b" class="toggle"><li><details open=""><summary><strong>Tìm hiểu một số câu lệnh git</strong></summary><p id="72520c21-32a9-4d33-93be-73ff1f365f81" class=""><a href="http://thaunguyen.com/blog/software/giai-thich-chi-tiet-nhung-cau-lenh-thuong-dung-trong-git#git_revert">http://thaunguyen.com/blog/software/giai-thich-chi-tiet-nhung-cau-lenh-thuong-dung-trong-git#git_revert</a></p></details></li></ul><ul id="78cdf548-f221-4db3-aa7b-52dd4b179076" class="toggle"><li><details open=""><summary><strong><strong>Git fork là gì ? Sự khác nhau giữa git fork, branch và clone?</strong></strong></summary><ul id="8fea3d0e-65b6-42e0-acc4-b4d1116149dd" class="bulleted-list"><li style="list-style-type:disc"><strong>Git fork:</strong> là một bản copy của một repository (Kho chứa source code của bạn trên Github). Việc fork một repository cho phép bạn dễ dàng chỉnh sửa, thay đổi source code mà không ảnh hưởng tới source gốc.</li></ul><ul id="3a9132be-bd4a-43c5-aaca-b9b7071e8769" class="bulleted-list"><li style="list-style-type:disc"><strong>Git clone</strong>: khác với fork; nó là một bản remote local copy của một số kho lưu trữ. Khi bạn sao chép, bạn đang sao chép toàn bộ repo, bao gồm tất cả lịch sử và các nhánh.</li></ul><ul id="20c3bb94-572b-46f3-aca2-5588fcd9b9b1" class="bulleted-list"><li style="list-style-type:disc"><strong>Git branch</strong>: là một cơ chế để xử lý các thay đổi trong một kho lưu trữ duy nhất để cuối cùng merger chúng với phần còn lại của code. Branch là cái gì đó nằm trong một repo. Về mặt khái niệm, nó đại diện cho một luồng phát triển.</li></ul></details></li></ul><ul id="b800d998-e4ee-4515-83d5-a13dff1d852d" class="toggle"><li><details open=""><summary><strong><strong>Sự khác nhau giữa &quot;git pull&quot; and &quot;git fetch&quot;?</strong></strong></summary><ul id="d8f633c7-325e-4483-8a55-2ae800a0a5f7" class="bulleted-list"><li style="list-style-type:disc">Nhìn chung, git pull thực hiện git fetch theo sau là git merge</li></ul><ul id="7d44d3ea-9c67-4bdf-843c-36f41bb9343a" class="bulleted-list"><li style="list-style-type:disc">Khi bạn sử dụng <strong>pull: </strong><ul id="af7a0de6-23fc-44ea-a43d-2e8a145a0d13" class="bulleted-list"><li style="list-style-type:circle">git sẽ cố gắng tự động thực hiện công việc của bạn cho bạn. </li></ul><ul id="48c5c80c-e74d-442c-8176-18d2681a2cee" class="bulleted-list"><li style="list-style-type:circle">Vì vậy Git sẽ merger bất kỳ commit ở trong nhánh bạn đang làm việc. </li></ul><ul id="571e0620-c09f-4e9a-a71f-acc683920a8d" class="bulleted-list"><li style="list-style-type:circle">Tự động merger các commit mà không cho phép bạn xem chúng trước. </li></ul><ul id="d522e75c-fd51-4826-8762-cfc8d67c7408" class="bulleted-list"><li style="list-style-type:circle">Nếu bạn không quản lý chặt chẽ các branch của mình, bạn có thể gặp phải conflicts thường xuyên.</li></ul></li></ul><ul id="2aafc83b-9cbd-4764-a840-0e66b2580171" class="bulleted-list"><li style="list-style-type:disc">Khi bạn <strong>fetch:</strong> <ul id="91958ded-efcf-457b-a1d1-31b3fbf80f8e" class="bulleted-list"><li style="list-style-type:circle">git tập hợp bất kỳ commit nào từ target branch không tồn tại trong nhánh hiện tại của bạn và lưu trữ chúng trong local repository của bạn. </li></ul><ul id="e758f23d-8c6d-498f-bd82-04f1104bce45" class="bulleted-list"><li style="list-style-type:circle">Tuy nhiên, nó không merger chúng với nhánh hiện tại của bạn. </li></ul><ul id="7a4b035f-8cad-48d5-b58e-e9943ddd0628" class="bulleted-list"><li style="list-style-type:circle">Điều này đặc biệt hữu ích nếu bạn cần cập nhật kho lưu trữ của bạn, nhưng đang làm việc trên project rất dễ có thể bị ảnh hưởng nếu bạn cập nhật các file của mình. </li></ul><ul id="b221f29e-7777-4f8d-be3f-e951035d4ba1" class="bulleted-list"><li style="list-style-type:circle">Để merger các commit vào nhánh chính của bạn, bạn sử dụng merger.</li></ul></li></ul></details></li></ul><ul id="d3597cd2-35d6-47d8-aa20-55b922871f8d" class="toggle"><li><details open=""><summary><strong><strong>Làm thế nào để revert previous commit trong git?</strong></strong></summary><ul id="207e1d69-9b47-4cfa-8880-727613006d48" class="bulleted-list"><li style="list-style-type:disc">sử dụng git reset</li></ul></details></li></ul><ul id="17441d20-5ea2-4a53-88c5-14fd32fe5782" class="toggle"><li><details open=""><summary><strong><strong>&quot;git cherry-pick&quot; là gì?</strong></strong></summary><ul id="313f2e34-6354-41a6-b008-9d0ccf559de3" class="bulleted-list"><li style="list-style-type:disc">Lệnh git cherry-pick thường được sử dụng để xem các commit cụ thể từ một nhánh trong một repo trên một nhánh khác. </li></ul><ul id="be740844-d8ae-40b3-a890-9dccad6de925" class="bulleted-list"><li style="list-style-type:disc">Việc sử dụng phổ biến là commit chuyển tiếp hoặc back-port commits từ maintenance đến branch phát triển.</li></ul><ul id="b652faac-7ec8-4b74-8268-5ad0e235e74a" class="bulleted-list"><li style="list-style-type:disc">Điều này trái ngược với các cách khác như merger và rebase mà thường áp dụng nhiều commit vào một nhánh khác.</li></ul></details></li></ul><ul id="d76cbab3-ddcd-4c03-9a3e-d774220e5bc2" class="toggle"><li><details open=""><summary><strong><strong>Khi nào nên sử dụng &quot;git stash&quot;?</strong></strong></summary><ul id="f51702bc-78b0-456a-b40f-73cd8de56243" class="bulleted-list"><li style="list-style-type:disc">Lệnh git stash thực hiện uncommitted changes của bạn (both staged and unstaged), lưu chúng lại để sử dụng sau này và sau đó chuyển đổi chúng từ from your working copy.</li></ul><ul id="597de43d-5f5b-4936-a311-bbf3dd88bf23" class="bulleted-list"><li style="list-style-type:disc">Ta có thể sử dụng stashing là nếu ta phát hiện ra đã quên một gì đó trong lần commit cuối cùng và đã bắt đầu làm việc trên nhánh tiếp theo trong cùng một nhánh</li></ul></details></li></ul><ul id="f2034204-9a06-4a3a-8a34-ad8aed7307e6" class="toggle"><li><details open=""><summary><strong><strong>Khi nào bạn sử dụng &quot;git rebase&quot; thay vì &quot;git merge&quot;?</strong></strong></summary><ul id="e8b40752-e1fb-4e8f-8659-2b05aa00d80d" class="bulleted-list"><li style="list-style-type:disc">Cả hai lệnh này được thiết kế để tích hợp các thay đổi từ một nhánh này sang một nhánh khác.</li></ul><ul id="a59a39dc-e4a8-4fb2-9739-52e216e3a991" class="bulleted-list"><li style="list-style-type:disc">Khi nào dùng:<ul id="a50c9054-2595-47b1-b436-21f152702190" class="bulleted-list"><li style="list-style-type:circle">Nếu bạn có bất kỳ nghi ngờ, sử dụng merge.</li></ul><ul id="c77d019b-460f-4a3a-816a-bd4837f0bb4c" class="bulleted-list"><li style="list-style-type:circle">Sự lựa chọn cho rebase or merge dựa trên những gì bạn muốn lịch sử của bạn trông như thế nào.</li></ul></li></ul><ul id="683f5c66-c3eb-48b9-bb39-15c35ab6cb51" class="toggle"><li><details open=""><summary><strong>Nhiều yếu tố cần xem xét:</strong></summary><ul id="1a5206e9-91a7-47b2-b23b-a8a8094ddaae" class="bulleted-list"><li style="list-style-type:disc">Nhánh bạn có đang nhận được những thay đổi từ việc chia sẻ với các developers khác bên ngoài nhóm của bạn (ví dụ: nguồn mở, công khai) không? <p id="59566248-96b1-4c51-80b1-ff5df97bb96a" class="">→ Nếu vậy, đừng rebase. Rebase phá hủy nhánh và repo của các developers đó sẽ bị ảnh hưởng / không nhất quán trừ khi họ sử dụng lệnh git pull --rebase.</p></li></ul><ul id="1a3ac065-7327-4340-8305-071e6ee8ba1d" class="bulleted-list"><li style="list-style-type:disc">Development team có kỹ năng như thế nào? Rebase là một hoạt động phá hoại. <p id="995b0b32-78a6-4cea-a89e-69a3cae4ba71" class="">→ Điều đó có nghĩa, nếu bạn không áp dụng nó một cách chính xác, bạn có thể mất commit và / hoặc phá vỡ sự thống nhất repo của developers khác.</p></li></ul><ul id="655383e9-d538-4da7-872b-ef01e358a73f" class="bulleted-list"><li style="list-style-type:disc">Bản thân nhánh có đại diện cho thông tin hữu ích không? <p id="f6d932cd-4a0a-4c29-8862-5f59debd5a13" class="">→ Một số nhóm sử dụng mô hình nhánh cho mỗi nhánh, trong đó mỗi nhánh đại diện cho một feature (hoặc fixbug, hoặc tính năng phụ, vv) Trong mô hình này nhánh giúp xác định các tập hợp các commit liên quan. Trong trường hợp mô hình nhánh cho mỗi developer, chính nhánh không truyền tải bất kỳ thông tin bổ sung nào. Sẽ không có hại gì khi rebasing.</p></li></ul><ul id="93b0d594-caa5-44e9-b4c6-8c0bb54ae74e" class="bulleted-list"><li style="list-style-type:disc">Bạn có muốn revert những pull đã merger vì bất kỳ lý do nào không?<p id="58fa391f-72b8-4875-898d-ad9e42db0819" class="">→ Reverting a rebase sẽ hơi khó khăn và / hoặc không thể (nếu rebase có conflict) so với reverting a merge. Nếu bạn nghĩ rằng có thể bạn sẽ muốn revert sau đó sử dụng merge.</p></li></ul></details></li></ul><p id="5d64c27d-564c-4624-ba0f-95139828b18c" class="">
</p></details></li></ul><p id="6848569c-83b5-4c0c-8bd7-38927ab0af6e" class="">
</p><hr id="415a983a-b963-42e8-91a8-e6224e0af565"/><p id="f4c58184-7fd1-480c-9e19-3e2627fd4461" class="">
</p><p id="d33ed947-4604-4897-a322-95960d0f3e8b" class="">
</p><h3 id="5346049d-addd-41fd-a21f-2d07c26a4f45" class=""><mark class="highlight-red">TESTING</mark></h3><hr id="37a20faf-8e3e-4ebe-b7ef-cc57574e4aac"/><ul id="68c0f3f0-fe6b-4060-b9b8-eec51d8be507" class="toggle"><li><details open=""><summary><strong>Có những loại test nào ?</strong></summary><ul id="bebaa5f9-3c2e-4639-9756-30a7a694de85" class="bulleted-list"><li style="list-style-type:disc"><strong>Unit test: </strong>chủ yếu test <code>function</code>, chỉ test riêng lẻ một module trong code của bạn. Đối với <em>React</em> thì có thể xem đây là test một component</li></ul><ul id="ac559e41-44d7-4def-aec3-1a0ac808745d" class="bulleted-list"><li style="list-style-type:disc"><strong>Integration test: </strong>test sự liên kết giữa các component. Đôi khi chạy một mình không sao nhưng ghép lại thì ra cả một bầu trời đầy sao ????. Khi viết <em>integration test</em> thì chúng ta sẽ sử dụng dữ liệu giả để dễ dàng kiểm soát được đầu ra cuối cùng</li></ul><ul id="d3ba6af1-3608-42d3-8044-de224c6db107" class="bulleted-list"><li style="list-style-type:disc"><strong>End-to-end test (E2E): </strong>cũng giống như <em>integration test</em> nhưng chúng ta sẽ test như môi trường <em>production</em>. Loại test này giống y hệt cách các bạn hay test bằng tay, điểm khác biệt là các bạn sẽ tự động hóa quá trình này</li></ul></details></li></ul><ul id="c6ead6d8-dee9-4b5c-b808-038d4bba38d0" class="toggle"><li><details open=""><summary><strong>Cách phân bổ các loại test khi viết test trong react</strong></summary><ul id="b844bf6e-ebc2-4fff-94f9-c61daa54d5c9" class="bulleted-list"><li style="list-style-type:disc"><strong>Unit test</strong>: đảm bảo component được render mà không gây ra lỗi. Phần này cần có nhưng <em>không cần tập trung quá nhiều</em> vào nó</li></ul><ul id="c51a2443-02d8-4885-a65e-b5ae87b00ae2" class="bulleted-list"><li style="list-style-type:disc"><strong>Integration test</strong>: phần chúng ta <em>nên tập trung vào nhiều nhất</em> vì nó sẽ gần sát với thực tế nhất</li></ul><ul id="cdbaa374-3e02-4927-99c3-5d765e843139" class="bulleted-list"><li style="list-style-type:disc"><strong>E2E test</strong>: bài test phản ánh thực tế khi sử dụng sản phẩm. Tuy tính chính xác cao nhưng lại phụ thuộc vào các thành phần khác trong hệ thống như <em>database</em>, <em>API</em>, ... nên khá khó để kiểm soát đầu ra. Theo minh thì phần này chiếm tỉ lệ ít nhất trong tổng số các bài test</li></ul></details></li></ul><ul id="d4478307-ca7a-4e48-8923-063166738828" class="toggle"><li><details open=""><summary><strong>Các bước test trong react </strong></summary><ul id="d0b867eb-28d2-49f4-911f-a6e6de7786e9" class="bulleted-list"><li style="list-style-type:disc"><strong>Arrange</strong>: chuẩn bị input (dữ liệu đầu vào) cho bài test</li></ul><ul id="5e64597d-21a8-4dc6-8a98-c087a7b9c373" class="bulleted-list"><li style="list-style-type:disc"><strong>Act</strong>: thực hiện test (invoke function, trigger event <code>click</code>/<code>change</code>, ...)</li></ul><ul id="5dcc8d29-5078-4d93-a2b5-b648abba8dcd" class="bulleted-list"><li style="list-style-type:disc"><strong>Assert</strong>: kiểm tra output (kết quả)</li></ul></details></li></ul><ul id="a756738e-f46e-42d4-88cd-66dd29f411aa" class="toggle"><li><details open=""><summary><strong>Một số tool testing trong react </strong></summary><ul id="fa03cbf9-6c08-4fbf-8db9-aa4804bc0c16" class="bulleted-list"><li style="list-style-type:disc">React-testing-library</li></ul><ul id="226a90fc-36ba-4382-bfad-f004384925cf" class="bulleted-list"><li style="list-style-type:disc">Jest</li></ul><ul id="dd03413f-d569-4050-b214-2fce05c216c2" class="bulleted-list"><li style="list-style-type:disc"><strong><strong>Mocha</strong></strong></li></ul><ul id="b3651140-e15e-4e73-bf3d-f9c34e960860" class="bulleted-list"><li style="list-style-type:disc">Chai</li></ul><ul id="bbdc362d-5fd6-4a46-ae16-124983f1eea9" class="bulleted-list"><li style="list-style-type:disc">…</li></ul></details></li></ul><hr id="5ca689f6-4fa0-446b-a30e-bed3ae68f73e"/><p id="977f763e-35d2-47a3-98b6-bc9a02418760" class="">
</p><p id="5d17f7ef-57b6-4a9f-af76-20bf6c2c94d9" class="">
</p><h3 id="3e219c60-d31b-4f39-a48e-e02a743d4d73" class=""><mark class="highlight-red">DESIGN PATTERNS</mark></h3><hr id="98407f1e-2261-42ed-bbb0-f34c4c016d27"/><p id="03476e17-12d4-4763-b782-f31786417d3b" class=""><a href="https://codestus.com/posts/6-design-patterns-thong-dung-trong-javascript-can-biet">6 design patterns JS cần biết</a></p><p id="ede0ef85-31f1-4aa3-bcb8-6209f4021b81" class=""><a href="https://www.patterns.dev/posts/">pattern.dev</a></p><ul id="0729e466-6711-4904-8402-c4cd5d4f3b76" class="toggle"><li><details open=""><summary><strong>Các loại design pattern ?</strong></summary><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="eee68f54-b98b-4f2e-a083-476385a42e0c"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><em><strong>Design pattern là các mẫu lập trình phổ biến được xây dựng bởi các lập trình viên nhiều kinh nghiệm, nó giúp source code của chúng ta dễ đọc, dễ hiểu và dễ mở rộng về sau này. Có thể nói design pattern định nghĩa ra các tiêu chuẩn code và các mẫu lập trình mà từ đó chúng ta mới có hàng trăm nghìn thư viện lập trình như ngày hôm nay.</strong></em></div></figure><ul id="c6213bb9-6a4a-47db-a94e-70b2c0de8ed3" class="bulleted-list"><li style="list-style-type:disc">Được chia làm 3 nhóm:<ul id="e163a37f-5d50-40d4-b97e-66850a460b8a" class="toggle"><li><details open=""><summary><strong><strong>Creational Patterns: </strong></strong>Nhóm này được dùng để phục vụ cho việc khởi tạo đối tượng.</summary><ol type="1" id="463300c5-6156-409b-a0d4-ae1b85f7d91b" class="numbered-list" start="1"><li><mark class="highlight-red"><strong>Singleton</strong></mark>: Tạo ra đối tượng sử dụng cho toàn chương trình và chỉ khởi tạo 1 lần</li></ol><ol type="1" id="ac07f3a4-abb5-474c-9507-204a80700377" class="numbered-list" start="2"><li><strong><mark class="highlight-red">Factory</mark></strong>: Tạo ra các đối tượng theo một quy tắc nhất định</li></ol><ol type="1" id="441020a0-50c2-45df-8762-894b31fc284f" class="numbered-list" start="3"><li><mark class="highlight-red"><strong>Factory Method</strong></mark>: Tạo ra các đối tượng theo một quy tắc nhất định, nhưng cho phép lớp thừa kế quy định đối tượng sẽ được tạo ra</li></ol><ol type="1" id="bd4000a0-6fa8-45d8-a325-850d34ff3eeb" class="numbered-list" start="4"><li><mark class="highlight-red"><strong>Abstract Factory</strong></mark>: Tạo ra các đối tượng theo một quy tắc nhất định mà không cần biết kiểu của đối tượng</li></ol><ol type="1" id="1ea32948-0b3c-4c23-a002-c8ce89558534" class="numbered-list" start="5"><li><mark class="highlight-red"><strong>Builder</strong></mark>: Thường dùng để tạo các đối tượng readonly hay immutable</li></ol><ol type="1" id="49d832ce-a623-447f-818b-74391128a92c" class="numbered-list" start="6"><li><mark class="highlight-red"><strong>Prototype</strong></mark>: Thường dùng để clone 1 đối tượng từ 1 đối tượng có sẵn</li></ol><ol type="1" id="1fda39ce-09e4-4126-a161-ad33da9a8a18" class="numbered-list" start="7"><li><mark class="highlight-red"><strong>Object Pool:</strong></mark> Dùng để tạo ra các đối tượng có thể dùng lại nhiều lần để tránh khởi tạo không cần thiết</li></ol></details></li></ul><ul id="952368ef-d81b-44b4-8180-956e00612dcf" class="toggle"><li><details open=""><summary><strong><strong>Behavioral Patterns: </strong></strong>Nhóm này phục vụ cho việc xử lý các hành động (action, request, event)</summary><ol type="1" id="831507df-124f-4c3c-9821-933cbfcc5d46" class="numbered-list" start="1"><li><mark class="highlight-red"><strong>Chain of Responsibility</strong></mark>: Là một chuỗi xử lý cho một hành động</li></ol><ol type="1" id="ac9fa494-69c5-4bdc-9e84-bf04ef6ba62b" class="numbered-list" start="2"><li><mark class="highlight-red"><strong>Command</strong></mark>: Xử lý hành động theo kiểu tương ứng</li></ol><ol type="1" id="698dd0b8-1a37-476f-8c25-fd210b7852c0" class="numbered-list" start="3"><li><mark class="highlight-red"><strong>Interpreter</strong></mark>: Chuyên từ đối tượng này sang đối tượng khác</li></ol><ol type="1" id="23fbc29c-1f22-4461-becc-7b1794b4efc0" class="numbered-list" start="4"><li><mark class="highlight-red"><strong>Iterator</strong></mark>: Dùng để duyệt qua một collection như bạn vẫn hay dùng vòng for với List và Set</li></ol><ol type="1" id="0d387dd8-8921-43f5-a95e-b01c71589a1c" class="numbered-list" start="5"><li><mark class="highlight-red"><strong>Mediator</strong></mark>: Định nghĩ ra một đối tượng sử dụng chung cho các lớp, ví dụ đối tượng Graphic sẽ được sử dụng bởi các lớp Button, TextView, ...</li></ol><ol type="1" id="00169182-52a7-4670-be06-cd66b6f82e2e" class="numbered-list" start="6"><li><mark class="highlight-red"><strong>Memento</strong></mark>: Dùng để quản lý trạng thái và trở lại trạng thái trước khi cần thiết, giống như undo và redo</li></ol><ol type="1" id="68f6fb6f-62ae-408a-8345-9d1c2efa2260" class="numbered-list" start="7"><li><mark class="highlight-red"><strong>Observer</strong></mark>: Lắng nghe một sự kiện sẽ xảy đến và xử lý sự kiện đó</li></ol><ol type="1" id="9decaa19-081c-407d-857b-dfcd2c9e19ed" class="numbered-list" start="8"><li><mark class="highlight-red"><strong>Strategy</strong></mark>: Đưa ra các xử lý tương ứng với hành động xảy đến</li></ol><ol type="1" id="55d2d1a6-def9-471a-b7cf-695e6f401e2c" class="numbered-list" start="9"><li><mark class="highlight-red"><strong>Template Method</strong></mark>: Quy định trình tự gọi hàm để đảm bảo lập trình viên không bị mắc sai lầm, nếu bạn dùng Android bạn sẽ thấy các hàm onCreate, onStart, ... đây là 1 trong những design pattern quan trọng nhất của Android</li></ol><ol type="1" id="9ae9d006-1b56-4b7d-a317-5677d1e24965" class="numbered-list" start="10"><li><mark class="highlight-red"><strong>Visitor</strong></mark>: &quot;Thăm quan&quot; các đối tượng trong một mảng hay 1 collection</li></ol><ol type="1" id="3f433725-9be2-46ce-8121-1604ff121541" class="numbered-list" start="11"><li><mark class="highlight-red"><strong>Null Object</strong></mark>: Có thể hiểu đơn giản là if (value == null) do something else do something</li></ol></details></li></ul><ul id="8d5c2352-2705-45d1-9be4-9b0d3b9375c9" class="toggle"><li><details open=""><summary><strong><strong>Structural Patterns: </strong></strong>Nhóm này phục vụ cho việc kết nối các đối tượng và mở rộng hệ thống</summary><ol type="1" id="c05f33e1-9be2-4781-9180-4c6eeab4c720" class="numbered-list" start="1"><li><mark class="highlight-red"><strong>Adapter</strong></mark>: Chuyển một interface của một class sang 1 interface của 1 class khác, cảm giác nó cũng hơi giống giống Command pattern</li></ol><ol type="1" id="0126e821-a981-4f6f-8c1b-05cbba55c501" class="numbered-list" start="2"><li><mark class="highlight-red"><strong>Bridge</strong></mark>: Giữ lại các phần giống nhau, và tách các phần khác nhau ra thành các lớp riêng biệt</li></ol><ol type="1" id="fb5456e7-e26c-4525-897e-1addb2264dd3" class="numbered-list" start="3"><li><mark class="highlight-red"><strong>Composite</strong></mark>: Kết hợp các lớp lại với nhau để tránh phải extends hay implements quá nhiều lớp và interface, ví dụ chúng ta hay có lớp service sử dụng rất nhiều lớp repo và các service khác</li></ol><ol type="1" id="60834ec5-4f60-4a1e-8b6a-4c7fade3ef37" class="numbered-list" start="4"><li><mark class="highlight-red"><strong>Decorator</strong></mark>: Là lớp để &quot;trang hoàng&quot; thêm cho đối tượng của chúng ta trước khi đưa đối tượng này vào sử dụng hoặc lưu trữ, phản hồi</li></ol><ol type="1" id="f8c53dbf-da7e-4b74-864d-0b12abec0f85" class="numbered-list" start="5"><li><mark class="highlight-red"><strong>Flyweight</strong></mark>: Dùng để chia sẻ một lượng lớn các đối tượng được khởi tạo một lần</li></ol><ol type="1" id="348b00ff-0eb8-43ec-8cb3-2e3e13c0fdfd" class="numbered-list" start="6"><li><mark class="highlight-red"><strong>Proxy</strong></mark>: Dùng để wrap lại đối tượng thực tế, thông thường chúng ta sử dụng wrap lại các đối tượng của thư viện bằng đối tượng của chúng ta, để dễ dàng thay đổi thư viện sau này</li></ol></details></li></ul></li></ul></details></li></ul><ul id="602cb832-9501-4389-b670-92bd79778ed0" class="toggle"><li><details open=""><summary><strong>Các design pattern trong react?</strong></summary><ul id="ca992d19-f8d8-42f3-aa43-a7ed94032402" class="bulleted-list"><li style="list-style-type:disc">HOC pattern</li></ul><ul id="daf7ba12-202b-476b-a848-b96a2b58bda4" class="bulleted-list"><li style="list-style-type:disc">Render props pattern</li></ul><ul id="9e16dd64-297e-43be-9397-f3f0421b01d8" class="bulleted-list"><li style="list-style-type:disc">Hooks pattern</li></ul><ul id="74e0b5c6-467d-4453-aa93-269476fe5aef" class="bulleted-list"><li style="list-style-type:disc">Compound pattern</li></ul><p id="280db0bc-a81c-4dba-8e54-16491db8999a" class="">
</p><p id="193336ad-54b4-4b49-b926-734e226c3ed0" class="">
</p></details></li></ul><p id="58854652-c4a8-4b4f-b6c7-7a02d1d4009e" class="">
</p><hr id="a9a3fd45-52a8-425d-8d64-43715939ef23"/><p id="29e6419e-fdde-4fa8-94fb-831f844ceb4e" class="">
</p><p id="e53a4bbc-ec6a-4c2b-bdbc-b80ff1e1c1a2" class="">
</p><p id="dfef97db-080b-4553-8608-64c32bb5c97c" class="">
</p><h3 id="1178d49f-8d95-44e9-84e1-4559e0249cf3" class=""><mark class="highlight-red"><strong>SECURITY</strong></mark></h3><hr id="f0f1c111-d273-4eac-87b2-9cf3d9e06c52"/><ul id="155875f9-81b6-4405-981b-1ddade3a2501" class="bulleted-list"><li style="list-style-type:disc"><a href="https://codestus.com/posts/cac-van-de-ve-bao-mat-can-nam-trong-react">Các vấn đề bảo mật cần nắm trong react</a></li></ul><ul id="b818caa5-6b36-4f4d-9033-6c2dd8df4604" class="bulleted-list"><li style="list-style-type:disc"><a href="https://viblo.asia/p/cai-thien-bao-mat-trong-reactjs-oOVlYj6n58W">Cải thiện bảo mật trong React</a></li></ul><p id="2af6f7a0-8c97-4d41-938a-783bb9f1a697" class="">
</p><hr id="33acdb75-9c77-4be8-8bf9-94fecd9e577b"/><p id="128fda5a-9e6c-45ec-9a6b-ef344bc282f8" class="">
</p><p id="4803d362-73c9-4c54-8608-344b63e0588c" class=""><mark class="highlight-red"><strong>ĐỌC THÊM</strong></mark></p><hr id="a538cee6-1e05-4fc2-a91f-d91ef94765ae"/><ul id="eaa110ce-3cc0-4509-8168-6d02877cf1b9" class="bulleted-list"><li style="list-style-type:disc"><a href="https://vi.reactjs.org/docs/hooks-faq.html"><strong>Câu hỏi hooks thường gặp</strong></a></li></ul><ul id="5811b874-fdb3-4f9d-a74a-d956717bbc02" class="bulleted-list"><li style="list-style-type:disc"><a href="https://dmitripavlutin.com/simple-but-tricky-javascript-interview-questions/"><strong>Trick interview JS</strong></a></li></ul><ul id="176c7707-3d2e-4421-8819-c5affde92de8" class="bulleted-list"><li style="list-style-type:disc"><a href="https://ren0503.github.io/posts/"><strong>Một số bài viết hay với react</strong></a></li></ul><p id="912e6dd1-0b50-4093-8b94-3a7ffbc28c2f" class="">
</p></div></article></body></html>